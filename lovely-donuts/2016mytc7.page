1001.
-----

1002. Balls and Boxes\[ruclion\]
--------------------------------

打表找规律

1003. Colosseo \[skyxuan\]
--------------------------

首先通过topo排序判断两部分的全序关系是否均满足传递性。如果是的话，枚举第二部分中的每个点，看它是否能放在第一部分中，以及它能放在哪个位置，因为给出的是一个竞赛图，所以这个位置一定是唯一的。把第二部分中的能插入第一部分中的点拿出来按topo序排好，标上权值为插入到第一部分中的位置，那么这个序列的LIS就是答案。

1004. Distance \[skyxuan\]
--------------------------

根据题目中$d(x,y)$的定义，可知$d(x,y)=num[x]+num[y]-2\times num[gcd(x,y)]$，其中$num[x]$表示$x$的质因子的个数。

所以对于插入和删除操作，我们枚举$x$的每个约数$v$，对每个约数$v$维护一个堆，把$num[x]$插入/删除，查询的时候就枚举x的约数从堆中取出最小值来更新答案。

由于$num[x]$最大也不会超过$20$，所以可以直接用$C[v][num[x]]$记录约数为v的堆中当前的$num[x]$的个数，再用一个$mask[v]$表示约数$v$当前堆中存在的$num[x]$的值，更新的时候仍然枚举$x$的约数来更新，查询的时候只需要枚举约数找$mask[v]$的$lowbit$即可。这样实现比上一种做法少一个$\log$

这道题由于每个数的范围是$10^6$，而询问总次数才$3\times10^5$，所以直接对每次询问的$x$,$O(\sqrt{x})$的寻找约数，如果预处理出每个数的约数反而会T

1005. Elegant Construction \[skyxuan\]
--------------------------------------

把点按其后继的个数排序，之后第$i$个点的后继个数最多为$i-1$，否则无解。如果有解的话只需要暴力向$1$到$a[i]$连边就一定是对的。

1006.
-----

1007. Golden Week \[ruclion\]
-----------------------------

树形dp+优化。f\[i\]\[j\]代表考虑以i为根的子树，1到i的距离是j，所有终点在i的子树里的游客总花费（重点是从1到终点的总花费）的最大值。对于所有游客，总是可以只考虑j恰好等于某一个游客的钱的关键值或者钱是0.之后的转移枚举u到v的这个边的价值，计算f\[u\]\[w\]时，对于一个儿子v，它可以选f\[v\]\[x\],只要x大于等于w就好，这时候因为f\[v\]\[x\]是总花费，可以预处理出最大的那个x。

1008. Hearthstone \[ruclion\]
-----------------------------

二进制枚举抽到手中的B卡是什么，个数为x，那么A卡的张数为x-1，最后一个是B卡，前面是f\[x-1\]\[x-1\]。f\[x\]\[y\]是放了x个B，y个A，并且每一个位置的前面的A的个数大于等于B的个数。之后把这样的方案数算出来，注意乘组合数，注意B卡拿完的特殊情况，分为恰巧拿完B卡和所有的卡都拿完了两种情况。

1009.
-----

1010. Joint Stacks \[skyxuan\]
------------------------------

`__gnu_pbds::priority_queue<T>`
可合并堆，默认为pairing\_heap，插入和合并操作都是$O(1)$的，其他操作均摊$O(\log n)$

1011.
-----

1012. Lights \[skyxuan\]
------------------------

首先分左上和右上两个方向来判断，如果两个方向都是两两可达的那么整个图就是两两可达的。

对点$p(x_0,y_0)$的左上方的点来说，先找到与$p$点$x$坐标相等的距离它最近的点，设为$p_1(x_0,y_1)$以及$y$坐标相等的距离它最近的点，设为$p2(x_1, y_0)$在$x \leq x1$的区域内的点如果点$p_2$是可达的那么点$p$就是可达的，在$y \leq y_1$区域的点如果点$p_1$是可达的那么点$p$就是可达的，在$p_1$和$p_2$都判定过之后剩下的只有$x1<x<x0$且$y1<y<y0$区域内的点，如果这个区域内有点那么点$p$不可能到达。所以我们仅需要判定这个矩形内是否有点。

Summary:
--------

-   skyxuan:
    今天的失误应该是12在刚开始没有发现做法是错的，DAG判到达点的个数必须通过bitset来做，简单的通过虚拟节点的做法也是行不通的。08和建坤讨论了算法框架后就没管了，结果发现是他少乘了个组合数。应该帮他把公式再仔细推一下。最近感觉程序错了之后还没有仔细看自己代码是不是错了就开始怀疑思路有问题，应该先把每一步都重新确定一下。
-   ruclion:12第一次贪心思路思考不成熟，应该先独立判定贪心思路是对的，如果判定不出来，要跟队友认真讲，并且队友给自己将后要确实自己也判定是对了之后再写。12因为第一次思路是错的，浪费了时间；之后是08的失误，写题之前先判定思路到底，再在脑子中模拟写的过程，其中重要的公式写清楚。写完之后wa了要先看代码实现思路的正确性，包括代码没敲错和思路完整性的实现（是否漏了想的思路中的部分，是否这样实现不能正确描述思路），之后怀疑思路正确性（包括认真重新确认思路，特殊情况，手算小样例），之后读题。08失误在思路和代码的转换中，判定过正确性之后，重要的公式没乘组合数，公式的实现对思路的描述是不对的。之后过不了样例，先查代码写错了没，没有写错，要看下对思路的实现对不对，漏了这个环节，直接去怀疑思路的问题了。浪费了时间。12最后的贪心思路，自己没有独立判定出来正误，找了队友，队友和我觉着挺对。但是实现的代码并不能准确描述思路的贪心，因此wa了。检查了代码没写错，想了下贪心的思路感觉没错，仍然是思路对应到代码上是不准确的。

