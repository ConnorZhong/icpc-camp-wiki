A. Peter and Snow Blower
------------------------

找到多边形上到给出点的最近和最远距离就能求出圆环的面积了。最远距离一定在多边形顶点处取得，最近距离可能是到多边形顶点的距离或到多边形某条边的距离。

B. Skills
---------

排序后预处理出把$k$个点变成最大的花费和把最小值提升到第$k$小点的花费，之后枚举把几个点变为最大，二分出该序列的最小值，或使用$two-point$达到$O(n)$的复杂度。

C. Necklace
-----------

首先发现如果有多于$1$种颜色的个数是奇数，那么无论如何都无法组成回文串。

如果所有的颜色个数均为偶数，那么一定可分为$gcd(a_1, \dots, a_n)$堆，每堆内随便放，堆与堆之间每次反着放，因为每种颜色的个数均为偶数，这样放完一定能首尾接上。

如果有一种颜色的个数为奇数，设该颜色为$i$，我们仍然分为$gcd(a_1, \dots, a_n)$堆，这个数一定是奇数，所以每堆内其他颜色的个数一定是偶数，且颜色$i$的个数是奇数，对这样的组合我们很容易的构造出一种回文串：形如aabcbaa。这样所有堆拼起来后仍然是回文串。

D. Kingdom and its Cities
-------------------------

-   解法1

对于一组询问来说，我们可以简单的采用树dp来解决这个问题，fn0fn1分别代表当前子树中有无关键节点和上面联通的情况下最少删几个点，转移要考虑：blablabla

对于多组询问，因为询问总点数是1e5级别的，所以我们可以对每组询问建一个虚数，其中只包含当前询问的节点以及这些点的LCA，这样总的dp复杂度仍然是1e5的。

我们把每个询问的k个节点按照dfs序进行排序，之后仅需把相邻两个元素的LCA加入集合中就保证他们两两的LCA均在集合中了。把新的集合按照dfs序进行排列后，新的树可以简单的通过维护一个顶点的栈来构建出来。

-   解法2

我们考虑贪心的来解决这个问题，对于一个子树

E. Puzzle Lover
---------------
