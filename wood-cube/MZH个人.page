---
title: MZH个人
...

#黑魔法备忘录

[黑魔法备忘录]()

# 简单易懂的二维几何

## AOJ 1198

给定平面上一些圆，任意两圆不会相切（保证没有精度问题），且任意三个圆没有公共点。询问两个点能否不穿过圆边界互相到达。

如果询问点中有点在圆内，直接判断包含两个点的圆的集合是否相同。否则点在由圆弧围成的区域中，因为这时点不会在圆内，可以把这些区域和弓形一起处理成多边形，然后判断所在多边形是否相同。

# 293C

CF的double好慢呜呜, 枚举约数a+b和a解方程不能过.
$$\prod_{cyc}(a+b) = \frac{(a+b+c)^3 - a^3 - b^3 - c^3}{3}$$

# 464E && 702F

函数式线段树, Merge-Split Treap

#2016-08-29

## 284A

判断原根可以$O(1)$空间的做。。虽然不知道有什么用。

#2016-05-05

## 183B

枚举两个点确定一条直线，再枚举所有点判断是否在这条直线上，更新答案。

## 594B

最优解应在导数相同时出现，即在起点和终点处传感器位置相同时出现。在$0 \leq x \leq 1$时有$\arcsin(x) - x$和$\arcsin(x) + x$单调递增，二分答案求解。

## 314D

把坐标轴旋转$\pi/4$后二分答案，问题转化为每个点限制所放直线交点在以其为中心的十字形内。对$x_i$排序后，使用十字形中纵条限制的点是一个连续的区间答案会更优。对排序后的数组维护前缀后缀中$y_i$的最大值和最小值，通过双指针扫描判断是否有解。

## 55E

先把问题转化为求有多少个三角形不包括询问的点。特判掉询问点在凸包外的情况，其余情况下若询问点在凸包点的一个三角形外，它一定恰在三角形一条线段的外边。使用双指针扫描，对凸包上每个点求出最远的点使得所在直线在询问点的右边，统计答案。

#2016-05-04

## 106E

最小球覆盖

## SPOJ GOODG

$$
\begin{align}
f(n) &= \max_{k=0}^{n-1} \{ f(k) - (n - k)d_k \} + a_n \\
     &= \max_{k=0}^{n-1} \{-n*d_k + f(k)+k * d_k \} + a_n
\end{align}
$$
横坐标不单调但直线斜率单调的斜率优化，使用cdq分治并在求凸壳的排序时使用归并排序可做到$O(nlogn)$。

## 333E

先二分答案，问题转化为求是否存在三角形三边均大于$mid$。枚举三角形的一个点，找出所有距离其大于$mid$的点求出凸包，再用旋转卡壳求出凸包上最远的两个点的距离。求凸包可以先对所有点集排好序避免每次的排序，总时间复杂度$O(n^2logn)$。

#2016-04-22

## BZOJ 4544

为什么会这样呢。。

#2016-04-21

## HDU 4622

对原串的每一个前缀$prefix$构建后缀自动机，并统计询问串为$prefix$的后缀时的答案。对后缀自动机的每个状态$p$求出其$right_p$集合中的最大值$rmax_p$，记$min_p = val_{par_p} + 1$，$max_p = val_p$，并统计该节点对答案的贡献。具体实现时将$ans[rmax_p - max_p][\left| prefix \right|] - 1$，$ans[rmax_p - min_p + 1][\left| prefix \right|] + 1$，并做两次后缀和即可。

## HDU 4436

将所有输入串构建成多串后缀自动机。对每个状态$p$记录$sum_p$表示起始状态到$p$的所有可能子串的和，$path_p$表示起始状态到$p$的所有可能子串个数，即可按拓扑序进行DP。因为数字不能包括前导0在转移时应忽视从起点开始的$nxt[0]$边。

#2016-04-20

## SPOJ LCS2

对第一个串构建后缀自动机，用其他的串在上面跑一遍。类似LCS中的做法维护$lcs$，并将$lcs$更新在自动机的节点上，并通过$par$树将节点上记录的值更新到所有祖先。对每个节点用其他串匹配到这个节点的$lcs_{p,i}$和节点的$val_p$中的最小值更新答案。SPOJ时限很紧求拓扑序时需使用基数排序。

#2016-04-19

##30E

最优解一定出在中间串取回文半径时的值。枚举中间串的中心，将中间串贪心取为最大，并将前后串取为原串与原串取反后做KMP能匹配到的最大位置和右串剩余最大长度的较小值。

## UVa 719

将原串翻倍后构建后缀自动机，从起点开始沿最小的边走$\left|S\right|$步。

##SPOJ LCS

对$A$串构建后缀自动机后用$B$串在上面跑一遍。维护变量$lcs$表示当前匹配到的长度，每次转移时如果有转移的边则进行转移，并将$lcs+1$；否则沿$par$向上找最近的有转移边的状态，并将$lcs$更新为当前的$val$，再进行转移。

## SPOJ NSUBSTR

先对原串构建后缀自动机。对每个状态$p$计算出集合$right_p$的大小来更新$f[val_p]$，然后反向用$f[i + 1]$更新$f[i]$。

#2016-04-18

##17E

先将问题转化为有多少对回文子串互不相交。用Manacher求出每个位置的回文半径，再通过前缀和求出每个位置有多少个回文串起始/结束计算答案。

##BZOJ2565

对每个位置求出以它起始/结束的回文串的最大长度。以结束为例，每个位置的答案应来自左侧能覆盖到它的中心最左的回文子串。将Manacher得到的极长回文子串按位置顺序扫一遍，每个极长回文子串更新在其之前覆盖不到的点的答案即可。

##BZOJ2342

对每个回文串中心寻找左侧串的子中心。子中心应满足在中心回文半径的一半范围内，且子中心回文半径能覆盖到中心。所有合法子中心中最远离中心的更新答案。从左向右枚举中心位置，用线段树维护插入/删除一个数，查询区间内最小的数。

#2016-04-15

##241C

由$n\leq100$可知最多只会碰撞100次。枚举起始和结束时的方向和碰撞次数可算出起始的角度，暴力模拟。

##50C

设圆点集凸包为$P_0(x_0, y_0), P_1(x_1, y_1), \cdots, P_{m-1}(x_{m-1}, y_{m-1})$，则答案为$\sum_{k=0}^{m-1} \max\{\left| {x_i - x_{i+1 \bmod m}}\right|, \left| {y_i - y_{(i+1) \bmod m}}\right| \} + 4$。不会证。

##13B

枚举线段对应的位置直接判断，为避免精度问题需使用全整数运算。

#2016-04-14

##199B

一个圆能被画出等价于它不与另一个圆环的两个圆相交，且不被另一个圆环完全包含。设圆为$O$，圆环中较小的圆为$C_1$，较大的圆为$C_2$。圆$O$不被圆环$(C_1, C_2)$包含可分为两种情况：圆$C_1$内含/内切于圆$O$且圆$O$内含/内切于圆$C_2$；圆$C_1$相离/外切于圆$O$且圆$O$内含/内切于圆$C_2$。

##385D

探照灯覆盖的线段不相交时答案更优。状压DP即可。

#2016-04-11

##660E

对每个非空的子序列求有多少个串能匹配它。设子序列长为$k$，在与串做匹配时匹配到了串的第$j$个字符，则共有$\binom{j-1}{k-1}(m-1)^{j-k}m^{n-j}$个这样的串。
<p>
$$
\begin{align}
  ans &= m^n + \sum_{k=1}^{n} \sum_{j=k}^{n} \binom{j-1}{k-1} (m-1)^{j-k} m^{n-j} m^k \\
      &= m^n + \sum_{k=1}^{n} \sum_{j=0}^{n-k} \binom{j+k-1}{k-1} (m-1)^j m^{n-j} \\
      &= m^n + \sum_{j=0}^{n-1} \sum_{k=1}^{n-j} \binom{j+k-1}{k-1} (m-1)^j m^{n-j} \\
      &= m^n + \sum_{j=0}^{n-1} (m-1)^j m^{n-j} \sum_{k=0}^{n-j-1} \binom{j+k}{k} \\
      &= m^n + \sum_{j=0}^{n-1} (m-1)^j m^{n-j} \binom{n}{j+1}
\end{align}
$$
</p>

##660F

使用分治。假设做到了区间$[left, right)$，需求出选择了$a_{mid}$的最大值。设$f(l,r)$表示恰选取了$[l,r)$区间内所有值时的答案。

<p>
$$
\begin{align}
  f(l,r) &= \sum_{k=l}^{r-1}(k-l+1)a_k \\
         &= \sum_{k=1}^{mid-1}(k-l+1)a_k + \sum_{k=mid}^{r-1}(k-mid+1)a_k + (mid-l)\sum_{k=mid}^{r-1}a_k \\
         &= f(l,mid) + f(mid,r) + (mid-l)\sum_{k=mid}^{r-1}a_k
\end{align}
$$
</p>

设$g(r)=\max_{k=left}^{mid}\{f(k,r)\}$，则可使用维护维护点$(mid-l,f(l,mid))$的上凸壳进行二分的斜率优化DP求出。总时间复杂度为$O(nlog^2n)$。

##120J

平面最近点对。注意同一个点变换出的四个点间的距离不应计算。

##33D

将圆按半径排序。每个圆以包含它的半径最小的圆做父亲，建成一棵树，并求出每对点间的距离。对每个点求包含它的半径最小的圆作为其在树中对应的点，输出答案。

##65C

由球的速度不大于人的速度可知若对时刻$t$可行，则对任意时刻$s>t$也应可行。对每条线段二分即可。