Summary
=======

D题被卡hash，有点不长记性，下次cf上hash要牛逼点才行。C题傻逼错误，当时想着应该没有边界条件，结果是m=1的时候，日狗了。B题傻逼题，想成神题就扔了。强者什么情况下都能做得好，太弱了，下次比赛前好好休息下，继续加油。

A
=

题解： 傻逼bfs题

B
=

题意： 给你一个序列，定义一个序列h\[1...n\]的价值L(h) if n &lt; 2, L(h)
= 0 if n &gt;= 2, L(h) = max( \[(|h\[j\]-h\[i\]|)/(j-i)\] ) 1 &lt;= i
&lt; j &lt;= n

有q次询问，每次询问h\[l..r\]这个序列的所有子序列的价值和。

题解：
仔细观察可以发现，最大值肯定是某个相邻的绝对值，对于每次询问用一个单调栈搞一下就好了，比赛中太搓了，看到过题人数这么多果断应该选择再好好研究下，下次要注意。

C
=

题意：
有n场比赛，m个人参加，一个人在一场比赛的得分为1-m，每个人该场比赛的得分都不同，总得分为所有比赛得分和。对于一个人的rank值为所有总得分比他总得分小的人的个数加一。现在你知道你每场比赛的得分，问期望rank值是多少。

题解：
设dp\[i\]\[j\]表示对于某个固定的人前i场比赛得分为j的概率，然后搞一下前缀和就可以快速计算dp值了，m=1的时候不特判的话会除0导致答案错误，不知道昨天在干嘛，太弱太晕。

D
=

题意：
给n个点的有根树，每个节点给个字母和c值，对于每个节点的价值为c加上起始为该节点，结尾为子树所有节点的不同的串的个数。问最大的价值是多少，有多少个结点是这个价值。

题解：
dfs一遍对于每个节点求出节点到根的哈希值，然后对于每个节点用一个set维护好该子树所有不同的哈希值，启发式合并下就好，复杂度为O(nloglog)。然后被卡哈希了，加了个哈希值搞个pair才过，sad。
