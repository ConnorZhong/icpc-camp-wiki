1002 Classic Quotation
----------------------

upsolved by Cabinfever

------------------------------------------------------------------------

Cabinfever's solution:

（题解csy说得很详细了，这里复述一下，并补充$s_{i,j}$和$suf_{i,j}$的具体求法）

假定我们使用KMP算法，对每个询问暴力求解，设：

$pref_i$表示$S$的的前缀$i$与$T$进行KMP后KMP的指针到达了哪里。

$preg_i$表示$S$的前缀$i$中$T$出现的次数。

$suf_{i,j}$表示从$S$的后缀$i$，从失配指针$j$开始KMP，能匹配多少$T$。

那么前缀$i$和后缀$j$拼起来后，T的个数为$preg_i + suf{j,pref_i}$。

那么对于询问$L$，$R$的答案为：

$ans = \sum\limits_{i = 1}^{L}\sum\limits_{j = R}^{n}(preg_i+suf_{j,pref_i})$.

但是复杂度太高了，我们发现$preg_i$与$j$并无关系，所以我们可以利用前缀和$O(1)$求得$\sum\limits_{i = 1}^{L}\sum\limits_{j = R}^{n}preg_i$

同样地，我们思考能不能用后缀和维护$suf_{j,pref_i}$，思考一下可以发现它只与$pref_i$的值有关，我们并不需要知道他的i到底是多少，而$pref_i$的值域是$[0,m)$，所以我们可以算出每个前缀中，每个适配指针有多少个，我们就可以$O(m)$地求到${\sum\limits_{i = 1}^{L}\sum\limits_{j = R}^{n}(suf_{j,pref_i}}$

用$preg$和$suf$表示$preg$的前缀和$suf$的后缀，$s_{i,j}$表示前$i$个中$pref$为$j$的个数，对答案$ans$我们就有了新的表示：

$ans = (n - R + 1)preg_L + \sum\limits_{i = 0}^{m-1}(s_{L,i} \times suf_{R,i})$

新的问题是怎么求的$s$和$suf$

$s$在对$S$做$KMP$时就可以轻松求出。对于未做后缀和的$suf$，因为字符集为$26$，所以我们可以对每个失配指针$i$去枚举假设碰到字母$j$后，是否匹配和新的失配指针并记录到$nxt2$数组中，这样我们可以类似dp的算出$suf$，$suf[i][j] = isMatch[j][a[i]] + suf[i+1][nxt2[j][a[i]]]$

1003 Counting Divisors
----------------------

solved by ConnorZhong

------------------------------------------------------------------------

ConnorZhong's Solution：

只需要筛出 $L,R$
之间的数的所有质因数，进行因式分解，每个不同的质因数出现的次数
$+1$，都乘起来就可以了。$k$ 次方相当于每个质因数出现次数翻了 $k$ 倍。

1005 Lazy Running
-----------------

upsolved by hzh

------------------------------------------------------------------------

hzh's Solution：

首先我们可以随意找一个循环节，例如我们随意走两遍d（1,2）的边，将d（1,2)$\times$
2作为模数，那么我们可以求得%mod等于x的最小需要的mod的倍数，这个可以用最短路求得，点数为4\*mod。

1006 Logical Chain
------------------

upsolved by ConnorZhong

------------------------------------------------------------------------

ConnorZhong's Solution：

bitset 压位 dfs，复杂度 $O(\frac{mn^2}{w})$。需要注意下写法，不优秀的
bitset 写法会导致巨大的常数差距...和标程一比 ConnorZhong 很轻易的 go die
了...

1007 Matching In Multiplication
-------------------------------

solved by cabinfever

------------------------------------------------------------------------

Cabinfever's Solution：

题目条件比较强，由于肯定存在完美匹配，那么$1 \leq p_{v_i}$，因为度为1的点的匹配是确定的，所以先把这些点拓扑排序处理了，并计算对答案的贡献。然后对剩下的点&p\_i
= 2&，所以每个联通块其实只有两种完美匹配，dfs计算一下答案就好。

1008 Phone Call
---------------

upsolved by ConnorZhong,Cabinfever

------------------------------------------------------------------------

ConnorZhong's Solution：

本质上就是求一个最小生成树，使得包含节点 $1$ 的连通树权最小。例如 $a,b$
路径，直接从 $a,b$ 往 lca 跳，合并路径上的点。再把两个路径的 LCA
合并，做 Krusical
就可以了。细节上用一个并查集维护点的连通性，一个并查集维护点合并，方便找上跳的父亲，注意的是
LCA 合并的时候，只需要合并连通性的块，而不要直接将两个 LCA 并在一起。

1010 Security Check
-------------------

upsolved by ConnorZhong

------------------------------------------------------------------------

ConnorZhong's solution：

很容易想到 $n^2$ 的 dp，类似于最长公共子序列的 dp
转移，注意到应该尽可能两个人同时检查，所以有

-   $f(i,j) = f(i-1,j-1) + 1, |a_i-b_j|\leq k$\
-   $f(i,j) = \min(f(i-1,j),f(i,j-1))+1, |a_i-b_j|>k$

注意到 $n,k$ 很小，我们可以把所有的 $|a_i-b_j| \leq k$ 的点对 $(i,j)$
抠出来，一共 $O(nk)$ 个，这部分暴力转移。

其他 $i,j$ 可以规约到 $f(i-t,j-t) + t$ 其中 $(i-t,j-t)$
是上面抠出来的点。

复杂度 $O(nk \log n)$

1011 Time To Get Up
-------------------

solved by cabinfever

------------------------------------------------------------------------

Cabinfever's Solution:

枚举判断1\~9的数字形状

1012 Wavel Sequence
-------------------

upsolved by ConnorZhong

------------------------------------------------------------------------

ConnorZhong's Solution：

求公共波浪子序列的个数。考虑 $dp(i,j,k)$ 为 $a$ 中子序列以 $i$ 结尾，$b$
中子序列以 $j$ 结尾，当前波浪形态上升或者下降用 $k$
表示。很显然可以发现一个 $n^2$ 转移，也就是一个 $n^4$
的复杂度。仔细观察可以发现这个转移是一个二维前缀和，考虑对转移过程
dp，设 $g(i,j,k)$ 为固定 $j$ 时这一行的前缀和。考虑 $h(i,j,k)$
为二维前缀和，其中 $h$ 可以通过 $g$ 中固定的 $j$ 用 $i$
来讨论当前波浪的形态来进行从 $g$ 到 $h$ 的转移。那么只有在 $a[i]=b[j]$
时 $dp(i,j,k)=h(i,j,k)+k$。 复杂度 $O(n^2)$

Summary
-------

### Replay

开场签到 09 11，zjc 发现 03 是个傻逼筛，和 hzh
讨论了细节直接就去上了，自带了一倍大小的大常数，hzh 帮忙很努力地抠了抠
wa 了，后来发现 zjc 可能还没有睡醒啊，改了个小地方也算过了。接着 hzh
上去上板刷的 04，搞了个分根号讨论怒 T，这个好像不太行啊？ zjc 去看了一下
1007 觉得是个傻逼题，和 jyb 一讲，就把锅甩给 jyb 自己去想 12 了，zjc
表示只会两个 log 的做法，这个时候 jyb wa了，zjc
仔细读题发现可能读了假题，就和 jyb 下机开始修修算法，换 hzh 上去爆搞
04，期间 zjc 和 jyb 发现之前的算法修修补补也能过，中间就交替上机 04 和
07，结果双双都过不了。zjc 找不到事干，顺带想想 05， 好像也不太会，最后
hzh xjb 随机把 04 搞了过去，回来一起帮 jyb 读 07
代码。发现一个十分隐晦的傻逼运算优先级错误。改了改也过了。
这个时候已经只剩下半小时，大家仔细一看 02 也能写啊？但是时间已经不够了。

讲题时发现 02、08 也可以做的啊。为什么 12
隔壁（好像有很多队都不是正解）用双 log 就冲过去了啊？

**zjc** 又熬夜了，起来后神智不清去写 03， 还自带大常数和bug，比后面 tls
先开始写，晚了半小时才通过。因为 jyb 和 hzh 讨论了
04，所以中间根本没有去想这个题，hzh 自己搞的时候也法帮忙，和 jyb 搞 1007
读题的时候好像也不太清醒，读 jyb
代码也没能帮忙查到错。有点梦游很不应该啊。
这场实际上有很多可以出的题，决策上来讲，1004
我们没有想到正解，花费了很多时间，或许可以先放一放想想别的题，所幸最后冲过去了，要不后果很严重。05
是个经典模型好像没人会做，很不应该啊，02
大家读到题的时候已经比较晚了，08 比赛快结束的时候才读，也没深入想，12
隔壁两个 log 竟然过了 zjc 最后半小时是不是可以上去冲一冲（不过 zjc
总是自带大常数估计也不太行）。anyway
这一场问题还是很明显，中期卡题易崩盘，不过也看到一些改善的地方。只是 jyb
和 zjc dirt 率真的好高啊？

**jyb**
上来A了11，然后就去想了想05，然后想了很久不会。。然后听着hzh说04分块很有道理啊，然后又去了看了13发现这是lxl毒瘤的不可做题，然后又去了看了看12，发现只会n\^3啊，然后去看了看07，和zjc交流了一哈，发现可做啊，然后敲了20分钟wa了，才发现$v_i$的度不一定是2啊。。然后我发现枚举一下度为1的就好了，但智障地并没有做拓扑。。虽然最后过了，但又想当然理解题意了啊。。卡了太久，也没去仔细想其他中档题，很惨。

**hzh**
上来看了1009，水题，秒之，然后发现1003好像过的人挺多，可做，于是和zjc讨论出了解法，为了让队伍能够不断层，于是让他去写，自己去想其他题，发现好像1004过的人也慢慢上来了啊，这个时限这个数据范围是不是可以乱搞过啊=
=，于是自己想了个乱搞的算法得了个绝望的TLE，没什么办法，后来想了一个不会TLE的做法，但是交了之后又发现不能保证正确性，最后绝望的加了个随机化，想着交了就不管了，结果居然AC了。。=
=我也不是很懂，只剩最后一个小时队友还在调1007，于是帮着队友调，发现了他们犯了很傻逼的错误，改之，遂过。时间所剩无几，也就放弃了。
