BUAA Summer Practice 2017 #4 简单动态规划 

--------------------------

## A. Tree Construction

在一个二维坐标系上，有$n$点且满足当$i < j$时,$x_i < x_j, y_i > y_j$。现用朝向x正半轴和y正半轴的线连成一颗树，问最小边权和

考虑一个区间dp:

​	 $$dp_{i,j} = \begin{cases} 0 & \mbox{ i = j} \\min_{k=i}^{j-1}dp_{i,k} + dp_{k+1,j} + cost(i,k,k+1,j) &\mbox{i < j}\end{cases}$$

由条件推出 $cost(i,k,k+1,j) = x_{k+1} - x_i + y_j - y_k$ 

容易发现cost满足四边形不等式，则利用四边形不等式优化到$O(n^2)​$

## B. Mice and Holes

在一条坐标轴上，有n只老鼠想要逃到m个洞里，已知每只老鼠的位置和洞的位置及容量，求所有老鼠逃进洞的最小距离和

很容易想到先对老鼠和洞以位置为关键字排序，$dp_{i,j}$表示前$i$个洞进了$j$个老鼠的最小距离和：

​		$$dp_{i,j} =  min(dp_{i-1,k} + cost(i,k+1,j))$$

这个$cost$，我们利用前缀和$sum_{i,j}$(表示第$i$个洞进前$j$个老鼠的距离和)也可以$O(1)$求出，这样得到一个$O(n^3)$的做法。

观察转移方程:

​		$dp_{i,j} = min(dp_{i-1,k} + sum_{i,j} - sum_{i,k})$

$sum_{i,j}$是一个定值，然后我们可以维护一个$dp_{i-1,k} - sum_{i,k}$的单调队列即可在$O(n^2)$时间复杂度内解决。

## C. Andryusha and Nervous Barriers

现有一个宽$w$，高$h$的垂直空间，空间中有$n$个屏障,现在可以从$h+1$的高度垂直扔小球下去，如果小球遇到屏障且高度差不超过一个界限，小球就会分裂成两个继续下落，否则小球会穿过屏障。现在从每个单位宽度扔一个小球，求最终落到屏障上有多少小球。

容易想到一个$dp_{i,j}​$表示从$(i,j)​$扔球得到的答案。考虑到$n​$只有$10^5​$，中间有大量空间是没有屏障的，我们重新考虑一个从下往上的$dp​$。我们从一个点$(x,y)​$扔球，其实我们只关心$y​$之下，$x​$最高的且不会被穿过的屏障是哪个。并且从每个屏障出发的答案是确定的，用$dp_i​$表示屏障$i​$的答案，$dp_i​$ = $dp_j + dp_k​$,$j,k​$为$l_i-1,r_i+1​$下去的屏障。那么我们开一个$1 - w​$的线段树，维护每个坐标有用的屏障信息。从下到上地，在$h_i​$加入屏障$i​$，在$h_i + s_i​$删除屏障$i​$，这里可以方便地在线段树上使用set来维护。由此，我们得到一个$O((n+w)log^2w)​$的做法。

我们可以把从同一个位置扔出的小球看作一个集合，那么一个屏障最多会产生两个集合，且会至少减少一个集合，那么最多会有$w+n$个集合。我们对每个列坐标维护一个顺序栈，记录该列还存在的集合。从上往下的依次处理屏障，对于每个屏障，我们需要知道哪些集合会落在屏障上。我们建立一个线段树来维护区间中最低的集合，判断会落在屏障上后，将球的个数记录并退栈，否则该屏障处理结束。最后的答案就是栈中所有球的个数和。这样，我们得到了$O((n+w)logw)$的做法。

## D. Snakes and Ladders 

有一个10\*10的格子图，每个格子编号1~100。玩家从1开始跳，每次扔骰子，设点数为$d_i$，然后玩家就可以跳$d_i$个格子（即随机走1~6格）。格子上有一些传送点，可能向前传送也可能向后传送。现在问跳到100的期望扔骰子次数。注意如果超出100，就会重新扔骰子。

期望dp。
用$dp_i$表示从第$i$个格子到$100$的期望步数
假设没有传送点,且考虑不能超过100，我们可以得到dp方程：

​			$$dp_i =\begin{cases}\frac{\sum_{j=i+1}^{i+6}dp_{j}}{6}+1 & \mbox{$1 \leq i \leq 94$} \\ \frac{\sum_{j=i+1}^{100}dp_j + \sum_{j = 101}^{j+6}dp_i}{6} + 1 & \mbox{$95 \leq i \leq 99$}\end{cases}$$ 

归纳可得

​			$dp_i = \frac{\sum_{j = i+1}^{min(100,i+6)}dp_j + 6}{min(100,i+6) - i}$

这个很显然可以递推求出，但是因为到传送可以向前向后，会出现“环”，所以我们必须建立方程组，使用高斯消元求出。

对于高斯消元矩阵的建立,设$k = min(100,i+6)​$,    $to_i​$表示第$i​$个格子的传送位置，我们将表达式移项

+ $(k - i) \times dp_i - \sum_{j=i}^{k}dp_j = 6$
+ $dp_i - dp_{to_i} = 0$

解出$dp_1$即为所求答案

## E. Ciel and Gondolas 

状态和转移十分显然：

$f(i,k)$ 表示前 $i$ 个人分成 $k$ 段的最小值，$w(i,j)$ 表示从 $i$ 到 $j$ 这一段的开销。

$f(i,k) = \min_{j<i} f(j,k-1)+w(j+1,i).$

暴力转移复杂度 $O(kn^2)$。

可以注意到 $w(i,j)$ 满足四边形不等式。 同时可以证明 $f(j,k-1)+w(j+1,i)$ 也是满足四边形不等式的。因此也满足完全单调性。于是我们就可以掏出板子抄一抄...

满足完全单调性的矩阵，我们可以用分治，在 $O(n\log n)$ 的复杂度求出每一列中的最小值。于是总体复杂度 $O(kn\log n)$。

这个题需要读入优化。

## F. 吉哥系列故事——恨7不成妻 

简单数位 dp。这道题求得是每个满足答案的数字的平方和。

考虑乘法分配律。每次 dp 到第 $i$ 位，该位所代表的值是 $x$，而该位之前的值是 $y$ ，$(x+y)^2 = x^2+y^2+2xy$，于是我们只需要在 dp 的时候维护三个值：

1. 当前状态的数字的和；
2. 当前状态的数字的个数；
3. 当前状态的数字的平方和。

## G. Singer House 

状态不那么自然的 dp。

$f(k,i)$ 表示 $k$ 阶图下能够在图中找到 $i$  条互不相交的简单路径的方案数。所以答案就是 $f(n,1)$。 

考虑每次从两个 $k$ 阶图转变成 $k+1$ 阶图时的转移。枚举两个子树 $f(k,L)$，$f(k,R)$。

- 考虑不选根节点。$f(k+1,R+L) $ 增加的贡献为  $f(k,L)f(k,R)$
- 考虑选取根节点成为单独一个点的新路径。$f(k+1,R+L+1)$ 增加的贡献为 $f(k,L)f(k,R)$
- 考虑选取根节点连在左子树或者连在右子树的某一条路径上，可以选择路径头和尾。$f(k+1,R+L)$ 增加的贡献为 $(2L+2R)f(k,L)f(k,R)$
- 考虑选取根节点可以合并子树中的某两条路径，则对于 $f(k+1,R+L-1)$ 的贡献有 $(L+R)(L+R-1)f(k,L)f(k,R)$

注意到第 2 维 $i$ 可能达到 $2^k$ 级别。而我们其实只需要求 $f(n,1)$。观察第 4 条转移发现每一层转移只有 $f(k,i)$ 的值最多只能影响到 $f(k+1,i-1)$。因此想要获得准确的 $f(n,1)$ 我们第二维也只需要前 $n$ 项准确值而已。

总体复杂度 $O(n^3)$

## H. Karen and Supermarket 

$f(i,j)$ 表示可以使用优惠券，考虑子树 $i$  中购买 $j$ 个商品的最小花费。

$g(i,j)$ 表示不可以使用优惠券，考虑子树 $i$  中购买 $j$ 个商品的最小花费。

转移很自然，对于每一颗子树 $i$ 他的父亲是 $fa$。 

这个 dp 暴力转移就可以。看上去是 $O(n^3)$ 的。实际上的复杂度是 $O(n^2)$。

给一个简易的证明。

考虑每一次把一棵子树 $i$ 和他的根节点$fa$进行合并。每次合并的复杂度都是 $sz(fa)sz(i)$。 其中 $sz(i)$ 表示当前子树的节点数目，$sz(fa)$ 是已经合并到根节点的节点数目。这样我们可以认为每次转移都是枚举了点对 $(u,v),u \in V(fa),v\in V(u)$. 这样每一个根 $fa$ 的合并的总复杂度，实际上就等于以 $fa$ 为 LCA 的点对 $(u,v)$ 的数目。这样的点对总共有 $\frac{n(n-1)}{2}$ 个。因此复杂度是 $O(n^2)$ 级别的。

类似题目：多校 2017 #5 1007. Rikka with Match

## I. Bear and Company 

给定一个长度为$n（n < 76）$的字符串，要求通过相邻字符之间的两两交换，使得交换之后的字符串内不会出现$“VK”$的片段，问最少交换的次数是多少。

这个串其实只有$3$种字符，$V$，$K$和其他字符（我们称为$X$）
预处理出一种字符前面的其他字符的个数
我们用$dp[i][j][k][l]$表示$i$个$‘V’，j$个$'K'$，$k$个$‘X’$组成新字符串的前$i+j+k$个字符，且当前的最后一个字符是$l(V/K/X)$最少需要多少次交换。
转移就直接枚举当前的最后一位，这一位放到当前位置所需要的交换次数就是$max(0，它前面的某字符的个数-当前这个字符的个数)$

## J. Send the Fool Further! (medium) 

给定一棵树，每条边上有一个宝物价值为$w$，每个节点最多访问$k$次，求能得到的最大价值
$dp[x][1]$表示访问完以$x$为根的子树并且返回到$x$的父节点能够得到的最大价值
$dp[x][0]$表示访问完以$u$为根的子树并且停在这棵子树内部所得到的最大价值
对于每个节点，将其子节点访问后用$vector$存储并排序，再作处理。

## K. Bash Plays with Functions 

令$g(n)$表示$n$的质因子个数，可以发现$f_0(n) = 2^{g(n)}$，这是一个积性函数。

而$f_r(n)=f_{r-1}\times1(n)$，因此也是积性函数。我们只需要对每个质因子单独考虑。 
发现答案跟质因子到底是什么没有关系，只跟它的次数有关。因此我们可以$dp$，用$dp[i][j]$表示$f_i(p^j)$，那么 
$dp[i][j]=\displaystyle \sum_{k = 0}^{j}(dp[i-1][k])$ 
预处理并用前缀和优化
时间复杂度$O((q+r)logn)$。

## L. GT and strings 

题意：给$n$字符串和$q$个询问，询问会给出两个数字$x$，$y$，问：1.x串是否是y串的子序列，2.x串是否是y串的子串。对于每个询问，输出两个字符，第一个为‘1’代表第一个询问正确，为‘0’代表第一个询问错误，第二个字符同理。

Q1：先预处理，$dp[i][j]$代表字符串中第i个字符的后面字符中'a'j这个字符的位置，处理每个询问，用x字符串来走y字符串的$dp$数组，走完后的最后位置还在y里面的话就是‘1’，反之就是‘0’,这样或许会TLE,但是我们可以用map去重，强制使得它询问不同的串，并且当x的长度小于等于y时我们才这样做，然后我们需要证明这样做的时间复杂度不会太大,证明如下：

显然当所有串长都一样长时会导致最差的时间复杂度，我们设有K个串，那么每个串长为$(\frac{MAXL}{k})$,一共可以构造出$k^2$个询问，当$k^2 \leq MAXQ$,时间复杂度为$O(MAXL \cdot k)$，$k^2>MAXQ$时，时间复杂度为$O(MAXQ\cdot \frac{MAXL}{k})$,因此最大时间复杂度为$O(MAXN \cdot sqrt(MAXN))$

Q2：我们先将所有字符串插入AC自动机，然后对于所有的y，单独处理，先将$s[y]$在AC自动机上跑，那么对于一对询问(x,y)当且仅当x节点在fail树上对应的子树中有y对应的节点，这个我们可以用线段树维护dfs序，跑$s[y]$时每到一个新节点就在线段树上更新相应的节点，对于x就访问其子树对应的区间即可，时间复杂度$O(MAXL \cdot log MAXL)$
