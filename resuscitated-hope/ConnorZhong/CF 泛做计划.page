# Overview

泛做CF。

- 目前做了多少道了？ $45$

# Solution
- `CF 633G` 拿一个 $1000$ 的 bitset 来维护每个节点存在的点的值。加法就是循环左移，再做一个质数表的 mask。
- `CF 343D` 注水操作相当于区间覆盖 $1$，清空操作我们考虑将一个节点设为 $0$，考虑查询，可知如果查询的节点所包含的子树中存在一个节点为 $0$，则其为空，反之为满。但是由于每个被设置为 $0$ 的节点相当于整条到根的链斗隐含着被清空的含义，在做覆盖操作时可能会覆盖掉这个信息，因此在操作 $1$ 时额外判断当前根节点是否为空，如果是则手动将根节点的父亲节点染 $0$，以保证性质。
- `CF 258E` 考虑每个操作 $a,b$ 都将 $a,b$ 标记到 $a$ 和 $b$ 上，子树用 dfs 序维护，做一次 dfs，进入一个节点，拿一个线段树维护经过的节点的标记所覆盖的子树的区间，就变成了线段覆盖，线段撤离，线段求覆盖长度的问题。
- `CF 813E` 考虑查询 $l,r$，令 $f(i)$ 表示自己前面第 $k$ 个同名元素的位置，无则赋值为 $0$。等价查询  $i$ 位于 $l,r$ 之间且 $f(i) < l$ 的数目，于是树状数组或者线段树维护一下各个 $f(i)$ 的 $i$。当然也可以可持久化离线版本：离线按 $r$ 排序，维护 $1,r$ 的查询。 
- `CF 813D` 令 $f(i,j)$ 表示两个序列分别以第 $i,j$ 个数结尾时的最大长度和。转移 $f(i,j)=f(j,i) (i < j), f(i,i) = 0, f(i,j) = \max(f(k,j))+1(i>j)$，$k$ 为可转移的值。因此维护一个遇到过的 $a[k]$ 的最大值和模 $7$ 的最大值。  
- `CF 331B` 看错+写崩了啊...考虑每个断点，用树状数组加起来，每次交换操作只会影响 $x,y,x-1,y-1$，注意去重啊。
- `CF 526E` 考虑某一个 $b$ 值，考虑其中前后都无法再塞进新元素的分割块，可以保证所有解中必然有一个块是从这个块的某个元素开始的，尺取法可以预处理出所有这样的块和从每个点开始的的最远覆盖长度，因此找到最小的块,令其长度为 $T$ ，我们枚举这个块中每一个元素作为起点的情况，每次枚举可以做到 $O(n/T)$，因此是 $O(n)$ 的。
- `CF 593D` 考虑第一种操作，除了除数为$1$以外，每次做除法都会至少减半，因此最多会走 $\log y$ 条边。因此考虑类似于求 $LCA(u,v)$ 的思想暴力往上跳，将路径为 $1$ 的边用压缩路径 $dsu$ 粘在一起，于是第二种操作直接修改或者粘点就可以了。用 map 来强行草边权会被卡啊。
- `CF 384E` dfs序，维护一棵线段树，修改子树时按照当前节点奇偶性分开处理。修改时统一打标记，询问时按深度分别考虑。
- `CF 187C` 看上去很复杂，实际上优先队列处理下 bfs 的过程大概就可以了啊？
- `CF 529B` 暴力。题意很迷啊？样例枚举题意系列。
- `CF 670F` 分类讨论贪心xjb构造。首先很容易确定数字的长度，然后就开始往模式串两边讨论贪心加东西，坑极多，特别恶心，大概比赛中就会死于反复提交就是过不了卡几个小时然后就狗带了。
- `CF 371E` 易证答案必然是连续的一段。维护前缀和枚举区间就可以了。dirt..dirt..dirt..
- `CF 420C` 相当于在图上任取两点，与两点有关的边的数目大于$p$的点对对数。按度数排序，先二分计算不直接相连的合法点对数目，即两个点度数相加大于$p$，暴力去除直接相连的点对就可以了。然后再根据每条边单独考虑每条边直接相连的两个点是否产生贡献。zjc已经化身绝对的dirt选手了啊。
- `CF 66C` 题目逻辑并没有难度，小心坑点，读入恶心。zjc再次小小地写炸了？
- `CF 37C` 按长度排序，建字符集大小为 $2$ 的字典树，将每个叶子结点构造一个串。因为只需要$1000$个叶子，且深度最多为$1000$，直接dfs就可以，也可以手写带加法的 bitset。
- `CF 630Q` 这是什么鬼题啊，高中几何题啊？正四面体体积 $S_3 = \frac{\sqrt 2 }{12}l^3$，四边形底的金字塔 $S_4 = \frac{\sqrt 2}{12}l^3$，五边形底金字塔 $S_5 = \sqrt{1-(\frac{1}{2\sin(36^o)})}\frac{5l^3}{12\tan(36^o)}$.
- `CF 56E` 很套路的一个线段树上的DP啊，没什么好说的，差点zjc又写炸了啊，冷静了一下还是过了，很棒棒啊？
- `CF 553D` 可以想到一开始把所有可选点都选取，之后想要使答案更优，就一定会删除当前最差的点，所以一直调整下去就可以了，拿个优先队列搞一搞。想起了THUPC的D题。但又好像不是一个东西...
- `CF 160D` 无向带权图判断其每一条边“一定”，“可能” 或“不存在”于其每一个最小生成树中。考虑 kruskal 的过程，把所有边排序。易证其每一个最小生成树，只有可能是相同权值的边进行替换。因此用并查集维护联通块。枚举每一个等权值的边集，判断这个边集的每条边对于已包含的连通块而言是桥，还是自环，还是普通的边。即对应 `any` `none` `at least one`。 zjc日常写炸啊？zjc可能根本就不适合写代码啊？
- `CF 590D` 我们可以把前$K$个和后面的$N-K$个拆开成两部分分别求附带选取个数的01背包，因为分后选取数目必然减半。然后再枚举选取个数就可以了。复杂度$O((\frac{N}{2})^4)$ 附带一个不大的常数。zjc可能不太适合做代码手啊。这么个垃圾东西快要了命了啊？
- `CF 29D` 比较容易发现如果有解，那么顺序一定是走完一颗子树的所有叶子节点，再进入下一棵子树。大概是可以用dfs序搞的。不过对这个不太熟，所以就随便拿了个栈瞎比搞了搞反正也过了啊~踩坑：一个变量打错了。
- `CF 103C` 好像是一个，傻逼构造啊？样例超级良心啊。
- `CF 616E` 给两个数$n,m$, 求$n\mod 1 ... n\mod m$的和。将和式改写。$nm - \sum{\left\lfloor \frac{n}{i} \right\rfloor i}$，分别将$\left\lfloor \frac{n}{i} \right\rfloor$ 和 $i$ 枚举到$\sqrt n$ 大小就可以了，复杂度$O(\sqrt n)$。写的时候爆了一次 long long 没有发现。有一次 $m$ 比较小的情况没有考虑清楚。上题前还需要多准备一下，小心一点。
- `CF 794D` 构造。考虑两个点是否可以染色为同一个颜色，则需要这两个点，相邻的点完全一致（包括自己）。如果所有染色都是唯一的，即没有同色的情况，则原图必须是一条链。所以就按照能相同的点缩一下点，判断一下是否是一条链。缩点可以用 vector, sort, unique 来实现。
- `CF 786B` 比较有趣的一个套路？利用两棵对称的线段树来处理第二种操作和第三种操作，把所有线段树的节点都当做图中的节点一起跑Dijkstra。zjc怎么这么菜啊？这点代码量就差点hold不住了啊？ 
- `CF 5E` 很巧妙的一个题，考虑将原环进行平移操作，将最大的数放在第一位，这样就可以把环修改为线性来考虑。考虑答案贡献：数对中较小的值计算贡献，数对如果两者相同，位置靠前的计算贡献。计算左右距离自己最近的比自己大的数，可以通过单调栈$O(n)$求得，这样可以求得第一类贡献；在单调栈退栈过程中记录相同大小的值的数目，可以求得第二类贡献。
- `CF 41D` 按照模$k+1$的剩余系分割状态，从最下层往上DP就可以了。
- `CF 193B` 虽说是一个暴力出奇迹，卡了很久。需要有意识的注意常数技巧，同样的复杂度常数竟然差了近10倍直接TLE我也是很棒棒..？改了改后竟然还是差了5倍.. 
- `CF 164A` 上题之前应该多想想，这个题也是经典套路了，dfs直接做貌似很对实际上在图中存在SCC的时候会跪，正解应该是在反向图和正向图分别确定能到达的点。
- `CF 522C` 观察发现只有第一次$r_j = 1$ 的时候有影响，因此直接找出在$j$之后不在出现且能够满足的 $a_i$，剩下的直接判断可行性就可以了。
- `CF 630M` 喵喵喵？我可能拿了假的题单
- `CF 706E` 这个世界上竟然真的有十字链表？还以为那是活在数据结构教材上的传说。
- `CF 220C` 拿两个优先队列xjb维护一下就好了。代码准确度堪忧。
- `CF 105B` 暴力。码的时候多留心。
- `CF 128D` 这可能是一个水题啊？还是码的时候多想想细节。
- `CF 217B` 很有趣的题？反着考虑这个过程很类似辗转相除，所以枚举下 $1$ 到 $r-1$就可以了，得到 $O(rlogr)$ 的做法。实现过程中注意特判边界条件。
- `CF 524E` 把询问离线，线段树随便搞搞，类似扫描线，按$x,x_2$和$y,y_2$分别排序做一遍。以$x$排序为例 rook 表示在第 $y$ 位置单点修改为 $x$，询问表示修改所有小于 $x_2$ 的 rook 后 查询$y_1,y_2$ 之间最小值是否大于等于$x_1$。
- `CF 660D` 坐标点集算平行四边形。因为无共线，$n^2$ 枚举所有的线段，根据斜率和长度排序，随便搞搞。注意特判一下斜率不存在就可以了。
- `CF 611E` STL，分类讨论。熟悉了一下 $multiset$ 的使用。题目比较恶心，注意细节。
- `CF 425C` DP。可以注意到答案最多$300$，状态$DP(i,j)$，表示当前第$i$轮操作，第一个序列的第$j$个点在第二个序列中最小的匹配值，转移很自然。
- `CF 620D` 给两个序列，交换$0-2$个数，使和的差最小。对每个序列$n^2$分组，在另一组排序二分找最近的值来更新答案，**一定要注意数组大小是否开够**。
- `CF 490F` 树上链的最长上升子序列。给出一个 $O(N^2\log N)$ 的做法。枚举链的起点，用 $O(N\log N)$ 的方法做最长上升子序列，dfs整棵树，注意函数结束后的回滚状态。
- `CF 798D` 有趣的题，巧妙的构造。考虑选出来的数字之和必然大于剩下的数字之和；按 $a$ 降序如果是奇数，则选取第一个，如果是偶数，则选取前两个，接下来每两个为一组，选取 $b$ 值较大的一个。我们可以发现选取出来的序列很容易与未被选出的序列构成一一对应的大于关系。因此答案合法。
- `CF 772C` 给一个 $m$ 和 ban 序列，构造一个最长序列，使得模 $m$ 意义下其前缀乘积互不相同，且不出现 ban 序列中的值。容易证明存在 $x$ 使 $ix \equiv j\mod m$ 成立的充要条件是$gcd(i,m)|gcd(j,m)$，因此根据 $gcd(i,m)$ 对 $0 ～ m-1$ 分组，通过整除关系连边，得到DAG，求出DAG上最长边。需要注意的是求逆元的方法，和特判0.