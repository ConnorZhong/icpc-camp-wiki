---
title: Daily Training

...

# ???
- `POJ 1273` 最大流模版题。
- `HDU 5306` 吉老师线段树，很难很绝望啊。区间取 $\min$ 区间求和。维护线段树 $tag$ 的单调性，来尝试更新区间和，需要维护的有：子树中最大的 $tag$ ，子树中已经被 $tag$ 支配的叶子结点个数。

# Spring Daily Practice

## 2017-5-29 ~ 2017-6-30
- `POJ 3735` 首先根据操作做一个转移矩阵，快速幂就可以了。不过我为什么自带大常数啊？为什么我的矩阵快速幂会比别人慢了二十倍不止呢？
- `POJ 3171` 线段树dp，竟然写炸了...
- `POJ 3420` 实在羞愧于不会推公式，写了一层轮廓线 dp，求出了公式，题解公式只有 $5$ 项，我有 $2^4$ 项啊...复杂度就冲上去了，好在并没有什么关系。看别人题解后理性分析的话，可能可以注意到这样的事实：考虑第 $i$ 层，前 $i-1$ 层都已经被填满，那么我们此时第 $i$ 层可能的形态其实只有 $6$ 种形态。用 $1$ 表示已被填，用 $0$ 表示还没有被填，如下 $0 0 0 0,1100,0011,1001,0110,1111$ 各个形态当前的方案数用$f(i,0),f(i,1),f(i,2),f(i,3),f(i,4),f(i,5)$ 表示，可得 $f(i+1,0)=f(i,0)+f(i,1)+f(i,2)+f(i,3)+f(i,5)$，$f(i+1,1)=f(i,0)+f(i,2)$，$f(i+1,2)=f(i,0)+f(i,1)$，$f(i+1,3) = f(i,0)+f(i,4)$，$f(i+1,4) = f(i,3)$，$f(i+1,5)=f(i,0)$
- `CF 633G*` 拿一个 $1000$ 的 bitset 来维护每个节点存在的点的值。加法就是循环左移，再做一个质数表的 mask。
- `HDU 5293` 树dp，考虑每一条链都只在其lca处才取，$f(i)$ 表示第 $i$ 个节点和他的子树中所能选取的最大值。那么对于某一个节点而言，如果在该节点不选取新的链，就是由其所有儿子节点的 $f$ 和，如果选取新的链，就是这条链的所有点，减去它们本身的 $f$，加上所有儿子的 $f$，这可以从修改点查链转化为修改树查点，由一个树状数组来维护转移。
- `UESTC 574` 每次都操作都当作一个区间加，和为子树中每个节点额外加上它本身的深度值。每个节点维护子树中的深度之和，做一个双标记，加上的等差数列的个数和区间加的数值，就做完了。
- `HDU 5296` 给棵树，一个操作把点拿入集合 $S$，一个操作把点从集合 $S$ 中去除，求集合中的点的生成树的权。考虑一个结论，每次加入一个点，相当于改变了接入到由 $S$ 中 dfs 序恰巧比自己大的和比自己小的两个序号最接近的点构成的链上的距离，如果 $S$ 不存在序号小或序号大于这个点的结点，则直接取序号最小和最大的点。这个结论很容易证明它是对的，但是从正面推结论不是很容易，因此暂且记下这个例子。
- `HDU 5039` 给棵树，将边染黑或染白，求多少条路径经过奇数条黑边。考虑根节点都是白色的，所有与根节点之间存在偶数条边的点是白色，反之为黑色，修改边的颜色就是把该边所连接的深度较深的点为根的整棵子树颜色反转，于是用线段树维护一下节点颜色个数，查询就是两个颜色的点数相乘。
- `HDU 3887` 容易想到用线段树维护所有节点，用区间查儿子，这样是 $O(n\log^2n)$。考虑用 dfs 时对树状数组差分，可以做到$O(n\log n)$。
- `CF 343D*` 注水操作相当于区间覆盖 $1$，清空操作我们考虑将一个节点设为 $0$，考虑查询，可知如果查询的节点所包含的子树中存在一个节点为 $0$，则其为空，反之为满。但是由于每个被设置为 $0$ 的节点相当于整条到根的链斗隐含着被清空的含义，在做覆盖操作时可能会覆盖掉这个信息，因此在操作 $1$ 时额外判断当前根节点是否为空，如果是则手动将根节点的父亲节点染 $0$，以保证性质。
- `CF 258E*` 考虑每个操作 $a,b$ 都将 $a,b$ 标记到 $a$ 和 $b$ 上，子树用 dfs 序维护，做一次 dfs，进入一个节点，拿一个线段树维护经过的节点的标记所覆盖的子树的区间，就变成了线段覆盖，线段撤离，线段求覆盖长度的问题。
- `CF 813E*` 考虑查询 $l,r$，令 $f(i)$ 表示自己前面第 $k$ 个同名元素的位置，无则赋值为 $0$。等价查询  $i$ 位于 $l,r$ 之间且 $f(i) < l$ 的数目，于是树状数组或者线段树维护一下各个 $f(i)$ 的 $i$。当然也可以可持久化离线版本：离线按 $r$ 排序，维护 $1,r$ 的查询。 
- `CF 813D*` 令 $f(i,j)$ 表示两个序列分别以第 $i,j$ 个数结尾时的最大长度和。转移 $f(i,j)=f(j,i) (i < j), f(i,i) = 0, f(i,j) = \max(f(k,j))+1(i>j)$，$k$ 为可转移的值。因此维护一个遇到过的 $a[k]$ 的最大值和模 $7$ 的最大值。  
- `CF 331B*` 看错+写崩了啊...考虑每个断点，用树状数组加起来，每次交换操作只会影响 $x,y,x-1,y-1$，注意去重啊。
- `CF 526E*` 考虑某一个 $b$ 值，考虑其中前后都无法再塞进新元素的分割块，可以保证所有解中必然有一个块是从这个块的某个元素开始的，尺取法可以预处理出所有这样的块和从每个点开始的的最远覆盖长度，因此找到最小的块,令其长度为 $T$ ，我们枚举这个块中每一个元素作为起点的情况，每次枚举可以做到 $O(n/T)$，因此是 $O(n)$ 的。
- `CF 620E` 拿Bitset来维护一下节点的颜色数，这个题就做完啦。
- `HDU 5468` 2015 Shanghai Online. 枚举一下质因数，蜜汁树上的容斥大力艹啊，$1$ 与其本身互质这个细节很爆炸。写一半发现自己记录结果的方式有点问题，跑去翻了翻题解，竟然可以dfs 进点时算一次，出点时算一次来做差，类似前缀和来巧妙解决（还有这种操作.jpg），还需要努力啊。这个题还可以 dfs 序 + 莫比乌斯反演。
- `HDU 5692` 仔细思考的话会发现每组询问等价于在 $x$ 的子树中寻找一个节点距离根的权最大，修改就是将所有子树同时增减一个值，因此预处理出根到所有节点的路径的权建线段树，这样题目就相当于区间修改，区间RMQ。去年百度之星的题，当时怎么这么菜啊？
- `POJ 3321` 很裸的dfs序套线段树。惨遭卡常，真是惨啊。
- `CF 593D*` 考虑第一种操作，除了除数为$1$以外，每次做除法都会至少减半，因此最多会走 $\log y$ 条边。因此考虑类似于求 $LCA(u,v)$ 的思想暴力往上跳，将路径为 $1$ 的边用压缩路径 $dsu$ 粘在一起，于是第二种操作直接修改或者粘点就可以了。用 map 来强行草边权会被卡啊。
- `CF 384E*` dfs序，维护一棵线段树，修改子树时按照当前节点奇偶性分开处理。修改时统一打标记，询问时按深度分别考虑。
- `CF 187C*` 看上去很复杂，实际上优先队列处理下 bfs 的过程大概就可以了啊？

## 2017-5-22 ~ 2017-5-28
- `CF 529B*` 暴力。题意很迷啊？样例枚举题意系列。
- `CF 670F*` 分类讨论贪心xjb构造。首先很容易确定数字的长度，然后就开始往模式串两边讨论贪心加东西，坑极多，特别恶心，大概比赛中就会死于反复提交就是过不了卡几个小时然后就狗带了。
- `CF 371E*` 易证答案必然是连续的一段。维护前缀和枚举区间就可以了。dirt..dirt..dirt..
- `CF 420C*` 相当于在图上任取两点，与两点有关的边的数目大于$p$的点对对数。按度数排序，先二分计算不直接相连的合法点对数目，即两个点度数相加大于$p$，暴力去除直接相连的点对就可以了。然后再根据每条边单独考虑每条边直接相连的两个点是否产生贡献。zjc已经化身绝对的dirt选手了啊。
- `CF 66C*` 题目逻辑并没有难度，小心坑点，读入恶心。zjc再次小小地写炸了？
- `CF 37C*` 按长度排序，建字符集大小为 $2$ 的字典树，将每个叶子结点构造一个串。因为只需要$1000$个叶子，且深度最多为$1000$，直接dfs就可以，也可以手写带加法的 bitset。
- `CF 630Q*` 这是什么鬼题啊，高中几何题啊？正四面体体积 $S_3 = \frac{\sqrt 2 }{12}l^3$，四边形底的金字塔 $S_4 = \frac{\sqrt 2}{12}l^3$，五边形底金字塔 $S_5 = \sqrt{1-(\frac{1}{2\sin(36^o)})}\frac{5l^3}{12\tan(36^o)}$.

## 2017-5-15 ~ 2017-5-21
- `POJ 3411` 挑战上的状压习题。Dijkstra维护转移过程，题目中有重边wa了一发。状压部分告一段落。zjc没写炸就感觉不太习惯。
- `POJ 1795` 挑战上的状压习题，本质上是一个旅行商问题的字符串版本，有一些细节，注意一下字典序的问题。zjc日常写炸。
- `POJ 2836` 挑战上的状压习题，尼玛(｡･∀･)ﾉﾞ嗨呀，又踩坑写炸了啊....
- `CF 56E*` 很套路的一个线段树上的DP啊，没什么好说的，差点zjc又写炸了啊，冷静了一下还是过了，很棒棒啊？
- `CF 553D*` 可以想到一开始把所有可选点都选取，之后想要使答案更优，就一定会删除当前最差的点，所以一直调整下去就可以了，拿个优先队列搞一搞。想起了THUPC的D题。但又好像不是一个东西...
- `CF 160D*` 无向带权图判断其每一条边“一定”，“可能” 或“不存在”于其每一个最小生成树中。考虑 kruskal 的过程，把所有边排序。易证其每一个最小生成树，只有可能是相同权值的边进行替换。因此用并查集维护联通块。枚举每一个等权值的边集，判断这个边集的每条边对于已包含的连通块而言是桥，还是自环，还是普通的边。即对应 `any` `none` `at least one`。 zjc日常写炸啊？zjc可能根本就不适合写代码啊？
- `CF 590D*` 我们可以把前$K$个和后面的$N-K$个拆开成两部分分别求附带选取个数的01背包，因为分后选取数目必然减半。然后再枚举选取个数就可以了。复杂度$O((\frac{N}{2})^4)$ 附带一个不大的常数。zjc可能不太适合做代码手啊。这么个垃圾东西快要了命了啊？
- `CF 29D*` 比较容易发现如果有解，那么顺序一定是走完一颗子树的所有叶子节点，再进入下一棵子树。大概是可以用dfs序搞的。不过对这个不太熟，所以就随便拿了个栈瞎比搞了搞反正也过了啊~踩坑：一个变量打错了。
- `POJ 3254` 挑战上的状压习题。zjc的dp技能点太少了啊。mask表示最近处理的一排的状态，分别枚举放不放来转移。
- `CF 103C*` 好像是一个，傻逼构造啊？样例超级良心啊。
- `CF 616E*` 给两个数$n,m$, 求$n\mod 1 ... n\mod m$的和。将和式改写。$nm - \sum{\left\lfloor \frac{n}{i} \right\rfloor i}$，分别将$\left\lfloor \frac{n}{i} \right\rfloor$ 和 $i$ 枚举到$\sqrt n$ 大小就可以了，复杂度$O(\sqrt n)$。写的时候爆了一次 long long 没有发现。有一次 $m$ 比较小的情况没有考虑清楚。上题前还需要多准备一下，小心一点。


## 2017-5-1 ~ 2017-5-14
- `CF 794D*` 构造。考虑两个点是否可以染色为同一个颜色，则需要这两个点，相邻的点完全一致（包括自己）。如果所有染色都是唯一的，即没有同色的情况，则原图必须是一条链。所以就按照能相同的点缩一下点，判断一下是否是一条链。缩点可以用 vector, sort, unique 来实现。
- `CF 794C` 贪心构造，很容易证明每一步的最优解。
- `CF 794B` 不表
- `CF 794A` 水。
- `CF 804C` 由于每个冰淇淋所在的点构成连通的子图，同时由于$T$是一棵树，不存在环，因此如果做dfs，后扫描的点如何染色将不会对已经染色部分造成影响，因此随意dfs扫描暴力染色是正确的，复杂度$O(n+m)$。注意对没出现的冰淇淋进行染色。
- `CF 804B` 后面往前走，乘2或加1。
- `CF 804A` (n+1)/2-1 
- `CF 805B` aabbaa..
- `CF 805A` 机灵题专场..l和2的故事。
- `CF 786B*` 比较有趣的一个套路？利用两棵对称的线段树来处理第二种操作和第三种操作，把所有线段树的节点都当做图中的节点一起跑Dijkstra。zjc怎么这么菜啊？这点代码量就差点hold不住了啊？ 
- `CF 5E*` 很巧妙的一个题，考虑将原环进行平移操作，将最大的数放在第一位，这样就可以把环修改为线性来考虑。考虑答案贡献：数对中较小的值计算贡献，数对如果两者相同，位置靠前的计算贡献。计算左右距离自己最近的比自己大的数，可以通过单调栈$O(n)$求得，这样可以求得第一类贡献；在单调栈退栈过程中记录相同大小的值的数目，可以求得第二类贡献。

## 2017-4-24 ~ 2017-4-30
- `CF 41D*` 按照模$k+1$的剩余系分割状态，从最下层往上DP就可以了。
- `POJ 2441` 状压DP。第$i$个牛是一维，已填状态是第二维。
- `CF 193B*` 虽说是一个暴力出奇迹，卡了很久。需要有意识的注意常数技巧，同样的复杂度常数竟然差了近10倍直接TLE我也是很棒棒..？改了改后竟然还是差了5倍.. 
- `CF 803D` 二分。
- `CF 803C` 枚举一下GCD，构造个自然数列乘一下。
- `CF 803B` -- 
- `CF 803A` --
- `POJ 1769` 线段树上的dp。
- `CF 164A*` 上题之前应该多想想，这个题也是经典套路了，dfs直接做貌似很对实际上在图中存在SCC的时候会跪，正解应该是在反向图和正向图分别确定能到达的点。
- `CF 522C*` 观察发现只有第一次$r_j = 1$ 的时候有影响，因此直接找出在$j$之后不在出现且能够满足的 $a_i$，剩下的直接判断可行性就可以了。
- `CF 797C` 一路往前贪，尽可能找最小的，剩下的都入栈，比较栈顶和后面最小值的大小Gao一下。
- `CF 797B` 随便搞搞？
- `CF 797A` 因式分解。
- `POJ 3233` 矩阵等比数列求和，分治做，矩阵快速幂做都可以。分治的常数是快速幂的两倍多。
- `CF 630M*` 喵喵喵？我可能拿了假的题单
- `CF 706E*` 这个世界上竟然真的有十字链表？还以为那是活在数据结构教材上的传说。
- `CF 220C*` 拿两个优先队列xjb维护一下就好了。代码准确度堪忧。
- `CF 105B*` 暴力。码的时候多留心。
- `CF 128D*` 这可能是一个水题啊？还是码的时候多想想细节。
- `CF 217B*` 很有趣的题？反着考虑这个过程很类似辗转相除，所以枚举下 $1$ 到 $r-1$就可以了，得到 $O(rlogr)$ 的做法。实现过程中注意特判边界条件。
- `CF 524E*` 把询问离线，线段树随便搞搞，类似扫描线，按$x,x_2$和$y,y_2$分别排序做一遍。以$x$排序为例 rook 表示在第 $y$ 位置单点修改为 $x$，询问表示修改所有小于 $x_2$ 的 rook 后 查询$y_1,y_2$ 之间最小值是否大于等于$x_1$。

## 2017-3-13 ~ 2017-4-23
- `CF 798C` 除了 $gcd$ 不是$1$的情况，其他时候都应该把 $gcd$ 做成2，可以发现最多$2$次操作就能使相邻两个数都生成$2$的公因子，而无论怎么操作，都无法生成其他新的公因子。所以一路做过去就好了。
- `CF 798B` BF算法。
- `CF 798A` 注意读题，签到的时候手不能抖。
- ~~`CF 530A` 我也想知道为什么这种题过的这么少啊，直到我提交的时候发现语言中没有 C++。~~
- `CF 660D*` 坐标点集算平行四边形。因为无共线，$n^2$ 枚举所有的线段，根据斜率和长度排序，随便搞搞。注意特判一下斜率不存在就可以了。
- `CF 611E*` STL，分类讨论。熟悉了一下 $multiset$ 的使用。题目比较恶心，注意细节。
- `CF 425C*` DP。可以注意到答案最多$300$，状态$DP(i,j)$，表示当前第$i$轮操作，第一个序列的第$j$个点在第二个序列中最小的匹配值，转移很自然。
- `CF 620D*` 给两个序列，交换$0-2$个数，使和的差最小。对每个序列$n^2$分组，在另一组排序二分找最近的值来更新答案，**一定要注意数组大小是否开够**。
- `CF 490F*` 树上链的最长上升子序列。给出一个 $O(N^2\log N)$ 的做法。枚举链的起点，用 $O(N\log N)$ 的方法做最长上升子序列，dfs整棵树，注意函数结束后的回滚状态。
- `CF 798D*` 有趣的题，巧妙的构造。考虑选出来的数字之和必然大于剩下的数字之和；按 $a$ 降序如果是奇数，则选取第一个，如果是偶数，则选取前两个，接下来每两个为一组，选取 $b$ 值较大的一个。我们可以发现选取出来的序列很容易与未被选出的序列构成一一对应的大于关系。因此答案合法。
- `CF 772C*` 给一个 $m$ 和 ban 序列，构造一个最长序列，使得模 $m$ 意义下其前缀乘积互不相同，且不出现 ban 序列中的值。容易证明存在 $x$ 使 $ix \equiv j\mod m$ 成立的充要条件是$gcd(i,m)|gcd(j,m)$，因此根据 $gcd(i,m)$ 对 $0 ～ m-1$ 分组，通过整除关系连边，得到DAG，求出DAG上最长边。需要注意的是求逆元的方法，和特判0.
- `FZU 2129` 给一个序列，求不同的子序列的个数。状态定义为 $f(i)$ 表示前 $i$ 个数的子序列个数目，$last(x)$ 表示值为$x$的元素上一次出现的位置。转移方程 $f(i)=f(i-1)+f(i-1)-f(last(x)-1)$ ;如果 $last(x)$ 为空时 $f(i)=f(i-1)+f(i-1)+1$。
- `CF 764D` 图&STL。注意到整个图与一棵有根树十分相近，因此我们维护每一个节点的时候将儿子们的流量和父亲来的流量分开维护。考虑将$x\rightarrow f(x)$修改为$x \rightarrow y$，这样维护时需要修改的点有$x,y,f(x),f(y),f(f(x))$，这样我们就可以完成前二种操作。现在处理第三种操作全局最值，考虑每次修改过的点中的最大值和最小值，我们考虑在父亲节点做一个保存其儿子节点流量值的`multiset`，这样我们只需要对$x,y,f(x),f(y),f(f(x)),f(f(f(x))),f(f(y))$的儿子们中维护一下最值，扔到全局中修改就可以了。需要注意的是，维护时还需要去除上述点中的重复点。（`multiset`真是好用）。

## 2017-2-27 ~ 2017-3-12
- `CF 763C` 数论。官方题解太神啦！一种更普遍的做法1和官方题解2。1.用模$m$意义下的所有数的和以及平方和方程，可以唯一确定两组$(x,d)$解，暴力check一下就可以了；2.对于$2n<m$我们随意选取两个值做差，check一下这个差在原数组中出现的次数。这个次数就是$n-k$，于是解出了$d$，check一下；对于$2n>m$，我们注意到$m$是质数，即与$d$互质，假设原数组是等差数列，则其对于$Z_m$的补集也是公差相等的等差数列，在这个补集上重复$2n<m$的做法，解出$d$，暴力check原数组。
- `CF 782E` 题意鬼畜。直接dfs。
- `CF 782D` 题意鬼畜。注意如果有人第一个名字同名，则他们必须全部选择第二个名字。除此之外每次都暴力选取只有唯一命名选择的人更新$O(n^2)$，再将没命名的人扫一遍，随便搞搞。
- `CF 782C` 随便dfs染染，颜色数是$max{du[i]+1}$。
- `CF 782B` 二分时间。用区间检验。
- `CF 782A` 蛤蛤蛤。
- `ifrog 1096` 喵喵喵？下次可别做一半跑路了啊...
- `ifrog 1099` 喵。

# Winter Daily Training 2017
## 2017-2-19 ~ 2017-2-26
- `CF 779E` 注意到每一位独立对答案贡献，因此枚举每一位选0或者选1.
- `CF 779D` 水二分。
- `CF 779C` 汪汪汪？
- `CF 779B` 汪汪？
- `CF 779A` 汪？
- `CF 777E` 贪心&栈|dp。按照外径从小到大贪心放置，发现如果某一个较大的盘如果不能放置，则上面的盘也无法放置。因此用一个栈维护一下状态随便搞一搞，可以得到$O(n)$的做法。当然也可以dp，$dp_i$表示只选取比$i$小的盘盒第$i$个盘的最大高度。数据结构维护下转移。$O(nlogn)$。
- `CF 777D` 最优解显然是从后往前找，能不删则不删。
- `CF 777C` 预处理出每个位置最远可以延伸到的地方。
- `CF 777B` 暴力贪？
- `CF 777A` 循环节是$6$。
- `CF 776E` 欧拉函数。仔细验证一下可以发现$f(n)$其实是欧拉函数，因此$g(n)=n$，所以这个题就是水题了，到$1$时停止。可能需要注意一下模$1e9+7$的位置？
- `CF 776D` dsu|dfs。把每个门看作边，控制同一个门的两个开关的按下与否状态应当与每个门的的状态有关，dsu搞搞，判断一下是否存在矛盾即可；考虑每个门都仅被两个快关控制，确定其一后其他的也被确定。因此只需要找没有确定的开关枚举一下状态就可以推下去了。
- `CF 776C` 搞个map来记一下前缀和，然后处理前缀和的时候每次都查一下。
- `CF 776B` 质数染1，其他染2。
- `CF 776A` 喵喵喵？
- `CF 768F` 计数。分别统计合法和全部的情况，使用隔板法分别求解就可以了。
- `CF 768E` SG。可以暴力算SG，复杂度证明相当于求$60$的不同数的划分，dp算算大概8e6左右？(谢谢qls)；注意某一堆石子数字介于$\sum_{i=1}^{p}i$与$\sum_{i=1}^{p+1}i$之间的数最多能取$p$次，而每次选取都可以使得该堆石子能继续被选取的次数为$1,2,\cdots,p-1$之间的任何一个数，这与SG函数的定义相符，于是这个石子数的SG值即为$p$，可以$O(n)$计算。
- `CF 768D` dp。$dp(i,j)$表示第$i$天凑齐了$j$种球的概率。转移很自然。
- `CF 768C` 暴力。注意到$a$和$x$很小，异或操作的所有值都在$2^{10}$内，一个$O(2^{10}k)$的大暴力。
- `CF 768B` 分治|树的性质。注意到$n$是由两侧的$\left\lfloor n/2 \right\rfloor$和$n%2$组成，所以可以分治。注意到其实整个过程构成了一棵完全二叉树，按照中序遍历的顺序标号，深度为$i$的节点的值为$(n>>j)\&1$，类似树状数组的编号性质，某节点所位于的层级可以通过编号的$lowbit$快速得到。因此可以暴力枚举每一位的值。
- `CF 768A` 喵喵喵？
- `CF 767E` 贪心。我也不知道为什么这套CF都是贪心？注意到本质只有支付$100$或用零钱补足两种决策，且决策之间的差别是$100$零钱。因此假定全部用零钱，零钱不够的时候从前面找代价最小的来$+1$s。
- `CF 767D` 贪心。所有牛奶尽可能靠后喝，随便搞搞？
- `CF 767C` 水。大概随便搜搜？
- `CF 767B` 贪心&细节。考虑$0$必然是可行解，等待时间为$t_s$，我们只要计算出每个人的等待时间，在等待时间最短的人到达的前$1$s的位置插队就可以了。
- `CF 767A` 水。

## 2017-2-6 ~ 2017-2-11
- `CF 766A` 相同则$-1$，否则较长串长度。
- `CF 766B` 排个序判断相邻3个数。
- `CF 766C` dp&前缀和。利用前缀和可以在$O(\Sigma)$快速计算某一段子串是否合法。很容易得到$O(\Sigma n^2)$的dp。计算最长子串同样可以在$O(\Sigma n^2)$下得到，当然也可以直接并入前面的dp中，最少切分可以通过$O(\Sigma n)$ 贪心得到。
- `CF 766D` 并查集。每个字符建立两个节点：分别表示该字符的正和反。如果两个词是相同的则将两个词的正和反分别合并，反之将其交叉合并。正反同时在同一个集合则矛盾。
- `CF 766E` 拆位&树dp&dfs。求区间异或值的和通常需要用到拆位。随意选取一个根，通过各个节点到根的前缀异或和，维护每个节点及其的子孙的前缀异或和拆位后的每一位个数。利用中序dfs可以一次性求出每个节点为根的子树中所有路径的异或值的和。$O(n\log{max\{a_i\}})$。
- `CF 762A` 求因数，小心平方时爆ll。
- `CF 762B` 水贪心。
- `CF 762C` 观察到只能删除中间的一段，使得两头合并后成为子序列。因此正着反着分别处理一遍子序列在原串中对应的最远的位置。然后枚举一端，二分找另一端，更新答案就可以了。
- `CF 762D` dp。注意到只有3行。可以发现基本不需要考虑往回走的情况，因为每个位置只能被访问一次。且所有往回走可以被样例2解释中的仅返回一格的蛇形路径等效替代。因此只需要额外增加一种转移就可以一行一行往下dp了。

## 2017-2-5
- `CF 764A` 水。
- `CF 764B` 水。交换奇数位置。
- `CF 763A` dfs。随意找一条连接两个不同色彩点的边，判断这两个点是否可以作为根，否则这两个点必然位于同一棵子树即无解。不存在这条边的时候随意找一点。(eat shit记录：随手写了个记忆化搜索树形dp，却显然可以被菊花图卡掉。吃屎。)
- `CF 763B` 抖机灵。注意到边长只有奇数。因此考虑其中左上顶点，按照奇偶性(odd,odd)，(even,even)，(odd,even)，(even,odd)分成四组。这四组内部互不相交，因此直接涂色就好。
- `CF 761F` 前缀和&暴力。通过打标记和前缀和可以预处理出每个点$(x,y)$上各个字符分别有多少个。再用原图求一遍前缀和可以得到所有图从$(1,1)$到$(x,y)$的相对原图前缀距离和。同样也可以求出对于每个点对于某种特定字符距离，得到关于某种单字符的前缀距离和。用$\Sigma$表示字符集。这样每一张图对于所有图的距离可以在$O(\Sigma)$复杂度下求出。总复杂度$O(\Sigma*(NM+K))$

## 2017-2-4
- `POJ 1201` 线段树&贪心||差分约束&SPFA。1.将区间以右端点为key排序，用线段树考虑当前区间有多少个点，并尽可能在靠后的位置插入点。2.题目条件显然无负权环。考虑$d[i]$表示小于$i$的区间选中点的最少个数。$d[i] \leq d[i-1]+1$从$i-1$到$i$连边权$1$的边，$d[i-1] \leq d[i]$，从$i$到$i-1$连接边权为$0$的边。$d[a_i] \leq d[b_i+1]-c_i$，$b_i$到$a_i$连接$-c_i$的边。求$(d[n+1]-d[1])$的最小值，即最短路的相反数。
- `UVA 11990` 树套树，线段树&树状数组。动态逆序对问题。思路是计算出总的逆序对数量，之后每次查询当前删除的元素的逆序对贡献数。构建归并树，每个节点同时维护一个区间大小的树状数组，有序序列相当于是离散化的hash。删除时将当前的位置对于节点的树状数组对应位置$-1$；计算逆序对贡献时，利用树状数组，删除位置靠前的节点查询比删除值小的数的数量，反之查找比删除值大的数的数量。复杂度$O(n\log n+m\log n\log n)。$

## 2017-2-2
- `POJ 3494` 栈。求最大全$1$子矩阵。
- `SPOJ MINSUB` 栈&二分。二分矩阵中的最小值，按照与当前处理的最小值数字的关系将矩阵处理成`01`矩阵。之后利用求最大全$1$子矩阵的方法。
- `SPOJ INTSUB` 组合计数。枚举$a$，可以得到候选的$b$的个数$b_a$和比$a$大但是不能整除$a$的数字个数$c_a$，答案是$\sum_{a=1}^{2n}(2^{b_a}-1)2^{c_a}$，边算边取模。

## 2017-1-31
- `CF 756C` 线段树。注意到每次询问时答案应当是`push`操作数等于`pop`操作数后的第一个`push`。因此考虑一个后缀和，每次`push`操作，将$1$到当前位置的区间$+1$，`pop`则$-1$，每个节点维护当前区间的最大值。查找时只需要沿着最大值大于$0$的线路一路向右节点走即可。
- `CF 761A` 水&&trick。$0$ $0$有点坑啊。
- `CF 761B` 水。
- `CF 761C` 瞎暴力。
- `CF 761D` 瞎贪心。
- `CF 761E` 构造。当项数有限时，$\sum_{i<0}2^i < 1$，所以选取一个2的幂次作步长，每一步都除以$2$。永远都不会交。
- `SPOJ UCV2013E` 组合数。套路题？答案是$C(n,x_1)C(n-x_1,x_2)\cdots C(n-x_1-x_2-\cdots-x_{n-1},x_n)$。组合数比较小，模数是质数$1e9+7$，直接预处理阶乘和逆元即可。
- `POJ 3250` 栈。日本人书系列，经典单调栈的运用，求最近的比自己大（小）的值。
- `POJ 2559` 栈。同上。
- `POJ 2082` 栈。同上。

## 2017-1-26
- `CF 760A` 水。
- `CF 760B` 模拟。注意到枕头会被分配为三角形。一层一层往下发放即可。
- `CF 756A` dfs。将数字做为节点的连通块拼起来，同时保证1的数量为奇数。
- `CF 756B` DP。显而易见的水DP，转移时二分找一下就好了。
- `CF Gym101142K` 水。随便做。
- `CF Gym101142B` 构造&贪心&恶心。简单的通过集合交，可以得到同时与`B`和`G`相邻的人数$t=x+y-n$，只与`B`相邻的人数$x'=x-t$，只与`G`相邻的人数$y'=y-t$。可以观察到计数时其实只考虑相间隔的两个字母，与中间无关，因此间隔着取串中的字符，得到新的串：答案计数只考虑新的串的相邻位置的情况。易注意到间隔取字符构造新串时，若$n$为奇数，只得到一条重排列后的新串，若$n$为偶数，则得到两条互不干扰的新串。我们只需要构造新串，再将新串按照间隔恢复原串即得到答案。注意到构造时用到的子串的类型有$3$类，`..BG..GB..`，`..BB..BB..`，`..GG..GG..`，通过$t$的数值来添加第一类串，再分别补全第二类和第三类串，即可成功构造。考虑无解的情况：1.`t<0||x'<0||y'<0`；2.`t>0&&(x'==0||y'==0)`；3.`t&1`；4.`(n&1)&&t==0&&x'!=0&&y'!=0`；5.`!(n&1)&&(t==0&&x'!=n/2&&y'!=n/2)`；6.`!(n&1)&&(t>n/2/2 + n/2/2)`；7.`!(n&1)&&(t<=2)&&(max(x',y')<n/2)`；

## 2017-1-19
- `CF 752A` 水。
- `CF 752B` 水。
- `CF 752C` 简单贪心。方向矛盾点记录就好。
- `CF 752D` 贪心&STL。注意处理下本身回文的串即可。
- `CF 750C` 贪心|数学。随便解下不等式。
- `CF 414C` 分治。似乎是今天唯一还行的题，归并排序求逆序对的变形。处理出归并树每一层逆序对的个数，感性地发现每次翻转都是将归并树的某一层极其更深层的逆序对个数反转（即与最坏逆序对数做差，需要注意的是这道题每个数字可能相等），而不会影响靠近根部分层数的计算结果，这样每次修改和求值可以做到$O(logn)$。
- `CF 758A` 水。
- `CF 758B` 水。注意循环。
- `CF 758C` 暴力模拟。注意细节。
- `CF 758D` DP|贪心。易证明低位数字尽可能多，预处理出串哪些部分可以取，往前暴力贪。

## 2017-1-18
- `CF 754C` 字符串&dp。很恶心的题，$dp[i][j]=第i行信息可能与第j个人匹配$，先验证可行性，再沿着dp处理的反方向回溯解。
- `CF 754D` 优先队列&贪心|树状数组&离散化。选取$k$个区间使其公共区间长度最长，由于该区间必然由某个左端点开始，可以按左端点排序，从小往大依次将右端点入队，保持队列中元素个数为$k$，每次删除队顶最小的右端点，更新答案；同理，答案区间与某个左端点有关，因此枚举每个左端点，用树状数组维护右端点的位置，二分查找右端点更新答案。
- `CF 757C` STL&排序。很容易发现每个gym相当于将出现相同次数的点划分为一个集合，求在所有gym中出现次数都一样的点。用vector维护每个点在不同gym中出现的情况，用vector整体排序就可以。复杂度$O(nlogn)$
- `CF 757D` 状压dp。$75$位最多只能被划分$1-20$，$dp[i][mask] = 前一个划分线位于第i个位置，当前已得到mask集合的数字的划分方法数$。复杂度$O(N*2^{20})$。这么简单的dp为什么还得看了题解才会呢？
- `HDU 4864` 贪心&优先队列。注意到$x$优先级必定高于$y$，按$x$从大到小贪，每次选取符合当前$x$的机器中$y$最小的那一个，$y$很小，直接遍历就可以。


## 2017-1-17
- `CF 755F` 贪心&dp。将赠送和带礼物的关系看作边，构造图，形成若干个环连通块。考虑最大值，很容易发现贪心是work的，比较简单。考虑最小值，取若干连通块使得和为$k$，则答案为$k$，否则答案$k+1$，用背包来验证。注意到验证$k$和$n-k$等价，用其中较小的一个数做背包容量，二进制分解的多重背包强行冲过。处理连通块时用到了一次排序，$O(min(k,n-k)logn + nlogn)$
- `SPOJ STO02` 字符串`Manacher`。可以注意到取反翻转相等的条件和回文十分相像，注意到这一点后这个题就变成了类回文子串的计数，修改manacher的判断条件即可。需要注意的是根据题目要求，子串必须是偶数长度，因此将每个标为`#`的位置的子串数量相加即可，需要注意的是当串为奇数的时候必然不满足要求，将非`#`位置直接置$0$即可。复杂度$O(n)$。
- `SPOJ STARSBC` 欧拉函数。易满足条件的图是与$n$互质的数，而$k$与$n-k$会得到一样的结果，因此答案为$\varphi(n)/2$。复杂度$O(\sqrt{n})$
- `HDU 3068`  字符串`Manacher`。裸题，求最长回文子串的长度。犯了个智障错误一直在吃屎。
- `HDU 3294`  字符串`Manacher`。发现回文串只与字符是否相同有关，与具体值无关。这就变成了裸题了，注意下输出方式。
- `CF 754A` 构造。只有全$0$才无解，把数组中的$0$分配到相邻的子数组中即可。
- `CF 754B` 暴力水。

## 2017-1-16
- `CF 755A` 暴力水。
- `CF 755B` 简单博弈。显然$n\neq m$时，较大一方胜利，相同时奇数先手胜，偶数后手胜。
- `CF 755C` 并查集。从树上任一点找到的最远距离点必然是树上最长链上的某一个端点。只需要将每组提到的点对放入同一个集合，最后的集合数量是答案。
- `CF 755D` 树状数组。点修改，区间查询，需要注意处理$k = min(k,n-k)$复杂度$O(nlogn)$，存在线性的做法。
- `CF 755E` 图论构造。有结论：自补图的直径小于等于3。证明的方法：证明如果一个图的直径大于3，则其补图直径小于等于3（谢谢QLS）。可知当$k > 3$时无解，显然$k = 1$和$n\leq 3$无解。当$k=3$时，构造$1 \rightarrow 2 \rightarrow 3 \rightarrow 4$，将5以后的结点连入连结$2$和$3$，这样形成直径为3的自补图。当$k=2$时，$n=4$无解，$n>4$时构造一个$1 \rightarrow 2 \rightarrow ... \rightarrow n$的链，其补图的半径为2。