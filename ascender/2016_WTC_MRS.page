A. 2016 \[zmy\]
===============

观察一波超级合数，使用的质因数都比较小，$1e18$
内的超级合数最多使用质数到 $23$ ，为了放宽条件，使用 $100$
以内所有质数。用两个变量维护当前约数个数的最大值和次大值。然后我们构造所有的数。猜测每个数都是由一个比其小的满足条件的数乘以一个质数得到的。这样我们可以维护一个堆不断取出构造出的最小值，然后判断其是否满足条件。

B. Airports \[zmy\]
===================

曼哈顿距离转切比雪夫距离，按照 $x+y$ 和 $x-y$ 排序分别搞。
每次只用考虑每个点能否与 $1$ 和 $n$ 连通，用并查集维护一波即可。

C. Jump \[zmy\]
===============

用数学表达式写下来，发现 $s$ 前面的系数只能是 $1$ 或 $-1$
所以我们只用奇偶分层跑 djikstra 即可。

D. Merge \[zmy\]
================

考虑 $f[i][j]$ 表示第一个排列选到 $i$ 第二个排列选到 $j$
时本质不同的排列个数。 如果当前 $a[i]!=b[j]$ 那么
$f[i][j]=f[i-1][j]+f[i][j-1]$
。否则会有重复的情况。考虑计算了多少个重复的。我们不停往前找，连续会有多个
$a[i-k]=b[j-k]$
的情况。对于每个这种情况，为了让其有序，我们考虑第一个弹出个数一直比第二个大的方案数多的方案数。这个是卡特兰数。

E. Mirror Rice Cake \[zmy\]
===========================

排序贪心。

F. Number Cards \[zmy\]
=======================

首先考虑两个特殊情况。1：如果只有一个颜色，那么答案有无限种。2、如果有两个颜色的区间有交，答案一定为
$0$
。我们把每个区间的编号都减去一。这样我们需要保证两个端点在同一个区间，则其对$M$
整除的值应该相同。每个数对所有数整除的结果只有 $\mathcal{O}(\sqrt{1e9})$
种，我们把左右端点的这个区间都求出来，然后分别求教。这样我们对于每个颜色都得到了若干个方案。最后按照顺序进行
dfs 。

G. Paint \[zmy\]
================

问题主要在于多段可能会有重叠部分。我们很容易想到，枚举有多少段，然后每段有一个长度限制。比如长度为
$x$ 和 $y$ 两段拼起来长度不能超过 $x+y$
。但是对于一些情况，这样可能会有重复。为了避免重复，我们需要预先处理出若干个长度区间。我们求解每段黑色在这个区间内的方案数。这部分用容斥
+ 组合数可以搞出。

H. Random Walk \[zmy\]
======================

发现正着很难想。我们考虑总格子减去重复格子数。为了避免重复，我们需要计算每个格子在后面一个格子时第一次回到此点的方案。发现我们需要求出从起点出发，走特定步数第一次回到原点的方案数。我们可以先用组合数求出走特定步数回到原点的方案。再用
dp 求出第一次回到远点的方案数。

I. Robots \[zmy\]
=================

map 套 set
维护点的坐标。再用一个堆维护所有碰撞事件。不过为了避免一些重复判断，我们需要保证计算碰撞时，每个点的四个方向都只能被计算一次。出现重复的点，之后的碰撞都与其无关了，可以扔掉。

J. Ropes \[zmy\]
================

prufer 序列。

K. Stains \[wbr\]
=================

首先把所有给定的点差分，得到的若干向量都是位于一线性空间内的整点，且这个线性空间的基底为两个等长正交的向量，而我们需要求的就是模长最大的基底。类比一维的问题，我们显然需要做二维gcd。这里给出一个简易的实施办法。我们可以用虚数表示一个向量，即用$a+bi$代表向量$(a,b)$。那么设一个基底为$p+qi$，那么另一个基底就是$i(p+qi)=-q+pi$，也就是说对于任意向量$a+bi$，其在这个基底下的坐标即为$\frac{a+bi}{p+qi}$的实部和虚部。利用辗转相除法的思想，给定两个向量，我们每次将一个向量减去另一个向量的极大的整数倍，直到两向量共线为止。实现只需要使用复数乘除法就可以实现了。

L. String Modification \[zmy\]
==============================

贪心。

M. Team Competition \[zmy\]
===========================

对于 $n$
为奇数的情况，我们构造所有等腰三角形。对于偶数的情况，我们先构造出 $n-1$
的方案，再进行调整。
