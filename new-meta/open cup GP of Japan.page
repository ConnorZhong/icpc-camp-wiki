A Circles \[Miceren\]
=====================

**题意:**
平面上有$n \leq 1e5$个圆，每个圆都过原点，现在问他们的并能覆盖多少平面上的整点。所有圆的圆心坐标绝对值不超过$100000$。

**题解:**
两个圆交最多就2个，一个已经是原点了，所以至多还有一个。考虑我们算出这些圆并集的外轮廓，这个可以通过可以对所有圆的圆心求凸包，那么那些在凸包上的圆心所代表的圆才能是最后在轮廓上的那些圆。

考虑怎么算整点，因为圆坐标范围有限，考虑我们枚举$y$，计算y对应的这一条水平线上有多少的$x$满足限制。

可以发现对于一个给定的$y$，可行的$x$肯定是若干段区间的并。按照一般的做法，我们把这些的关键点抓出来，打上标记$+1, -1$，然后扫一遍就好了，那么本题最大的难点来了，如何弄出关键点。

一个很自然的想法，我们把圆在这个轴上覆盖的区间拿出来(区间端点不一定是整点)，对于这些区间，我们把左右取$lower or upper$，即可算出整点。

我们肯定是对于每一个圆，算出在这个圆上的关键点。对于一个圆，我们可以算出他在最后的轮廓上，贡献的圆弧在$y$上的跨度，算出跨度，对于每一个可能的$y$算事件点。这个复杂度被最后的轮廓的周长bound住，复杂度没有问题。

关键问题，我们怎么找到所有和某一个圆，在某个$y$上的所有关键点呢？

首先我们要先定义清楚一个策略，防止关键点被重复添加，一个圆上的事件点必须要在他做出贡献的圆弧上，如果是严格在圆弧的角度区间内部可以直接添加，但是如果在边界上，需要判断这个事件到底是什么，换句话来说，我们需要知道这个点到底是某个区间的开始，还是结束，还是开始和结束。

幸好一个简单的办法是，我们只要check在凸包上相邻的这三个圆对这个点的包含关系（严格在里面，左贴边，右贴边？），就可以算出来了。

为了保证精度，这道题大部分都是整数运算，某些需要根号的都蛋碎处理了。所以最后真的写的很冗杂。

[code](2016/9/26 A)

C.House Moving \[Miceren\]
==========================

**题意:**

有$m$个人，每个人有一个权值为$p_i$，现在要把他们分到$1 \cdots n$这些位置上去，并且保证每个位置分到最多一个人。分完之后，使得下式子最大。（假设$x_i$表示第$i$个人分到的位置)。

$$ \sum_{i < j} |x_i - x_j| p_i p_j$$

**做法:**

首先一个显然的性质，我们肯定是把这些人分在这个数轴上的两侧，而且从外到内，$p$单调不增。
然后考虑dp，考虑到最后的总权值其实也就是对于两个相邻人的位置，我们算这个位置左边人的$p$的和$sumL$,
和右边人的$p$的和$sumR$。使得这个$sumL * sumR$的和尽量大。直接考虑$DP$

$f(i, j)$代表前$i$个弄完了，左侧分配的人权值和为$j$，$dp$ 一下就好了。

[code](2016/9/26 C)

F.House Moving \[Yuzuriha Inori\]
=================================

**题意**:

有坏点的网格中要你从指定起点走一条每步都转90度弯的遍历所有没坏的点的路.
问可能不可能.

**做法:**

因为每步都要转弯, 所以除了起点和终点,
每个点都要有一条横边和一条竖边连接. 因为要遍历所有点,
所以每行都是相邻的空格子之间连横边, 每列也都是相邻的空格子之间连纵边.
这样连好以后, 因为除了起点和终点以外每个点度数都是2,
所以从起点开始走一遍就能判断是否是合法的路径. 但我们不知道终点.
枚举终点会TLE. 注意到为了能把横边和纵边连好,
每行每列的空格子数都必须是偶数, 此处起终点要特别计算,
例如起点走的是横边, 那么起点所在的列就不能把起点算作空格子, 终点亦然.
因此为了满足这个偶数的条件,
终点的枚举范围可以从整个网格缩小到当前是奇数的那一行或一列.
