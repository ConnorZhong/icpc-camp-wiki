B. Binary Code
==============

**题意:**

给你很多个01串，每一个串内部可能有一个'?',现在要求你给这个?赋值，使得最后每个串之间不会有前缀的关系。字符数之和为$5e5$。

**题解:**

首先我们枚举每个'?'是什么来建立tri树，对于相同的串，我们需要加一个虚拟点来唯一表示。

剩下的就是2-sat
问题，关键在于我们借助tri树上的**虚点**来辅助建边，对于tri上的每个点，建立up,
down。最后的点数是$2(tri_node + #strings)$，最多500w，其实小得多。

[code](NEERC16%20B.cpp)

D. Delight for a Cat
====================

**题意:**

现在有一个bacon，天天只会睡觉和吃东西，有$n \leq 1000$天，每天吃饭或者睡觉有一个收益$a[i], b[i]$。现在问这$n$天怎么安排，使得每$k$天，至少$ms, me$天在睡觉和吃饭。在满足要求的情况下要求受益最大。

**题解:**

首先假设他每天都吃东西，有一个初始收益，然后就是一个线性规划了。

设$x[i]$为0、1,
代表他第$i$天要不要换。那么$me, ms$就相当于每k天，有一个x的和的上下界。而换的收益就是$b[i] - a[i]$。

然后我们把方程列出来。

$$lower \leq \sum_{j=0}^{k-1} x[i+j] \leq upper$$

引入y, z变量，写成等式，注意这里的y, z是大于等于0的任意数字，有
$$\sum_{j=0}^{k-1} x[i+j] + y[i] = upper$$
$$y[i] + z[i] = upper - lower$$

相邻式子相减，大概就有 $$x[i+k] - x[i] + y[i+1] - y[i] = 0$$
$$y[i] + z[i] = upper - lower$$

注意边界，第一个式子还是 $$\sum_{j=0}^{k-1} x[j] + y[i] = upper$$
要稍微特殊处理。

但是注意，到这里还是没法像志愿者招募那样弄。因为并不是每个变量正反最多出现一次，换一下有。

第一个式子 $$\sum_{j=0}^{k-1} x[j] + c - z[0] = upper$$

$$x[i+k] - x[i] + upper - lower - z[i+1] - y[i] = 0$$
$$y[i] + z[i] = upper - lower$$

这样就大功告成啦！

然后愉快最大费用流，但是要注意到我们有下界，所以是上下最最大可行流。这个题目可以直接设置正无穷大费用边引流。

[code](NEERC16%20D.cpp)

G. Game on Graph
================

**题意: **

现在爱丽丝和鲍勃玩游戏, 他们轮流在一个有向图上沿着边移动一个棋子.
谁将棋子移动到一个出度为$0$的点, 他的对手就输了. 然而他们的目的不尽相同.
Alice很享受这个游戏, 所以他希望把游戏无限进行下去. 如果做不到,
他想赢得这场游戏. Bob赶时间, 他想赢得这场游戏, 如果做不到,
他宁可输掉(也不愿无限玩下去). Alice和Bob互相知道对手的目的.
问Alice和Bob都足够聪明的情况下,
游戏所有可能的起始局面将会达到何种结果(一共$2n$种起始局面,
即一开始棋子在哪个点上以及谁先手).

**做法: **

首先确定平局(即Alice强迫Bob无限玩下去)的情况. Alice最喜欢平局,
而Bob最讨厌平局. 所以, 一旦Bob先手的状态的一个后继被确定不是平局,
这个状态也不是平局; 当Alice先手的某个状态的所有后继都不是平局,
这个状态才不是平局. 按照这个规则搜索到的状态都不是平局, 剩下的是平局.
初始状态是, 所有出度为$0$的点无论谁先手都不是平局.

然后确定胜负. 将第一步的平局去掉, 按照一般的游戏胜负规则搜索.
初始状态还是所有出度为$0$的点.
现在没搜到的状态全是Alice赢(因为现在没搜到的状态是两个人都不想输情况下的平局情况,
然而Bob如果陷入这种情况是宁可输掉的).

[code](NEERC16%20G.cpp)

I.Indiana Jones and the Uniform Cave
====================================

**题意: **

现在你在迷失森林中. 这个森林由若干空地组成,
每个空地上都摆着一圈共$k$个传送门可以把你传送到别的(或者这个)空地.
然而你并不知道一共有多少块空地, 每块空地也无法区分,
每块空地中的传送门之间也无法区分. 所幸每块空地上有一块石子,
初始都在空地中间. 你可以把这块石子放在某个传送门的左边或者右边,
以后再回到这块空地时就能看到这个石子. 换句话说, 你每被传送到一块空地,
看到的景象只有三种, 即中间有块石子, 某个传送门左边放着一块石子,
或者某个传送门右边放着一块石子. 由于传送门是排成一圈的,
所以你每次可以任意挪动石子, 并参照石子使用一个特定的传送门. 例如,
你可以将石子放到现在所在的传送门顺时针的下一个传送门的右边,
并使用再下一个传送门离开.
你的目标是使用所有的传送门一次(保证空地之间两两可达).

**做法: ** 需要我们用石子模拟dfs. 石子在中间, 就是新点,
石子在右边可以表示在栈中的点, 石子在左边就表示dfs结束的点.
我们每次把石子顺时针移动一下, 再从这个传送门出发便可.
但这道题不允许我们立即返回, 所以当我们dfs到返祖边, 横叉边的时候,
需要能走回当前dfs的点. 如果遇到返祖边, 即栈中的点,
我们可以要求栈中的石子始终标识当前他的儿子的方向, 这样我们就能走回来了.
由于不知道返祖边的终点的深度,
我们必须标记后走一圈以得知走几步能走回当前的点. 如果遇到横叉边,
我们也希望走回来. 这就需要退栈的时候将当前点的石子摆在一个合适的位置上.
摆在每一个位置, 沿着走都最终会回到栈中的点上.
只要摆在这之中回到的栈中的第一个点最浅的那个方向上即可.
这样用循环不变式即可证明如果走了横叉边, 一定能回到自己栈中的父亲那里.

[code](NEERC16%20I.cpp)
