B. Bipartite Blanket (Done By Miceren)
======================================

**题目描述:**

给你一个二分图$(VA, VB，E)$，其中$|VA|, |VB| \leq 20$，现在每个点都有一个点权，问这个图有多少个子集，满足

-   点权之和大于某个给定值$t$。

-   点集被某个匹配cover(也就是是某个匹配的点集的子集)。

**题解:**
首先我们可以发现，第二个限制看上去是个难点，导致我们没法把两边拆开。

但是$Thanks to the bipartite god!$，我们竟然可以分开:

**如果存在一个匹配cover左边的一个点集$A$,
同时存在一个匹配（不需要和之前的一样）cover右边的一个点集$B$。那么就存在一个匹配同时cover$A, B$。**

大家可以用反证法来解释，这里就不赘述了。

然后就是我们要求左边哪些点集是可以被某个匹配覆盖的呢。

**SB的办法**
我们一边DFS枚举点集，一边做匈牙利。可以发现我们匈牙利快速查找没有匹配过的点，从而可以优化到每加入一个只要$O(n)$的复杂度。

**机智的办法**
根据hall定理，我们直接检查每个子集是不是满足条件，再加上自己是否满足条件即可，这个可以直接写成dp的形式。

总的来说，第一个方法唯一的优势可能在于可以少开一个100w的数组吧。

[code](CERC 2016 B.cpp)

D. Dancing Disks (Yuzuriha Inori)
=================================

**题目:** 现有$6*6$根柱子摆成一个网格状,
左上角的柱子上放着一些盘子(类似汉诺塔), 从下往上盘子的大小是$n$的排列.
现在允许你每次从一个柱子上拿顶上$k$个, 放在他右边或下边的柱子上.
最终目标是使得右下角的柱子上按顺序放置所有的盘子. 构造方案.

**做法:**
容易想到一个柱子上的东西的排序算法肯定和他右边和下边所有的柱子的排序算法有个递归调用的关系.
用$cap[i][j]$表示$(i,j)$位置上的柱子最多能排好多大的排列,
那么有一个显然的递归让我们做到$cap[i][j]=\sum_{(i',j')在(i,j)右边或下边}cap[i'][j']$.
只要从$(i,j)$柱子的最顶上的盘子开始, 根据盘子的大小让他去另外一个柱子,
使得所有的盘子走后,
右边或下边的每个柱子上都是排好序后的连续的一些大小的盘子.
然后我们在递归调用这些柱子的排序算法即可. 最后,
这样不够排题目要求的范围. 需要一个小trick:
和终点相邻的柱子其实能排序大小为$2$的排列,
这也是我们唯一一个用到从柱子顶上拿$>1$个盘子的操作的地方.
[code](CERC 2016 D.cpp)

E. Easy Equation (Yuzuriha Inori)
=================================

**题目:** 给定$n$和$k$,
求$n$组关于$a,b,c$的方程$a^2+b^2+c^2=k(ac+bc+ab)+1$的正整数解,
要求所有解中出现的$3n$个正整数各不相同.

**做法:** 打个表.
发现在一个解中作为最大的两个数好像一定会在别的解中作为最小的两个数字出现.
这提示我们解可以每次变化$a,b,c$中的一个来BFS得到. 假设一组解为$a,b,c$,
另外一组为$a,b',c$, 可得$b+b'=k(a+c)$. 这就是BFS的公式.
最后观察一下$1,k,k^2+k$作为初始解就可以BFS了.

[code](CERC 2016 E.cpp)

G. Geohash Grid （Done By Miceren）
===================================

**题目描述:**

给你一个$2^n * 2^n$的grid，设当前的矩形区域为$(0, 0, 2^n - 1, 2^n - 1)$,
对于格子$(r, c)$编号规则如下:

-   把当前矩形横竖平分为$4$块，如果$(r, c)$在右边，当前最高位为1，否则最高位为0.

-   如果$(r, c)$在下面，则最高的第二位为0，否则为1。

-   然后根据$(r, c)$在哪一块继续递归下去。

总而言之，这样的编码规则保证了，对于这个大grid中的任意两个格子$(r_1, c_1)$,
$(r_2, c_2)$，如果$r_1 \geq r_2, c_1 \geq c_2$，那么前者的编号一定不小于第二个格子的编号。我认为这样的定义和上面的规则是等价的。

那么现在给你一个grid上的简单多边形，边都是平行于坐标轴的。

现在有$Q$个询问，每个询问给你一个$k$。你可以选择$k$个连续的编号区间，是的这些区间的并cover这个简单多边形，且多覆盖的部分尽量小。

$n \leq 30, Q \leq 1e5, k \leq 1e9, 多边形上的拐点数 \leq 200$。

**题解:**

首先，如果$k = 1$，我们取的区间肯定是从这个简单多边形中最小的编号到最大的编号。

那么再多一个区间会如何呢？我们可以把这个问题取反，其实就是我们在一开始取得大区间里面『挖洞』。并且肯定会挖最大的$k - 1$个洞。

那么一个自然地想法是，我们需要提取出来所有的洞的信息。

因为询问很多，每个$k$也很大，很容易看出，这个『洞』也确实会达到$1e9$的级别。

但是size不同的洞的个数肯定不会太多，这个的证明可以自然而然的由做法得出来。

**简单做法:**

首先我们根据编号的过程进行递归，对于每个递归到的矩形$x_1, y_1, x_2, y_2$，我们都会继续分裂成两个递归下去，而这个『洞』就产生在每次分开的时候。

总的来说会有这么一些case。

-   如果有一个点被包含在矩形里面，那么我们两边都往下递归。

-   如果矩形和简单多边形没有交，直接返回。

-   以上不满足，且只有横线穿过矩形
    如果当前是横着划分，那么我们还是两边递归，否则，我们只递归一边。因为另外一边肯定是一样的。

-   只有竖线穿过矩形 如果当前是横着划分，只递归一边，否则两边都递归。

以上可以用势能分析来解决，一个矩形的势能为，$里面包含的点 * log 矩形面积$。

然后维护洞的大小的话，可以传递一个scale变量下去，代表当前的一个hole其实代表了多少个hole。

最后查询直接lower\_bound就好。

[Mike's code](CERC 2016 G_Mike.cpp)

**我的复杂做法:**

因为一开始没有观察到如此优美的做法，我的做法稍显繁琐。一开始我会把这个简单多边形划分成大小阶不变的不交矩形。

然后递归的时候，我会根据两边形状的hash值来考虑是否两边都往下递归。

[My code](CERC 2016 G_Me.cpp)

I. Invisible Integers (Done By Miceren)
=======================================

**题意:**

请你构造一个数列，每个位置是$1~9$中的一个数字，现在有$n \leq 10$个限制，每个限制给了你一个数列，要求你满足

-   你构造序列中，从某个位置开始，往某个方向走，每遇到一个之前没出现的数字，就append在自己当前的数列后面。最后得到它给的数列。

要求你构造个长度最小的数列满足以上的限制。

**题解:**

首先，我们肯定是要从左到右来依次知道每个位置的值。那么问题是我怎么表示状态呢？

因为每个数列可能是往左走的，也可能是往右走的。那么我们分别记录

-   往左走得，出发位置最靠左的，并且cover了当前位置的序列是谁，他匹配到了哪个位置。（状态为$nv$）

-   往右走得，出发位置最靠右的，并且cover了当前位置的序列是谁，他匹配到了哪个位置。（状态为$nv$）

-   当前已经考虑了哪些个序列了。（状态为$2^n$）

然后可以发现可以转移，但是因为状态已经有了$2^n*n^2*v^2$，我们的转移最多也就只能为$O(v, n)$。

所幸小心一点的确可以做到这个复杂度。

完结！！

[code](CERC 2016 I.cpp)
