A. Alone in the Cactus
======================

**题意: **

有一个仙人掌. 现在一个人在其中随机游走, 但是不会选择已经去过的点.
这个人在有限步之内将会无路可走. 这时, 如果走到了红色的点, 这个人就赢了,
如果走到了绿色的点, 这个人就输了, 如果走到了蓝色的点, 这个过程就重置,
人回到起点重新走. 现在问这个人赢的概率.

**做法: **

仙人掌DP. 对于一个环, 只要正反DP一遍就行了.

B. Binary Neural Network
========================

**题意: **

让你用神经网络构造任意$n\le 10$元布尔函数.

**做法: **

我们希望构造一个神经元, 使得它的输出为(接近)1,
当$n$个布尔变量都是我们想要的值, 否则输出为(接近)0. 怎么办呢?
因为一个神经元的输入是上一层神经元输出的线性组合,
并且我们可以构造一个没有输入的神经元当做常数,
所以这个线性组合中也可以有常数. 如果上一层有$n$个输入,
对于我们希望为$1$的输入, 只要令那个神经元对当前神经元的系数为$1$,
对于希望为$0$的输入, 令系数为$-1$, 并且常数$+1$.
这样当前神经元的输入就是"有多少个输入是我们想要的值"了.
再将常数减去$n-0.5$, 再缩放若干倍,
就能做到"当所有输入都是我们想要的时候输出为1"了. 有了这个基本构造,
只要对于布尔函数中答案为$1$的参数组合使用这个基本构造,
最后再来一个神经元把这些基本构造的结果加起来就行了.

C. Chess Puzzle
===============

**题意: **

有个马从$4\times n$的格子的左上角开始走, 不能重复经过格子,
最终回到左上角. 问这个过程中最多能经过多少格子, 并给出任意方案.

**做法: **

打表发现答案大概是格子数减2. 当$n$足够小时, 直接爆搜. 当$n$比较大的时候,
拆成两半, 每一半搜出一组"从起点到最后一列的第一行(或第三行),
然后跳到另外一半, 再从最后一列的第三行(或第一行)回来, 并跳回起点"的解.
这种解在$n\ge 4$的时候只浪费一个格子, 所以两半拼起来就好.
当$n$更大的时候, 头尾像刚才一样搜两组解,
中间每长度为$5$的一段$[1\ldots 4]\times [a,\ldots,a+4]$搜一个$\text{从上一节来} (1, a),\ldots,(2, a+4), \text{此处跳到下一节} (4, a+4), \ldots (3, a) \text{最后回到上一节}$这样的解,
就能无限复制连起来了.

D. Dominoes
===========

**题意:**

给你一个$n * m \leq 56$的网格，每个格子可以是障碍，或者关键格子，或者是普通的空地。

现在有一套多米诺($28$张，为$(x, y), 0 \leq x \leq y \leq 6$的所有pair)。要求你覆盖这些非障碍的格子，使得关键格子的点数之和最大。

**题解:**

直接状态压缩DP即可。可以发现我们覆盖完之后只关心有多少个$关键-关键$的格子，根据关键格子的总个数，自然可以推算出有多少个$关键-普通$格子。状体压缩完之后枚举每种格子对的个数，知道了这个之后就再背包即可。

E. Experience is Worth It
=========================

**题意:**

有一个$n * m, n, m \leq 200$的网格，每个格子里面有一种野怪。总共有$k \leq 26$种野怪，每种野怪有两个属性$p_i, g_i$代表你消灭他需要$p_i$等级，消灭之后你可以得到$g_i$等级。现在问你有多少个矩形你是可以通过合理的消灭顺序清掉这个矩形里面的所有野怪。

**题解:**

首先枚举矩形的上下边界，那么现在问题就是我枚举了一个左边界，哪些右边界是可以的。

由于只有26种野怪，我们肯定是从$p_i$最少的野怪开始消灭。也就是说，我们要满足$k$个不等式。

$$sum_{Rect, p_j < p_i} g_j \geq p_i$$，很容易发现这些不等式当$l$确定时，$r$的选取是个后缀区间。这个可以线性扫描处理出来。

那么我们假设枚举了$l$，再枚举这里面最厉害的野怪是哪种，在这个限制下，结合上不等式的限制，右端点其实肯定就是一个区间了，直接算即可。

最后复杂度$O(n^3 * k)$。

F. Fix the Matrix
=================

**题意: **

要求你给出一个$6\times 6$的$0,1$矩阵. 你的对手可能会进行行操作:
每一行改一个位置或者不改, 再打乱行的顺序. 或者类似的列操作.
你获得打乱后的矩阵. 你必须能判断你的对手进行的是哪种操作, 或两种都可能.
在此基础上, 你要给出对手是如何打乱行/列的. 不过, 如果打乱方法有多种可能,
此时你的输出必须和对手实际打乱的方式完全一样才算正确.

**做法: **

就是说, 你的方阵必须满足, 任意一行改变任意一个(或者不改)元素后,
行与行之间仍然能区分(否则你没法猜透对手的实际打乱方法).
这其实是要求每两行之间不同的位置至少有$3$个, 每两列也一样. 不太会构造,
所以爆搜一个满足条件的矩阵.

G. Guess the Data Structure
===========================

**题意: **

给你一个序列，要求支持4种操作：append一个数$x$，区间求和，所有数异或一个数$x$，所有数排序。

**做法: **

把序列切成左右两块，左边是在异或$DD$之后，排序，之后又异或了$D$的，所有数未经任何异或的trie。右边是一个一个append进来，之后整体异或了$D$的前缀和数组。

所以append只要前缀和数组加一位就行了。

区间求和：如果想求的位置超过了左半部分，直接调用trie的根，然后加上右边一段前缀和。如果不满左半部分，则在trie树上走一走。由于是在异或了$DD$之后排的序，所以序要根据$DD$某一bit的值重新定义左右。注意这里的求和，需要拆成30位，统计未经异或，每一位1的个数，然后根据当前的$D$就能算出异或以后的和了。

异或一个数：直接修改$D$。

排序：把有半部分每个数拿出来丢进trie里，并把$DD$置为当前的$D$。

这样的话，trie上每个节点需要开一个长度为30的数组，会MLE。注意到这个数组只需要在分叉的时候会用到，这样就少了很多，卡一卡就可以过了。

I. Izhevsk Training Camp
========================

**题意: **

有$9$个permutation($n\le 65536$).现在要你从中选出$3$个,
使得在这$3$个permutation中先后顺序一样的pair${a,b}(a\neq b)$尽量少.

**做法: **

枚举$2$个permutation, 算出逆序对的个数. 对于$3$个permutation,
如果一个pair不满足题目条件, 那么他会在两个permutation对中出现为逆序对.
如果他满足题目条件, 则不会作为逆序对出现. 所以,
满足题目条件的pair尽量少,
其实就是三个permutation两两的逆序对数量的和尽量大.
