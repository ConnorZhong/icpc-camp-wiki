A. Dreissig
===========

**题意:**

现在有一个100个点的完全图，每条边上没有颜色。现在你和对手轮流给没有染色过得边染色。对方每次随机选30条边染成黑色，你每次选一条边染成白色。当存在一条白色哈密顿路径时你胜利。要求玩100盘，你至少赢95盘。

**题解:**

考虑如果我们直接每次在我们当前的链上append一个当前剩下的度数最小的点，到了最后很容易发现最后那一条边很早就被删除了。

我们可以考虑同时维护多个链，每次选度数最少的两个链头合并，这样会减少一点在前期就死掉的可能性。

但是当我们只剩下一条链的时候，如果没法直接连出来一个环，我们枚举链上两个相邻两个点，如果两个链头分别往这两个点上连边，我们就出来一个环了。如果有这个可能性，我们就先连一条边，相当于把我们的链反转一下。重复这个操作，由于敌人是随机挑选，我们很大概率就能弄出来一个环。

[Petr\_Mitrichev\_Contest\_14 A.cpp]()

B. Mond
=======

**题意：**

有一个$100*100$的区域。其中有一个未知的固定点。你可以使用最多60个探测器。你可以给每个探测器规定一些路标（要求第一个路标横坐标为0，最后一个路标横坐标为100），然后探测器会沿路标直线前进。当探测器路径上任意一点和那个点距离小于等于1时会返回1，否则返回0。让你猜出点的位置。

**做法：**

二分。先使用类似T字型填满某块区域的方式整数二分出一个长度为1的范围，然后使用直线的边界去二分逼近。需要注意二分x坐标时，要考虑最左边是从$y=100$还是$y=0$开始，这取决于之前二分出来y坐标的另一边。

[Petr\_Mitrichev\_Contest\_14 B.cpp]()

C. Oha
======

**题意:**

给你一个$n$，你需要构造给出$m, k$以及$m$个长度小于等于$k$的01字符串，使得所有长度为$k$，且不包含这m个串作为子串的字符串个数恰好为$n$。

$n \leq 1e9, m \leq 100, k \leq 60$。

**题解:**

随机，每次我们随机一个串，如果当前随机的这个串和之前所有的串构成的答案比$n$小，我们就加长当前这个串，至于加什么字符随机。

如果当前答案比$n$小了，开始下一个串随机，直到答案刚好等于$n$。

然后就没了。

注意$k$的选取尽量使得$1 << k$接近$n$，否则出解会很慢。

[Petr\_Mitrichev\_Contest\_14 C.cpp]()

G. Tabelle
==========

**题意: **

在$n\times m$的网格上, 每个格子中写着$0$或者$1$.
你可以任选一行或一列或一条对角线(主副方向均可, 不循环),
将这些格子翻转(即\^=1). 问能否把所有格子都翻成正面. $n,m\le 1000$,
要求构造的解翻转次数不超过$10000$.

**做法: **

注意到翻转的次数远小于总共的格子数. 其实只有少数格子是能自由选择状态的,
剩下的都会跟着确定. 结论是自由度为$3n+3m-9$($n,m\ge 3$). 首先证上界.
我们把操作分成$4$类, 即行操作, 列操作, 主对角线操作和副对角线操作.
每种操作的所有操作各做一次, 效果都一样, 都是全部翻转.
所以这里有$3$类操作可以各去掉一个, 不妨设列操作没有被去掉任何一个,
那么别的类别里去掉的操作都可以用自己类别的其他所有操作和所有列操作加起来得到.
然后, 我们把两种对角线操作再分为奇偶两类,
代表所操作的格子的两个坐标是否同奇偶. 可以发现, 主对角线中的$1$个奇操作,
可以用副对角线的所有奇操作和主对角线中其他的奇操作加起来得到.
并且主对角线中的另外$1$个偶操作, 可以用所有列操作,
所有副对角线的奇操作和其他主对角线的偶操作加起来得到. 相应地,
副对角线的$1$个偶操作可以用主对角线的所有偶操作和副对角线其他的偶操作加起来得到.
最后, 用所有的奇行列操作能拼出和用所有的奇主对角线操作一样的图案,
所以还有$1$个操作可以省去. 可以分析发现,
刚才省去的$7$个操作没有循环调用关系,
所以总共$3n+3m-2$个操作的自由度最多为$3n+3m-9$. 下面证明下界.
对于前三行的每一列, 先用列操作确定这一列的第二行的格子,
再用主对角线操作确定这一列第一行的格子,
最后用副对角线操作确定这一列第三行的格子. 只要从左到右确定所有的列,
这$3m$个格子就可以随心所欲地填值. 然后对于从第$4$行开始的每一行,
先用航操作确定这一行第二列的格子,
再用主对角线操作确定这一行第一列的元素,
最后用副对角线操作确定这一行最后一列的元素. 只要从上到下做这些行,
这$3n-9$个格子同样可以随心所欲的填. 现在上下界已经夹紧,
只要按照刚才说的方法确定了这些随心所欲的格子, 其他的格子都已经确定了.
所以将这些随心所欲的格子都填成$1$, 再检查剩余的格子即可.

[Petr\_Mitrichev\_Contest\_14 G.cpp]()

J. Weltall
==========

**题意：**

求字典序为$d$的长度为$n$的$k$错排。其中$k$错排指的是恰有$k$个元素在原来的位置上。

**做法：**

枚举前缀算方案数。后缀计数问题变成：有一些位置和一些数，其中有$j$个数可以任意放（记作A类），有$i$个数不能放到某个特定的位置（记作B类），总共是$i+j$个位置。

考虑$dp[i][j]$，不妨令前j个位置为任意位置，后$i$个位置为特定位置。显然有$dp[0][j]=j!$。

考虑之后的第$i$个位置上放谁。$dp[i][j]$有4中个部分。

(1)$i$这个位置上放了另一个B，且这个B的位置上放了$i$，即互换。$dp[i-2][j]*(i-1)$

(2)$i$这个位置上放了另一个B，且这个B的位置上放的不是$i$，相当于$i$在前$i-1$个里面充当了那个B。$dp[i-1][j]*(i-1)$

(3)$i$这个位置上放了一个A，且那个A的位置上是$i$。$dp[i-1][j-1]*j$

(4)$i$这个位置上放了一个A，且那个A的位置上不是$i$，相当于$i$在前面还是一个B类。$dp[i][j-1]*j$

之后注意到枚举某一位时，往后的影响只有3类，所以可以把3类都算好然后二分，来减少高精度运算的次数。

[Petr\_Mitrichev\_Contest\_14 J.java]()
