A. Almost Longest Increasing Subsequence
========================================

**题意:**

给一个随机排列,
让你在线求出一个尽量长的上升子序列(即每次他告诉你排列的下一个数,
你要决定是否选.) 要求你选至少离线最优解的0.65倍那么多的元素才算通过.

**做法:**

观察随机排列的最优解, 大约为$2\sqrt{n}$级别. 所以策略大概是,
看到一个数字, 如果比现在选过的最后一个元素还小, 肯定要抛弃,
否则看他在当前存活(即没出现过并且比选过的最后一个大)的$t$个元素中是否是最小的$C\sqrt{t}$个之一.
$C$待定. 如果是, 就选, 否则不选. 调一下参数.

B. Bitwise Queries
==================

**题意:**

现在有一个数列，长度为$n \leq 5e5 + 6$，现在有三种操作，一种是区间$and$，一种是区间$or$，最后一种是区间问$min$。

**题解:**

考虑两个操作，可以看成要求一个区间的数字的某些位强制赋值为$0 or 1$。考虑线段树维护，我们在每个线段树节点上记录这个区间在哪些位置上必定是$0 or 1$，还有这个区间里面的最小值。注意这里的最小值是不考虑祖先里面确定位置的情况下，剩下位里面的最小值。

考虑查询，这个很简单，我们递归收集两个孩子的最小值，然后这个区间的值就是两个孩子的最小值加上这一位必定为1的位置的贡献。

考虑修改，如果我们当前希望修改的区间没有完全包含当前线段树区间，我们直接认为这一层确定的位置全部失效，直接push到下层。如果完全包含，那么确定位置的更改我们可以O(1)完成，对于多出来的位置修改，我们强行继续递归。

可以证明这样的复杂度是$O(30n \log n)$，考虑势能为线段树所有点确定的位置个数之和。每次修改，由于不包含的区间只有$O(\log n)$个，而且都push下去，增加势能$O(30\log n)$。包含的区间，如果$mask$还有多的部分，说明肯定会收集一些下面的对应确定位置到这一层来，减少的势能和递归的节点个数相同。

[Moscow IPT Contest B.cpp]()

E. Expected LCP
===============

**题意: **

有$n\le 10000$个random string$s_0,\ldots,s_{n-1}$, $\Sigma=\{0,1\}$.
现在问你$\max_{0\le i\ne j< n}LCP(s_i,s_j)$的期望.

**做法; **

先转换成LCP大于$k$的概率和. 再补集转化. 现在问全部LCP都小于$k$的概率.
这相当于$n$个random string的前$k$位互补相同.
也就是从前$k$位所有可能的$2^k$中方案中,
给每个字符串分配一个(互不相同的). 就是一个排列数. 再对$k$求无穷和.
为了转换成等差数列, 把排列数用斯特林数转换成普通的指数.

F. Finite Walking
=================

**题意:**

现在有一个大小为$n \leq 2e5$的无向图，每条边有一个权值为$a_i$。现在你在上面随便选择起点，随意走出一条路径后，在任意一个点停止，我们设$b_i$为你经过$i$这条边的次数对$a_i$取模。问有多少种不同的$b_i$的组合。

**题解:**

首先要分连通块以此处理，不同连通块答案相加。

对于一个连通块，如果一条边的$a_i$是奇数，那么这个位置$b_i$可以为任意值(因为2和奇数互质，可以通过来回走这条边做出任意数字)。

那么我们把奇数边连接的点缩点，并且答案乘以这些$a_i$。对于剩下的由偶数边组成的图，我们可以发现，我们要的configuration就是每个偶数边是奇数还是偶数。

考虑在上面随便走一条路径，那么走过的偶数边为奇数。再加上很多简单环选或不选也对应了一个方案。每一个方案对应的权值是所有偶数边的$a_i / 2$的乘积。

这样一来直接算就好了。

G. Guess the Distribution
=========================

**题意: **

$$\theta_n = \frac{\lambda_1 + \lambda_2 + \lambda_3 + ... + u - np}{\sqrt(np(1-p))}$$

其中$\lambda_i$为一个$P(\lambda = 1) = p$的伯努利分布随机变量，而$u$是在$[-0.5, 0.5]$上均匀分布的函数。而$\theta$就是通过上面的式子生成的随机变量。

现在给了你$n, p$和一堆$theta$的sample，问$n$是多少。其中$n \in [1, 100]$，要求你输出的答案与$n$差的绝对值取平均后小于等于5。

**题解:**

考虑枚举$n$算最大似然，注意概率密度的计算。

I. Immigration
==============

**题意: **

你从原点开始骑着摩托车沿$x$轴正方向匀速运动. 在$t_0$时刻,
你看到到了培根. 培根匀速运动. 在$t_i$时刻, 培根瞬间变速,
以一个新的匀速运动. 当没有$t_{i+1}$时, 培根就不会在变速了.
你在这个无穷的过程中一直盯着培根, 问你扭头的角速度最大是多少.

**做法:**

先转换为你不动的情况. 然后按定义求角速度.
角速度的最大值出现在变速点的前后, 或者你到培根某一条移动路径的最近处.

J. Jumping on a Tree
====================

**题意: **

有个$n\le 1000000$个点的树, 还有一个参数$d$.
初始每个点在并查集中属于单独的一类. 现在for树上的点对,
两个点如果树上距离为$d$, 就把他们并起来. 问最后并查集里有几类.

**做法: **

我们可以分治. 每次把跨过分治重心的边连起来. 具体的说, 如果分成两半的话,
左边一半深度为$x$的和右边一半深度为$d-x$的如果都至少存在$1$个,
那么应该连接所有这些点. 这样也能过. 其实标程不是这么做的. 直接dfs,
每个点开个vector套vector, 把小的儿子往大的儿子上怼即可.

K. King’s Roads
===============

**题意:**

现在有$n \leq 1e5$个点，每个点有一个label$w_i$，每两个点之间有一条权值为$(w_i + w_j) MOD m$的边，问最小生成树。

**题解:**

考虑一个最小生成树算法，一开始每个点自己是一个连通块，然后每个连通块往外连一个权值最小的边。假设边权没有相同的，这样一来有些连通块可能可能互相指对方，有些可能形成了一棵树(总之没有一个大于等于3的环)。那么我们使用这些边，连通块个数至少减半。

对于这个题一样做，因为性质，我们每次对一个连通块中的点可以很快找到最小出边。(由和是否对于m分成两类，分别线性扫即可)。

由一些简单trick即可做到$O(nlogn)$。

Comments
========

做出7题，最终排名第5.

Miceren:
这一场E题全场很多队伍做出来了而我们没有做出来很伤，再加上J题最后算法解体是我的错，导致浪费了很多时间。
