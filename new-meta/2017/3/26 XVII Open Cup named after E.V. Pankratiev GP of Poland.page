B. Almost pattern matching
==========================

**题意:**

给你一个串$s, t$,
问$s$是否存在一个子串$s'$，使得$s'$和$t$的编辑距离不超过$k$。其中$k \leq 10$,
$|s|, |t| \leq 1e5$。

**题解:**

考虑现在有一个字符串$s'$，我们怎么计算$s'$和$t$的编辑距离。一开始如果第一个字母相同我们肯定直接匹配上，看第二个，第二个一样看第三个，这样一直到第一个不同的位置。然后就有三种可能，一种是我们从$s$中删掉这个字母，或者从$t$中删掉这个字母，或者替换。

那么根据这个过程，我们可以dp，考虑$f[i][j]$代表当前匹配的第一个串和第二个串的位置差为$i$，并且我们操作了$j$次的情况下，第二个串最多匹配到了哪里。

每次用掉一个操作，我们使用后缀数组来求lcp，跳到下一个不一样的地方，然后枚举三种转移即可。

[XVII Open Cup named after E.V. Pankratiev GP of Poland B.cpp]()

**另外一种可能的解法**

这个解法是我自己想的，感觉也应该没有问题，但是现在无限wa，不知道为啥。

还是考虑上面的过程，如果我们枚举一个左端点$l$,到每一个决策点我们直接暴力枚举是哪种，然后使用折半的技术做到$n * 3^{k/2}$复杂度。考虑中间肯定能通过一点trick合并起来。

[XVII Open Cup named after E.V. Pankratiev GP of Poland B.cpp
第二种方法wa的代码]()

D. Mushrooms after rain strike back
===================================

**题意：**

有$n\leq 1e6$堆草。每堆草第一天的时候有$b_i$高，之后每天会长$a_i$。你有$k$天时间，你每天可以割一堆草，答案是总共最多可以割多少草。要求输出$k\in [1,n]$的所有答案。

**题解：**

首先一堆草只会割一次（否则选最后一次）。观察发现，如果我们选好了要割哪些堆的草，那么这些堆一定是按$a$从小到大的顺序割（考虑交换变优）。接着考虑$b$最大的那堆一定会出现在所有天数的解中（如果不出现，考虑它和第一天选的那堆交换），假设这一堆是$j$，可以首先删除这一堆，然后把所有$a_i\geq a_j$的$b_i+=a_i$（相当于经过了一天），所有$a_i< a_j$的$b_i+=a_j$（相当于选了这堆以后，$j$这堆会往后推一天），这样问题就递归了。

所以天数$k$的最优方案，一定是$k+1$天某个最优方案的子集。考虑排列$p_1,p_2,...,p_n$表示前$k$天的最优方案是选择堆$p_1,p_2,...,p_k$。可以按$a$从小到大的顺序插入到$p$中。由于新加入的$a$是最大的，所以他在第$i$天的值（上面一段最后的$b$）为$ai+b$，和别的堆无关，所以它应该在它可以最早成为最大值的位置。注意到如果他在某一天可以成为最大值，那么他在之后一定可以成为最大值，因为别人增加的$a$都比他小。所以可以在平衡树上二分出插入的位置。由于其他的$a$都比他小，所以在他以后的那些$p_i$的值都要加上他的$a$，这是个区间加的操作。

最后的答案是平衡树的所有前缀和。

[D.cpp](2017/3/26%20XVII%20Open%20Cup%20named%20after%20E.V.%20Pankratiev%20GP%20of%20Poland%20D.cpp)

F. Reachability
===============

**题意:** 有一张长方形的纸, 在上边界上画着$n$个点$a_1,\ldots,a_n$,
下边界上画着$m$个点$b_1,\ldots,b_m$.
现在要你在纸上添加任意多的点和有向边, 要求点互不相同,
有向边可以弯曲但是只能在你选择的点处相交.
最终将形成的图中$a_i$能否经由有向边到达$b_j$写成一个$n\times m$的表格,
问表格有多少种可能.

**做法:** 观察发现, 如果剔除没有边相连的点,
那么$a_i$能到的$b_j$对应$j$的一段区间. 且若把每个$a_i$对应的区间写出来,
他们的左右端点关于$i$都不严格单调. 进一步观察可以发现,
上面的条件竟然是充分的!

H. Matching
===========

**题意：**

有一棵$n\leq 2e5$的树。问你有多少对点$(u,v)$，删掉$u$和$v$之后最大匹配数不变。

**做法：**

树形dp。

$f[u][0]$表示$u$这棵子树，不关心$u$有没有被匹配用掉，最大匹配数；$f[u][1]$表示$u$这棵子树，$u$一定没有被匹配用掉，最大匹配数。显然有：要么$f[u][0]=f[u][1]$，要么$f[u][0]=f[u][1]+1$。

$g[u][0]$表示$u$这棵子树，不关心$u$有没有被匹配用掉，删掉了一个点，最大匹配数仍然等于$f[u][0]$，有几种删点的方案；$g[u][1]$表示$u$这棵子树，$u$一定没有被匹配用掉，删掉了一个点，最大匹配数仍然等于$f[u][1]$，有几种删点的方案；$g[u][2]$表示前两者并集的大小。

转移需要讨论$u$的孩子$v$中有多少个$f[v][0]==f[v][1]$。

1.  $f[u][1]=\sum_vf[v][0]$
2.  $g[u][1]=\sum_vg[v][0]$
3.  $cnt=\sum_vf[v][0]==f[v][1]$
4.  $cnt$为$0$
    a.  $f[u][0]=f[u][1]$
    b.  $g[u][0]=1+\sum_vg[v][2]$
    c.  $g[u][2]=g[u][0]$

5.  $cnt$为$1$
    a.  $f[u][0]=f[u][1]+1$
    b.  $g[u][0]=\sum_{f[v][0]!=f[v][1]}g[v][0]+\sum_{f[v][0]==f[v][1]}g[v][1]$
    c.  $g[u][2]=\sum_{f[v][0]!=f[v][1]}g[v][0]+\sum_{f[v][0]==f[v][1]}g[v][2]$

6.  $cnt\geq 2$
    a.  $f[u][0]=f[u][1]+1$
    b.  $g[u][0]=\sum_{f[v][0]!=f[v][1]}g[v][0]+\sum_{f[v][0]==f[v][1]}g[v][2]$
    c.  $g[u][2]=g[u][0]$

然后要求两个点的方案，就是枚举一个根，首先必须要$cnt=0$（删掉这个点匹配数不变），然后把$\sum_vg[v][0]$加到答案里就行了。换根可以讨论$cnt$的情况来维护。

[H.cpp](2017/3/26%20XVII%20Open%20Cup%20named%20after%20E.V.%20Pankratiev%20GP%20of%20Poland%20H.cpp)
