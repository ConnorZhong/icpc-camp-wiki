F. Lake
=======

**题目:**

现在有$n \leq 1e5$个东西，每个大小为$a_i$，你能再这些东西上切$k \leq 1e9$刀，使得最大的加上次大的东西最小。

**题解:**

首先一个结论，每个东西都只会平均分。

考虑最后分出来的最大和次打的组成。

1.  如果最大的是原本的一个东西呗切了很多刀，那么次大的肯定和最大的一样大。

这个可以直接二分最大的大小，那么所有的东西都要小于等于二分出来的值，我们可以计算一个切的刀次数，和$k$比较即可

2.  如果最大的是原本一个东西，并且他们有被切过

假如我们把$a_i$排序，其中$a_1$最小，那么考虑$a_j$是我们切完之后，剩下的最大的没有被切过的物品。

如果其他还有物品切完还比$a_j$大，那么就变成第一种情况，这里不考虑。

现在考虑对于所有$k > j$，这些物品都至少被切过一次，并且现在已经小于等于$a[j]$。

我们找到一个满足上面条件最小的$j$，那么剩下的事情就是二分使得所有序号大于$j$的物品切完之后最大的值尽量少。

为什么我们只考虑这个$j$呢？首先比$j$小肯定不用考虑了，考虑$j$能否变得更大。

考虑$j + 1$这个位置，因为我们二分得到的是$j$,所以存在一个对所有大于$j$的物品的切割方案，使得他们的最大值小于等于$a[j]$，那么也就是说，我们考虑$a[j + 1]$作为没有碰过的最大值的时候，已经得到了一个对于$k > j + 1$的切割方案，使得所有的大小都小于等于$a[j - 1]$，而且本来要切的$a[j + 1]$也幸免于难，也就是说我们现在还剩了一刀没有切。

考虑这一刀我们应该切在什么地方，肯定是加在$a[j] or a[j - 1]$上，因为切在其他地方都不会减少答案，那么这说明$j + 1$不会是我们最优解的情况。同理可推得所有大于$j$的情况。

[Makoto Soejima Contest 3 F.cpp]()

J. Mixed Drinks
===============

**题意:**

现在有$n$个$(a_i, b_i, c_i)$,
并且每一维单独出来是一个排列。现在你可以取$n$个元素的一个非空子集$S$，设$f(S) = {max_{i \in S} a_i, max_{i \in S} b_i, max_{i \in S} c_i}$，问$f$函数有多少个不同的值。

**题解:**

每一个$f$的答案明显最多要三个元素即可。

考虑计算有多少个答案$(x, y, z)$至少需要3个元素才能凑出来。那么也就是说要求$x, y, z$分别来自不同的地方。

容斥这个，变成了求$x, y$来自一个地方，有多少方案，这个等价于求对于每一个$i$,
有多少$j$，满足$x_j < x_i, y_j < y_i$，同样的，也要求$x, y, z$来自一个地方，这个就是求对于每一个$i$,
有多少$j$，满足$x_j < x_i, y_j < y_i, z_j < z_i$。

这个都挺好求的，分治加树状数组集合轻松解决。

要注意的主要就是，每一维都是一个排列，不然会麻烦一点，但是一样可以算。

[Makoto Soejima Contest 3 J.cpp]()
