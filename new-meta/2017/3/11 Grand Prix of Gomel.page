B. Buggy Combination Lock
=========================

**题意：**

有一个长度为$n\leq 2e5$数字密码锁，每个位置是范围是$m\leq 1e9$。但是你在转动位置$i$的时候$i+1$会跟着动（动$n-1$的时候$0$会跟着动）。问转到目标状态的最少步数，或者无解。

**做法：**

设某个位置的转动状态是$x$，那么剩下位置都可以唯一确定。当$n$是奇数的时候，可以解方程解出来（注意可能有0/1/2个解）。$n$是偶数的时候，有时候$x$可能是任意值。这时候想要求总的最小步数。一个位置的转动状态可以表示成$\pm x+b$，这个位置的最小步数则是一个分段函数（有时候是$y$，有时候是$m-y$）。可以算出所有函数变化的时间点，维护答案的函数，算一算就可以了。

[B.cpp](Grand%20Prix%20of%20Gomel%20B.cpp)

C. Cyclic Shift
===============

**题意:**

给你一个串，求出所有前缀的最小表示法的起始位置。

串长小于等于100w。

**题解:**

对于一个串的lyndon decompostion而言，最小的special lydon
word就是它的最小表示法起始位置。

具体求法可以看代码，或者看论文《Optimal Canonization of All Substrings》

[Grand Prix of Gomel C.cpp]()

I. Inversions in Lexicographical Order
======================================

**题意: **

问你$1$到$n$的数, 字典序排列逆序对有多少个. $n<10^{250000}$.

**做法: **

枚举较大的数字,
再枚举和这个数字产生逆序对的较小的数字和他按字典序比较不一样的第一位,
再枚举较小那个数字的长度, 写出答案的表达式. 换序求和几次,
用FFT和前缀和做, 最后进一波位.

K. Keep Distance
================

**题意：**

给你一个长度为$n\leq 2.5e5$的小写字母串。对每种字符计算，把这种字母的下标弄成一个等差数列最少要多少次交换不同两个位置字符的操作。

**做法：**

枚举一种字母$c$，枚举一个公差$d$。最少交换，就是保留原位置最多。由于字母个数有限，所以这个等差数列有个长度限制。维护$d$个队列。从后往前枚举第一个在原位置的位置$i$，在队列$i\ mod\ d$中push\_front$i$，然后根据最长长度pop\_back。队列中的元素就是保留下来的个数，更新答案。

字母出现的次数如果是$x$，那么公差最多只能是$\frac{n}{x}$。所以总复杂度是$O(26n)$。

[K.cpp](Grand%20Prix%20of%20Gomel%20K.cpp)
