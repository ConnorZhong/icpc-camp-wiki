M. Sequence to Sequence
=======================

**题意:**

现在给定两个长度为$n \leq 1e5$的非负的序列$s, t$，你现在可以进行若干以下两种操作。

-   给一段数字加一，如果本身是0不变。

-   给一段数字减一，如果本身是0不变。

问把序列$s$变成$t$最少要多少步。

**题解:**

首先容易证明我们总是可以先只进行减操作，后进行加操作。

为了更好地说明，我们假设$a[i] = t[i] - s[i]$,那么我们相当于可以对$a$数组进行上述操作，目标是把$a$变成0。限制是对于每个位置$i$，有一个上界$u[i] \geq 0$。而对于那些$t[i] = 0$的位置，我们在$a[i]$变化的过程中曾经到达过0即可。

对称的，我们对$a$先进行加操作之后，使得$a$中的数字都至少为0，且都不能超过上界。那么之后的减操作我们可以认为那些$t[i] = 0$的数字删除，然后通过统计当前$a[i]$相邻的差的绝对值从而得到答案。

考虑贪心策略，我们当然希望尽快把所有元素都大于或等于0，也就是把全局都$+1$。但是为了后面收尾减操作不要做太多的无用功，也为了不要变得无解，我们需要满足下面两个要求。

-   只要满足每个元素都大于等于0的时候就要马上停止。

-   每个元素不能加的超过上界，如果一个元素再加的过程中到达了上界，我们应该从这个位置裂开为两个区间的子问题考虑。

-   对于两边的元素$a[l], a[r]$，考虑到收尾的时候我们要最小化相邻的差的绝对值之和，我们考虑$a[l - 1], a[r + 1]$，因为处理到这个地方，可以保证$a[l - 1], a[r + 1] \geq 0$，而如果$a[l] > a[l - 1]$，我们肯定得不偿失，所以当我们加到$a[l] = a[l - 1]$的时候，应该直接把$a[l]$抛弃掉。(注意由于最后算相邻差的时候我们没有考虑$t[i] = 0$的项，所以这里的$a[l - 1]$代表的是往左非$t = 0$的第一项)，$r$方向同理。

在上面3个限制下，我们每次选一个最小的$delta$进行全局加，并且及时更新$l, r$。

完成之后收尾即可。

[M.cpp](2017/04/29%20浙江省赛2017%20M.cpp)
