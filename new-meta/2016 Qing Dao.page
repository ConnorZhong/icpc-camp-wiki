E. Fibonacci
============

**题解:** 定义$x(n)=f(\ldots f(x(0))\ldots)$(共$n$层$f(\cdot)$),
其中$f$是斐波那契数列, $f(1)=f(2)=1$. 给定正整数$p\le 200000$,
问最小的正整数$n$, 使得$x(n)\equiv x(0) \pmod p$.

**做法:** 首先我们知道斐波那契数列$\pmod p$是有循环节的.
即$x(n)\bmod p$只和$x(n-1)\bmod \pi(p)$有关,
其中$\pi(p)$是$f\bmod p$的循环节长度. 这就支持我们反向递推.
但是我们不知道反向递推的公式, 而且反向递推的每一步也不一定唯一.
但是观察$\pi(p)$函数可以发现迭代$p\leftarrow \pi(p)$不超过$15$步后就会进入不动点,
且过程中$p\le 2000000$. 这就是说, 反向递推的边数不超过$15*200000$,
而这些边具体是什么可以处理出所有$p$值后正向递推得出.
所以直接BFS就做完了. 复杂度$15*2000000$.

[E.cpp](2016%20Qing%20Dao%20E)

M. Generator and Monitor
========================

**题解:**

直接KDtree 维护吧。。

[M.cpp](2016%20Qing%20Dao%20M)
