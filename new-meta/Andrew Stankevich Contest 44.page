A
=

**题意:**
平面上给你很多个点，每个点都有一个可能在的位置(一个等半径的圆)，现在问你最大的bounding
box有多大。

**题解:**
枚举最上面，最左边，最右边，最下面分别是哪些点，这些可以先处理出来每个方向的3个点，然后暴力枚举。

中间的形状因为是是一个凸函数，可以三分。

J. Judges Problem
=================

**题意:**

定义一个字符串$s[1\ldots n]$的覆盖数为最短的串$t$的长度,
使得对任意$1\le i\le n$,
均存在$le,ri$满足$s[le\ldots ri] = t$且$le\le i\le ri$.
现在给你$s[1\ldots i](1\le i\le n)$这$n$个字符串的覆盖数, 试构造串$s$,
或判断不存在这样的串$s$.

**题解:**

发现一个性质, 如果$s[1\ldots n]$的覆盖数是$k$,
那么$s$的前$k$个字符和后$k$个字符对应相等.
在此基础上我们考虑$s[1\ldots k]$的覆盖数. 这个覆盖数只能等于$k$,
否则由于$s$能被$s[1\ldots k]$覆盖,
那么$s$也能被覆盖$s[1\ldots k]$的串覆盖, 这就与覆盖数的最小性相矛盾了.
现在考虑$s[1\ldots k]$的覆盖数确实等于$k$,
并且$s$的前后$k$个字符已经对应相等的情况. 现在,
$s$的覆盖数也为$k$当且仅当$s[1\ldots n-1]\ldots s[1\ldots n-k]$这$k$个串中至少有一个覆盖数为$k$.(因为"当且仅当这些串至少有一个能被$s[1\ldots k]$覆盖"是显然的,
并且由之前的分析, 这种情况下就不可能被更短的串覆盖了).
发现除了字符对应相等, 我们所要求的性质都只和前面的前缀的覆盖数有关.
而字符对应相等又是必要的. 所以唯一可能解就是先假设每个字符互不相同,
再满足所有前缀所要求的字符对应相等条件所得到的那个串.
构造唯一可行解后验证即可.

构造唯一可行解的暴力复杂度是$n^2$乘以并查集的,
就是每次把$[i-cover(i)+1,i]$这个区间和相同长度的前缀对应连边.
我们可以做个优化, 当$s[1\ldots i]$的覆盖数为$i$时, 不需要修改并查集.
并且从后往前做, 如果当前的区间被后面的区间所包含,
那么也不必做(因为可以等到做以当前的区间为后缀的更短那个区间的时候再做).所以现在只有$s[1\ldots i]$的覆盖数$cover(i)$至少和$s[1\ldots (i+1)]$的覆盖数一样多的时候才会产生$cover(i)$的复杂度.
并且, 我们已经知道$cover(cover(i))=cover(i)$对所有的$i$都成立.
所以在有解的输入中, 应满足对所有的$i-cover(i)+1\le j\le i$,
只要$j-cover(j)\le i-cover(i)$, 就有$cover(j)>2(j-i+cover(i))$. 即,
每次产生复杂度都是区间$[i-cover(i)+1,i]$的右端点左移,
然后通过左移左端点使得区间长度加倍. 这就是说,
产生$t$的复杂度会导致左端点左移$t/2$. 所以并查集的总操作次数不超过$2n$.
只要超过$2n$返回无解即可.

最后如何验证呢? 只要对每个前缀记录它能覆盖到的最长的前缀,
便可按$i$从小到大维护$cover(i)$.

[code](ASC44J)
