A. Hacker Cups and Balls
========================

**题意: **

有个排列(大小100000), 再进行100000次操作,
每次是个区间sort或者反向sort(即sort+reverse). 问所有操作做完后,
中间那个元素是几(保证数组长度奇数).

**做法: **

二分答案, 每次变成$0,1$数组排序, 用线段树维护.

B. Bored Dreamoon
=================

**题意: **

有若干士兵站队(1000人), 从前往后(第一关键字),
从右往左(第二关键字)身高是递增的.
并且相邻两排的人数(左右方向的叫排)相差不超过1,
且前面的排大于等于后面的排的人数. 现在士兵们右对齐,
对于所有士兵中的$n$个, (1)给出了他们的高度, 各不相同;
(2)给出了其中选出任意两个不同的士兵$a$和$b$,
$a$是否在$b$的右前方(不严格的右前方)这一信息.
问是否合法以及第一排(最前面)最少有几个士兵(你可以任意在给出的士兵基础上增加士兵).

**做法: **

首先两个人之间要是互相不是右上关系, 可以根据身高判断谁在左上.
所以对于任意两个点我们能唯一确定4种关系中的一种.
两个方向分别做个差分约束.

C. Crazy Dreamoon
=================

**题意: **

有张方格纸, 上面有些线段.
现在问和线段严格有交(即截线段长度大于0)的方格的并集的大小. 范围都是2000.

**做法: **

随便做一下.

D. Forest Game
==============

**题意: **

有棵树(100000), 每次随机一个没删掉的点删掉,
得分为删掉前这个点所在连通块的大小. 问期望得分$\times n!$.

**做法: **

转换一下, 点$a$对删除点$b$的时候贡献1的得分的条件, 是$b$删除的时候,
$a$以及路径上的点都没删掉.
这个概率就是一个随机排列$b$出现在最前面的概率.
所以答案为$\sum_{a,b}\frac{1}{dis(a,b)}$, 随便做一下.

E
=

**题意: **

有两排点${0, 1}\times {1,\ldots, n}$. 现在有一个排列$p$,
$(0, i)$和$(1, p_i)$之间连有一条线段. 现在每条线段有一个删除所需的花费,
且删除一条线段同时免费删除与他相交的线段(并且那些线段因为也被删掉了,
以后就不能选择删除他们了). 问删除全部$n$条线段最少需要多少花费.

**做法: **

容易得出naiveDP做法: 将$(i,p_i)$画在平面上,
那么删除一条线段可以同时删除他右下和左上的线段.
那么用一条线段左下的"右上单调队列"上的DP值更新他自己的即可.

我们可以分治, 每次选择一条竖线分开, 先递归计算左边的点的DP值,
再计算左边的点的DP值对右边的点的DP值的更新, 最后递归右边.
那么怎样计算这个更新值呢?
首先我们要找到左边哪些点会尝试更新右边的某个点$a$.
这些点显然是$a$左下的点的"右上单调队列"中横坐标在分割线左边的点.
我们知道这个"右上单调队列"中横坐标超出分割线达到它的右侧的第一个点就是分割线右边的点中$a$下方点里最靠上的一个$a$左边的点,
设为点$b$.
所以我们此时只需考虑分割线左边的纵坐标在$a$和$b$之间的点(他们的"右上单调队列"就是$a$的DP值更新备选).
为了保证复杂度, 我们把右边的点按照纵坐标排序, 且维护一个横坐标递增的栈.
这个栈中的每个点都是后一个点的DP值更新备选,
并且后一个点的在分割线左边的备选的纵坐标都在这相邻两个点的纵坐标之间.
的当处理到$a$时, 会弹栈直到$b$.
这时把弹掉的点的备选都拿来尝试作为$a$的备选. 这时要用链表的数据结构,
就能合并若干"右上单调队列". 最后, 注意到我们需要这个链表中的最小值,
而链表只会进行弹出最左边元素和两个链表连接着两种操作,
所以我们只保留链表中DP值递增的一个子链表即可维护(即这里也是个单调队列).

[NLOG\^2N](gym101234E)

[NLOGN](gym101234ENLOGN)

F. Lonely Dreamoon 2
====================

**题意: **

给你$n$个数(200000), 让你排列一下,
使得相邻两个数的差的绝对值的最小值尽量大.

**做法: **

假设输入排序后为$a_0,\ldots,a_{n-1}$. 观察一下发现如果$n$是偶数,
答案为$a_{i+n/2}-a_i$的最小值. 如果是奇数,
答案为从这些$a_{i+n/2}-a_i$里选一个删掉, 剩下的最小值.

G. Dreamoon and NightMarket
===========================

**题意: **

给你$n$个数(100000个), 问你数字和第$k$大的非空子集.

**做法: **

老. 假设输入排序$a_0,\ldots,a_{n-1}$, 搞个堆, 每次取走后,
假设取走的方案中最大的选择的数是$a_i$,
就往堆中放入最大的$a_i$变成$a_{i+1}$的那种取法以及直接加入$a_{i+1}$的那种取法.

H. Split Game
=============

**题意: **

给一个简单多边形(100000),
问一条经过原点的直线能把多边形划分为最多多少个面积非0的部分.

**做法: **

扫一圈.

I. Tree Game
============

**题意: **

有棵树(100000),
每次操作可以选择两个未染色且树上的路径上的点也都未染色的叶子(一开始所有点都是未染色),
把他们和他们之间的路径上的点都染色. 如果能进行操作, 就一定要进行.
问适当的操作最少需要操作多少步.

**做法: **

一棵子树中的所有叶子要做到都无法操作, 这棵子树的根的父亲最多贡献1条路径,
剩下都要内部解决. 所以从下往上贪心, 有三种子树贪心结果,
第一种是所有叶子都内部解决了, 第二种是有一个叶子没有解决,
最后一种是有大于一个叶子没有解决, 但是父亲贡献1条路径过来的话,
就能全部解决了. 转移的时候, 第一种结果的儿子不用管,
第二种结果的儿子如果有至少3个, 那么必须找两个内部解决一下,
否则以后也管不了了, 第三种结果的儿子如果有两个就要内部解决一次.
这样最后会剩下第二种儿子不超过2个, 第三种不超过1个. 如果确实剩下了2个,
1个的话, 必须再内部解决一次变成1个, 0个. 最后, 如果剩余的儿子总量大于1,
或者剩余了至少一个第三种的儿子, 那么结果就是第三种,
否则结果为剩余的那一种(不剩的话, 结果为第一种).

J. Zero Game
============

**题意: **

一个长度为$n$的01串, 有$Q$个询问,
每次问你最多执行$a$次"取走一个数字并插入任意位置"的操作后,
最长连续0的长度最大是多少. $n\times Q\le 20000000$.

**做法: **

每个询问分开做. 首先答案肯定是删除一个区间以内的所有1,
然后余下的操作用来从区间外拿一些0过来. 枚举从哪里开始以后,
先假定所有操作都用来拿一个0过来,
即现在答案就是$a$(如果任何时候答案超过0的总量就和总量取min).
然后右端点往右扫, 遇到一个0答案加一(免费的), 遇到1答案减一(最多减a次).
这样转化以后就会做了.
