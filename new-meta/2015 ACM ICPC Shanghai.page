H.Happiness of Frog
===================

**题意：**
给你一个序列，现在你可以任意打乱他，要求使得它的回文子串尽量多。在保证这一点的情况下问有多少种方案。序列长度为$3000$，但是序列中不同元素个数只有$70$。

**题解：**
首先，如果要得到回文子串最多，必须是相同的字符放在一起，这样对于每两个相同字符，以他们为边界可以得到一个回文子串。而每一个回文子串必然边界两个点都是相同字母。这样一来我们可以发现这样一个构造自然可以得到上界。

为了得到这个上界，我们肯定希望对于每两个相同字符（这两个字符位置可以相同），以他们为边界可以得到一个回文串。我们来分别考虑每一个字符的放置方法。

对于一个个数大于等于3的字符$a$，那么这些字符中，要么是连在一起的，要么每两个相邻的字符之间恰好隔了一个相同的其他的字符$b$，成为$ababa$
or $ababab$ 形式。

那么进一步研究可以发现，这两种字符个数最多就差$1$。

而对于字符个数小于等于$2$的字符，情况有些特殊。字符个数为$1$的很简单，放哪里都行，只要不插在其他大的字符之间。对于$2$的情况要特殊处理。

因为字符个数为2的字符，不仅可以有上面说的组合方式，还可以直接套在某一个回文串的外面，还能进行多层叠套。

考虑$DP$,
$$f[v][remain][block][palind]$$代表我们现在做到字符个数为$v$的字符集合了，当前这个集合还剩下$remain$种字符，之前弄得字符总共形成了$block$个block，其中有$palind$个block是回文串。

其中，$block$包括$aaaaa$ or $ababa$ or
$ababab$这三种形式，其中前两个是回文串，最后一个不是回文串。

对于$v > 2$的转移的话，考虑有多少个是$aaaaa$，多少个是$aababab$，然后分配完内部的之后，剩下的都和少一个字符的集合组成block。

对于$v = 2$的情况，我们预处理$g[n][m]$代表我们有$n$个palindrome，然后有$m$个两个的字符，枚举每一个palindrome套几个就可以记忆化了。

总的来说，看起来麻烦，写起来还行。复杂度是$O(MAXV^4)$

[H.cpp](2016.11.2%20H.cpp)

C.Colorful Tree
===============

题意：子树刷颜色，子树查询不同颜色个数。

做法：加入一个modify就移除子树里所有modify（用set维护全部的dfs序）。然后找到modify该颜色最近的lca（用set维护某种颜色的dfs序），修改路径。转化为点修改，子树查询和，用树状数组。对于某个询问$u$需要特判改点的颜色是否出现在子树的modify里，未出现需要答案+1，这个用线段树维护。

[C.cpp](2016.11.2%20C.cpp)
