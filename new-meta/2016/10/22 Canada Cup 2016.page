E. Too Much Money
=================

**题意:**
现在你有$n \leq 1e5$元钱，并且有$m \leq 1e5$个各种面值的硬币。现在想凑出来$n$元钱，采用贪心策略，不断选取当前能选的最大面额的硬币。现在保证在当前状态下，采用贪心策略一定可以凑到刚好$n$元钱。问最少在里面加多少面额的一个硬币，可以使得贪心策略解体。

**题解:**
首先我们枚举加入一个什么面值的硬币。通过模拟贪心策略，我们知道我们这个面值的硬币必然是会被贪心取到的，首先通过简单预处理和二分可以知道贪心过程取到我放进去的这枚硬币后时，剩下还需要凑得钱。
随后我们继续二分到下一个必须要取得地方，在那个位置开始往下必然会取某个连续的一段，我们二分出这一段的长度。可以发现两个重要性质：

1.  我们当前剩下的要凑得钱至少减半。
2.  我们当前的钱必然小于我们二分出来的这一段左边那个硬币。

如果只使用第一个性质，我们不断这么二分，只会有$\log n 次迭代过程$，每次都是二分，所以得到一个复杂度为$O(n \log^2 n)$的算法。

如果加上第二个性质，可以发现我们接下来的迭代过程就是一个剩下的要凑得钱数，而不用再记录我现在贪心到了什么地方。这个部分我们可以直接记忆化搜索，使得总复杂度为
$O(n \log n)$。

G. Messages on a Tree
=====================

**题目大意:**
有一棵树。每次会在某个时刻从某个点开始，往根节点发送询问，到达根节点后立刻返回回答。一个点将询问信息发给父节点后会进入等待状态，直到收到回答信息。如果某个点在等待状态收到了来自孩子的询问信息，这个点会返回这个询问的回答。问每次在某个时刻某个点发送信息后，在什么时候会收到回答。

**做法:**因为题目中有要求，同时收到询问，会先处理起始点编号小的，所以所有事件按照起始点到根的时刻，编号双关键字排序。

如果我们知道了每个点结束等待的时刻e\[i\]（e\[0\]=INF），那么回答某个事件(t0,u)的节点是u到根的路径上，deep\[u\]-deep\[i\]+t0&lt;e\[i\]的最深的i。用树链剖分维护deep\[i\]+e\[i\]的最大值，对于路径上每条重链，先判有没有这样的点，如果有就在线段树上走一下找出这个点x。

然后我们要修改x到u上每个点i的结束时间为e\[i\]=tx+deep\[i\]-deep\[x\]。因为返回信息是自上而下的，所以deep越大，e也越大，所以线段树上一个区间的更新，可以直接用区间最深的点的值。

复杂度：每条重链开个线段树。查询枚举了重链，然后只会走一次，所以是$\log n$。修改每条重链只需要修改根结点，除了最上面一条要修改$\log n$个区间，所以也是$\log n$。写得不好好像$\log^2 n$也能过。
