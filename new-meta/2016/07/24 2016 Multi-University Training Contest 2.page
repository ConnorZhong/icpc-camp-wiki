H. Helter Skelter \[Akigeor\]
=============================

问题可以转化为1e6个矩形，每次询问一个点是否被矩形覆盖．扫描线树状数组，但是矩形拆成４个点会Ｔ，要拆成两条线段．
[code](2016/07/24%20H)

F. Fantasia \[Akigeor\]
=======================

点双连通分量缩点，然后是一棵树．如果被拆的点不是割点可以直接算，如果是割点，可以树形dp预处理子树积．
[code](2016/07/24%20F)

D. Differencia \[Akigeor\]
==========================

线段树节点内存b的有序表（归并树）．每次修改可以用二分直接算答案．

二分优化：只需要在根二分x一次．预处理前每个位置有多少来自左/右子树，x在左右子树的位置可以直接计算．
[code](2016/07/24%20D)

B. Born Slippy \[Akigeor\]
==========================

高8位和低8位分开计算。dfs时维护256\*256的二维数组f\[hi\]\[lo\]表示高位为hi的结点中在接收到低位为lo的更新后dp的最大值。修改只有一行，每次暴力备份就行了。
[code](2016/07/24%20B)

C. Call It What You Want \[Akigeor\]
====================================

最多只有5条非树边。暴力枚举是否经过，经过顺序，经过方向，之间的路径可以直接走树边（唯一），两头延伸：如果不连通，就是bfs最远距离，否则以某个端点为根再dfs一次，计算最深和次深深度，做树形dp。
[code](2016/07/24%20C)

G. Glorious Brilliance \[Akigeor\]
==================================

如果不是二分图则无解。枚举二分图左右和黑白的对应关系，两边不满足的点数必须一样，这些点两两连边权值是他们的距离，做km。

构方案：对于一条链a-&gt;b，找到第一个和a颜色不一样的点c，将a的颜色交换至c，递归子问题c-&gt;b。
[code](2016/07/24%20G)

J. Join The Future \[Akigeor\]
==============================

考虑前缀和。每个条件即给出两个前缀和的等价关系。枚举所有大小不为1的等价类（最多n/2个），之后dp方案数和最小字典序。
[code](2016/07/24%20J)

L. La Vie en rose \[Akigeor\]
=============================

dp\[i\]\[j\]=0/1表示s中第i位结束，t中第j位结束是否能匹配。dp\[i\]\[j\]可以从dp\[i-1\]\[j-1\]，dp\[i-2\]\[j-2\]转移。对j滚动，对i使用bitset优化。
[code](2016/07/24%20L)

M. Memento Mori \[Akigeor\]
===========================

按一维排序，枚举左端点，将所有在右边的点加入链表，逆序枚举右端点并不断在链表中删除。这样可以O(1)找出可能成为剩下两个点的点，暴力判断。
[code](2016/07/24%20M)
