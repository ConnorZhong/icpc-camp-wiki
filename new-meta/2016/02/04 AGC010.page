A. Addition
===========

**题意: **

有一坨数, 两个奇偶一样的数能合成成他们的和,
问能不能所有的数字最终合成一个.

**做法: **

当且仅当奇数有偶数个.

B. Boxes
========

**题意: **

有一个环上有$n$个位置, 初始每个位置都没有石子. 现在可以进行一种操作,
选择一个位置, 顺时针每个位置一次加入$1,2,\ldots,n$个石子. 给你最终结果,
问你是不是可能的.

**做法: **

相邻做差就能解出这个位置进行了几次操作. 验证.

C. Cleaning
===========

**题意: **

有一棵树上每个点一开始都没有石子. 现在可以进行一种操作,
选择不同的两个叶子, 将他们和他们的路径上的点都放入一个石子.
给你最终结果, 问你是不是可能的.

**做法: **

随便选一个不是叶子的根, 从下往上做. 叶子有几个石子,
就必须进行这么多次操作. 按照从下往上线头连接的方式考虑问题,
一个点下面两个线头可以在此连接,
那么这个点石子+1(前提是两个线头来自不同的儿子), 或者一个线头继续往上,
这个点石子+1. 所以根据这个点最终的石子数, 可以解出需要几对线头在此连接.
验证能选出这么多对, 并且最后根不剩余线头即可.

[code](AGC010C)

D. Decrementing
===============

**题意: **

有一坨数字100000个. 每次可以选择一个大于1的数字减1,
但是减了以后所有的数字除以他们的gcd. 保证一开始gcd是1. 问先后手谁赢.

**做法: **

假如有奇数个偶数(注意gcd时刻都等于1, 所以不能都是偶数), 先手赢.
因为先手只要随便选一个偶数减1, 就算除以某个gcd,
得到的结果也一定有偶数个偶数, 并且有至少两个奇数,
后面会证明这种情况是先手输的. 假如有偶数个偶数, 至少两个奇数,
那么先手无论怎样都只能把局面变成奇数个偶数, 所以输. 最后,
假如偶数个偶数且只有一个奇数, 那么先手变偶数就输了, 只能变奇数,
变了以后递归考虑.

[code](AGC010D)

E. Rearranging
==============

**题意: **

有一坨数字2000个. 先手可以任意排列,
但是后手可以任意次交换任意两个相邻的互质的数.
先手的目的是最终序列字典序最小, 后手目的是最终序列字典序最大.
问两个人足够聪明的结果.

**做法: **

两个数字如果不互质就连一条边. 不同的联通块之间是任由后手摆布的,
即他可以关于每个联通块生成的序列做个merge sort. 现在考虑一个联通块.
这个联通块可以让他里面最小的数字放在最前面.
因为如果我们以这个最小的数字做个dfs序(dfs树),
就可以保证后面的数字要么和这个最小的数字不互质,
要么和中间某个数字不互质了. 然后我们强制这个最小的在最前面,
相当于他在图中删掉了, 又要递归分成多个联通块做.
这些小联通块必须选一个和固定元素不互质的放在最前面. 所以我们dfs的时候,
从这个最小元素开始, 并且每个点都从小到大遍历邻边, 这样我们删掉了根以后,
每个联通块就是一颗子树,
且每个这样的子树就选择那个子树的根放在最前面就好了, 这样就完美递归了.

[code](AGC010E)

F. Tree Game
============

**题意: **

有一棵树, 每个点上有石子. 从某个位置开始, 轮流从当前位置拿走一个石子,
再选择一个相邻位置置为当前位置. 当前位置没东西拿的输.
问所有的初始位置的胜负情况.

**做法: **

假如只有两个点一条边. 那么开始位置的石子数如果不超过相邻位置的石子数,
就输了. 如果是个菊花, 中心的棋子数不超过周围每一个点的石子数, 也输了.
假如你非要移动到一个个数大于等于你的点上, 对手可以选择回来,
那你这一步就浪费了. 所以你只能去比你严格小的点. 这样做个DAG,
没出度的点输, 剩下的点按照可能的转移做就好了.

[code](AGC010F)
