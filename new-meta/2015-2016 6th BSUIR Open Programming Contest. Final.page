B. Variety
==========

**题目描述:**

现在给你一个$n*n, n \leq 1000$的棋盘，每个格子随机染了$1 - k$里面的颜色。

给你现在棋盘的样子。然后随机选择一个矩形，问期望里面有多少个不同的颜色。

**题解:**

考虑对每个颜色分开考虑。定义两个格子的大小关系先比较行，在比较列。

对某一个颜色c，我们把这个颜色的点排序。

考虑我们怎么把包含这种颜色的矩形分类。

我们开始枚举每一个点$(r, c)$，对于每一个我们枚举到的点，我们统计**有多少个矩形，我们枚举到的点是这个矩形里面坐标最小的点**。

设想这样的矩形的样子，我们的矩形下边界有$n - r + 1$种可能，这个一定，所以我们不用care坐标比$r, c$还大的点。

观察左右上边界的情况，我们把这个位置往上的部分划分成两个部分，分别是左半边和右半边。这两个部分里面我们不能碰到任何同颜色的点。那么把可行区域画出来其实就是包含当前这个点的，由比当前点小的当前颜色点构成的一个最大空正交凸包。

由于我们必须要包含当前点，所以你真的要做的话，需要维护出来右半部分的右凸壳和左半部分的左凸壳。

并且，如果有两个点在同一列，那么在上面的肯定不会存在于以后的凸包里面，所以我们直接删掉，后面不考虑这种情况。

直觉上来看，由于随机的原因，这个凸包上的点数之和肯定不多。如果我们能高效的维护两个凸包，每次都只扫这上面的点，那我们其实就能算答案了。

考虑这个凸包是怎么形成的。不失一般性，我们观察右凸壳上的一个点$(r_1, c_1)$，他之后的一个点$(r_2, c_2)$应该满足**$c_2 > c_1, r_2 >= r_1$**且$c_2 - c_1$的值应该尽量小。维护凸包的一个方法是用指针，考虑我们把左右凸包分开维护，每个点维护两个指针，为$next, prev$，沿着指针走，我们就能得到我们想要的凸包。

现在考虑加入一个点$(r, c)$，他的凸包怎么求出来。我们可以找到列最靠近当前点的两个点$(left_r, left_c), (right_r, right_c)$。对于左边的，我们沿着$prev$指针走即可，右边类似。

现在考虑加入一个坐标最大的点，这些指针会怎么改变。考虑我们在上面走得时候，对于右凸壳上的每个点，$prev$指向当前点，左凸壳上的每个点，$next$指向当前点。就好了！

但是有很多情况需要想清楚。第一个就是相同行的元素需不需要连接指针。如果你只是求答案，的确看上去不用。但是你要维护的话，就需要了。

然后就是复杂度的问题。我大概算了一下，这个的复杂度的期望大概是计算每个点的右凸包上的点的个数。

``` {.cpp}
    int n, k;
    scanf("%d %d", &n, &k);
    double ans = 0;
    for (int r = 2; r <= n; r++) {
        for (int c = 1; c <= n; c++) {
            ans += pow((k - 1.) / k, (r - 1) * c) / (k - 1) * (n - r + 1) * (n - c + 1);
        }
    }
    cout << ans << endl;
```

经过我的验算，$n = 1000$时，答案大概还是100w级别。不管k是多少，都不会过$1000w$大关。

如果聪明的你知道到底怎么估算出这个复杂度，请联系我！

这个题目的实现可以直接用set。足以过了。

**题解二:**（叉姐友情赞助）

我们补集转换，先枚举一个颜色$c$，再枚举某一行，问以这一行为下边界的矩形中，有多少个矩形不包含颜色$c$。

设我们有一个数组$a[i]$，代表第$i$列上，往上走多少步可以遇到一个颜色$c$的格子。那么我们这一行的贡献其实就是$\sum_{L \leq R} min(a[L..R])$。

考虑把这个数组建立成一个笛卡尔树，由于数据的随机，我们可以发现这个树的高度就$\log n$级别。答案很容易计算。

那么我们现在的操作无非就是把一个位置的值弄成0，或者全体$+1$。后者很好维护（因为就是定值）。前者的话，我认为可以split，叉姐认为可以直接rotate上来就好。反正树高摆在这里，怎么玩都行。

然后就没有然后了。唯一需要注意的地方在于一开始$a[i]$都是等于0的，这里需要自己调整一下，把树高做成$\log$级别。后面的感觉怎么弄都不会出事的样子。

[B.cpp](2015-2016%206th%20BSUIR%20Open%20Programming%20Contest.%20Final%20B.cpp)

F. Cactus
=========

**题目描述:**

给你一个点仙人掌（一个点最多在一个环里），$n\leq 10^5$，砍掉一些边，使得剩下的图，每个连通块边数不超过2，求方案数$mod 10^9+7$。

**题解:**

类似树形dp。先把图处理好。每次处理一个点或一个环。$dfs[x][up]$表示$x$这个点/所在的环，从上面伸下来那条边所在的连通块一共$up$条边。

如果是点，那么子树可以继续伸下去$down=0，1，2$条边，这个也用dp，$f[i][0/1/2]$，表示做到第$i$个孩子，已经伸下去几条边了的方案数，算上$up$保持合法就行了。

如果是环，就先枚举环上最后一条边$las$所处连通块的边数情况$0/1/2$，然后再dp一圈，$g[i][pre=0/1/2]$，表示做到第$i$个孩子，他上一条边上一共连着几条边，最开始那个点的上一条边是$up+las$，每次枚举环上下一条边$new$有没有，然后再枚举他的孩子连了$down=0/1/2$条边，$pre+new$可以当作$up$用上面那种点情况递归往下算一下更新$g$，最后只要取$g[][las]$的答案就行了。

[F.cpp](2015-2016%206th%20BSUIR%20Open%20Programming%20Contest.%20Final%20F.cpp)

J. Cherry orchard
=================

**题意: ** 有一块正方形的地, 上面有若干棵樱桃树.
现在哥哥先在边界上等概率随机选择一个点,
弟弟再在和哥哥不同的一条边(即剩下3条边)上独立等概率随机选择一个点.
两个点连线将樱桃树分为两部分, 弟弟拿到少的那部分.
问弟弟期望拿到多少樱桃树.

**做法: ** 樱桃树和正方形的角两两连线和正方形有若干交点. 每两个交点之间,
樱桃树的极角序不变. 在这个区间内做个积分.

[J.cpp](2015-2016%206th%20BSUIR%20Open%20Programming%20Contest.%20Final%20J.cpp)
