C. Guess The Number
===================

**题意:** 这是一个交互题。

现在要你在$[1 \cdots n], n \leq 1e9$中猜一个数字，你可以询问若干次，每次询问是问你要猜的数字是否小于某个数字$x$。

现在有$k = 10000$个数字要你猜，你询问次数不能超过$k(\log(n+1) + 0.1)$.

你可以认为电脑很聪明，会根据之前你的询问次数来选取秘密数字。

**吐槽题解:**
最蠢的直接二分询问宣告破产，因为要求很严格，如果你的算法是确定算法，很遗憾，不可能会对的。

那么问题是怎么随机来迷惑他的恶意程序。

一个愚蠢的想法是，如果当前$n$是偶数，我们肯定折半，否则奇数我们可以二分的位置有两个，可不可以随即一下这两个位置呢？

只能说，你要继续这么想根本毫无希望，随便算一下这个期望，比$\log(n+1)+0.1$几乎大1。

**真正的题解**

所以我们需要观察随机的本质是什么。我们最好能达到一个什么样的期望？

想象一下最后这个的搜索树，肯定是有$a$个点在$\lfloor \log n\rfloor$，$b$个点在$\lfloor \log n \rfloor + 1$位置，我们只要这$a, b$个点位置尽量随机就已经是极限了。

虽然这么做过这个限制是绰绰有余，但是这么做有两个问题。

-   怎么随机这些点，可以发现你不能直接random这$a, b$个数字，因为可能你弄出来的根本不是一个合法的搜索树。

-   $n$是$1e9$啊，真的随机直接超时。

这时候我们可以想到概率论课上说的，相对独立概念。我们要做到的是什么？这$a, b$个点的选择和$x$(我们要猜的答案)相对独立就可以了！所以不需要直接随机$a, b$那么"绝对"的独立性质。

我们可以直接随机一个$p \in [1 .. n]$，那么我们的$b$就是$[p .. p + b]$，超过的部分我们就从头取。很容易证明这样就是相对独立了。

那么接下来还有一堆trick，比如怎么保证随机后，对应的搜索树是合法的？

我们该怎么在二分的基础上建立这个搜索树？

这个其实就是为什么要求的是$\log(n+1)$而不是$\log(n)$了，可以想象一下$n = 3$，如果他一直要你猜2，你是不是就GG了？

最后的期望其实就是$\log(n+1)$，详细看代码了，我中间还加了一个二分。但其实可以省掉，但是要更麻烦的讨论。

[code](Prime Contest C.cpp)

D. Path Selection
=================

**题意:** 给你一个有向图，每条边有个字符$p$,权值$w$。现在有$q$个操作。

-   1.  修改一条边的权值。
-   2.  询问从一个点开始走的字典序第$k \leq 1e12$大路径的权值和。

图点数$10w$，边数$100w$，操作数$10w$。

**题解:**

DAG，无修改版本就是GRE WORDS，用带合并的可持久化treap即可做到。

这个题目的话，考虑到它不会修改一条边的优先级，也就是说从任意点开始的路径字典序顺序不变。

由于询问中$k \leq 1e12$，我们可以使用倍增技巧。

虽然不是个DAG，但是我们还是可以算出从每个点开始的路径条数。（可以tarjan缩完之后，对于每个边数大于等于1的块，里面的方案数就都是INF）。

然后对于每个点，把出边按照优先级排序，当某个前缀的方案数超过了$INF = 1e12$就不管后面的边了（因为没用了）。

然后取那个走完之后，方案数最多的边当做重边。

如果我们有一个询问是从某个点开始走$k$步，那么肯定是走一段重边，一条轻边...,
而且这个交替过程不超过$\log 1e12$。

因为你每走一次轻边$(u, v)$，其实相当于你当前的$k \leq ways[v] \leq ways[u] / 2$。容易得证。

那么这一段重边多长呢，会走到哪里呢？倍增即可。

那么还有一个问题，这一段的权值是多少呢？能支持修改么？

当然能！因为只看重边的话，这不就是一个环加外向树么！如果没有环，不就是问从树上一个点往祖先走若干步的代价么，dfs序很容易就能维护询问加修改了。

有了环的话，其实我们只要把环上一条边拆了变成树，那一条边特殊判断一下。还有考虑在环上绕多少圈的问题，就能做出来了！

[code](Prime Contest D.cpp)

[code2](Prime Contest D2.cpp)

E. Distanced Strings
====================

**题意:**

现在要求你构造$n$个串，每个串都是由前$k$个小写字母组成。且对于每两个串，他们相同的位置个数相同。

假设每个串长度为$L$，要求$L \leq 2n and s \leq \frac{2L}{k+2}$。其中$s$是两个串相同的位置个数。

**题解:**

[Sol](/PrimeContestSolutionForE)

为什么正确？
为了避免符号问题，把题解里面的$n$换成$t$。题解中的$p$选择范围应该是$\frac{k+2}{2} - k$。

我们的$t$选择应该是最小的$t$，使得$p^t \geq n$。

首先我们的串长是$L = 1 + p^1 + p^2 + ... + p^{t-1}$。而我们的$n > p^{t-1}$。

所以我们有$L = \frac{p^t - 1}{p - 1} \leq 2\frac{p^t}{p} = 2p^{t-1} < 2n$，所以这个条件自然是可以满足的。

同时$s = 1 + p^1 + ... + p^{t-2} = \frac{p^{t-1} - 1}{p - 1} < \frac{1}{p}\frac{p^t - 1}{p - 1} = \frac{1}{p}L \leq \frac{2L}{k+2}$

所以是可以满足的。

那么为什么大家相同的个数都是$s$呢？

大概可以算一下，两个串长度为$L$的话，刚好差为$0 \leq x < p$的位置恰好都是$\lfloor \frac{L}{p} \rfloor$，还有其中一个多了一个。

归纳下就好。

F. Edit
=======

**题意:**

现在给你两个由小写字母组成的，长度相同的串，现在要求从第一个串变化到第二个串，你可以使用两个操作

-   修改某一个位置的字符，耗费1的时间。

-   把一种字符全部变成另外一种字符。耗费常数c的时间。

问最少代价。

**题解:**

首先一个简单的观察就可以发现，第一种操作我们最后再做，先做第二种操作。其次，这个字符串长度其实我们没必要care，因为我们只需要一个$26*26$的数组$table[a][b]$代表我们有多少个位置是$a$字符要变成$b$字符。

由于第二种操作十分复杂，如果我们再考虑每个操作的先后顺序，肯定无法下手。

换一种思路，假如我们知道了最后的结果，我们怎么用第二种操作来达到这个结果。

结果该怎么描述呢？我们建立一个映射$go[a]$代表一开始为$a$的字符最后变成了$b$。

这样的描述首先是足够了，因为一开始字符一样的位置在最后实行第一种操作之前都是绑定在一起的。其次，有了这个信息，我们直接就可以知道第一种操作的耗费时间。

考虑对于一组$go$，我们怎么计算第二种操作带来的代价。

把每个字符看成一个点，go看成出边，那么这就是一个环加外向树模型。一个明显的lower
bound是这个图的边个数。考虑如果只是树，这个lower bound肯定可以达到。

但是一个单环的话，只有边数那么多的操作肯定不够。考虑加1个，如果有一个字符空闲的，我们只要多一步就好了，所以这肯定就是最优的了。一个字符空闲当且仅当他在这个图里面入度为0，且不是孤点。

如果是环+外向树呢？可以发现的确只要边数那么多的操作就够了，可以自己思考一下（使用外向树上的叶子）。

但是我们需要注意一个严重问题，就是单环情况，假如没有字符空闲出来给我们用的话，这样的图就是不可能的。因为一次第二个操作肯定就把两个字符merge起来了，以后也没法分开了。

那么到了这一步，我们成功把问题简化了一步：现在给你26个点，要求你给每个点加一个出边或者没有，使得最后每个出边的权值（没有出边就是0）+
单环的数量\*c权值最小。并且保证这个图不是由单环与孤点组成的。

下面就是厉害的地方了。

我们首先贪心选每个点的出边（可能是自己，那样的话就不用+c，这一步不考虑最后单环的数量的贡献）。可以得到图$G$。这个图有可能是不合法的图（只有单环与孤点）。

我们把我们上面的问题放缩：现在还是给你26个点，要求你给每个点加一个出边或者没有，使得最后每个出边的权值（没有出边就是0）+
在$G$中出现过的环并且在这个图里面是单环的数量\*c的权值最小。注意在这个问题里面我们不用保证新的图不是仅仅由单环与孤点组成的了。但是多了一个附加的小条件，如果$G$是不合法的图，我们这个问题求出来的图不能和$G$一样。

新问题的答案就是我们最终所要的答案。先说新问题怎么dp做。

我们按顺序逐个确定每个点的出边，最后附加的小条件可以很容易解决。而$G$中的环最多就$26 / 2 = 13$个，我们用mask码记录一下每个环是不是被『破坏了』。可以发现这样的dp是$O(2^{13}*26^2)$。

为什么这样是对的呢？可以发现唯一一个可能出错的地方在于我们新问题构造出来的图中可能有在$G$中没出现过的环，而且在新图中是单环。

考虑这个单环里面，肯定有一个点的出边在$G$与新图中不一样。我们考虑把新图中这个点的出边换成$G$中的出边。首先这个新的环被我们拆解了，其次不会有新的环产生，而且因为$G$是我们贪心得到的局部最优解，边权肯定也不会变大。于是我们得到了一个单环个数严格减少，而权值没有变化的满足新图条件的解。

这样一来这个问题就解决了。

[code](Prime Contest F.cpp)

I. Catch Me If You Can
======================

**题意:**

这是一个交互题。

现在平面上有3个同心圆，半径分别为$r, 2r, 3r$，但你并不知道圆的具体位置，而不知道$r$。你一开始在$(0, 0)$这个点，而你的目标是走到圆心。

我们称你在$xr$圆内，当且仅当你距离圆心为$(x-1)r - xr$。

现在你每次可以说一个你要走的方向并往这个方向走，在下面几个情况下你会停下来:

-   你走到某个圆的边界

-   你走这一步会使得你走到更大的圆里面去。

-   你经过了圆心

std会返回你你沿着这个方向走了多长才停下来，并且会告诉你你现在停在哪个圆的圆周上（如果到了圆心就直接结束）。

现在你只能走5次，并且第5次的时候，你会直接往前冲，不再理会圆的边界。如果在这个过程中你碰到了圆心也算你赢。

**题解:**

这个题目需要分众多情况讨论的能力+计算几何拼拼凑凑的能力+交互过程实现（意味着你又要写好多计算几何函数）+一点小聪明。

首先你可以发现，第一步我们无法避免，有$1/2$的概率『撞墙』。因为这个概率实在不小，我们可以认为第一步就认栽了，浪费一步。

假如

-   第一步撞墙了，第二步我们扭头走。继续撞墙？好我们知道终点所在的直线了，也就是两个方向。我们先试一个方向，如果还是直接撞墙，那么肯定是另外一个方向。如果没有直接撞墙，那也很好，说明就是这个方向了。

以下情况我们认为第一步没有撞墙，并且只剩下4步。

-   第一步走到了第三层。加上一开始$(0, 0)$在第三层，现在我们在同一层上有了两个点，可以使用一点小聪明。因为我们知道如果在同一个圆上我们知道了三个点，那么圆心我们直接可以算出来。所以我们扭头偏一点角度，可以确定我们又到了第三层，直接算答案，OK。

-   第一步到了第二层，第二步原方向走撞墙？？聪明的你再多写个10行把它特判了吧。

-   第一步走到第二层，第二步原方向还是走到第二层。还记得上面的小聪明么？用上吧。。刚好5步。

-   第一步走到第二层，第二步走到了第一层。好，现在我们三层三个点，我们还知道圆心到这三个点的距离比例。召唤出来阿波罗尼斯圆，两个圆一交，两个点。由于我们都到了第一层了，还能走两步，试试吧。

然后完毕。

注意事项：

初始方向最好随机，因为这个题目随便想就是精度误差上天，中间算的过程中很容易出nan(负数开根，非定义域内解acos函数等等)，随机的话，可以少很多特殊情况，比如总是撞墙的问题。

尽量写个点到最近圆的距离函数，不然头硬直接交的结果是judge也头硬一直让你WA。

[code](Prime Contest I.cpp)

31
==

**题意:** 有一个可旋转的六角星魔法阵. 给你一个点集,
问是否能旋转魔法阵覆盖这个点集的凸包.

**做法:** 经过简化后, 可覆盖的条件是点集的每个点在圆周上有个存活区间,
六角星的六个内点也在圆周上有个存活区间, 都能通过直线和圆求交求出来.
特殊情况是六角星的内点和凸包没有交点,
但是凸包包含了六角星内点导致存活区间其实是空.

[code](Prime Contest 31.cpp)
