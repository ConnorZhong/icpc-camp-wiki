To Round 14

### UR \#14 人类补完计划

**题意:**

现在给你一个无向图，$n \leq 16$个点，$m$条边，现在要求你对每一个基环外向树$T$，把答案加上2的
这个基环外向树中非叶子的个数 次方。求答案。

**题解:**

这道题想通过，需要最多恰好$3^n$算法，多一个$n$都会导致TLE。

可以发现，这个$2^{非叶子个数}$这个权值形式，有很多方法可以解决，比如限定一棵基环外向树后，给一棵树黑白染色，统计方案数。

但是，无论你怎么算，都避不开一个问题，就是如何计算基环外向树的个数。

考虑一个暴力做法，就是首先我们枚举一个集合，假设这个集合就是我们的环，那么我们可以把这些点缩成一个点，然后再枚举我们最后的奇环外向树，apply一个matrix
tree算法，复杂度为$O(3^n n^3)$。

那么接下来就是我们如何优化这个算法。

**方法一：**

考虑对一个集合$V$，我们的基环外向树方案数是多少。一个简单的想法就是他们的出度的乘积！

看上去挺对的，但是因为这个图是无向图，有可能产生环的退化情况，比如变成一棵树。我们减去树的方案数即可。这个可以用matrix
tree算法，总复杂度为$O(2^n * n^3)$。

**方法二：**

这个方法要麻烦的多，但是我觉得还是很有趣。

考虑我们先枚举一个集合$V$，现在考虑算$V$的答案$cnt(V)$。

我们希望算出来数组$g(S), S \in V$代表$V$作为一个基环外向树，而$S$作为所有的叶子，的方案数。这个我们显然现在还不好算，但是我们有方程

$$ cnt(V) = Circle_V + \sum_{S \in V} g(S)$$

其中$Circle_V$代表V这个点集组成一个环的方案数。

我们能算什么？

$$h(S) = cnt(V - S)W(S, V - S)$$

其中$W(A, B)$代表我们对于$B$里面每一个点，都选择$A$中一个点作为父亲的方案数。

那么$h(S)$的意思就是，在所有的基环外向树用到的点集为$V$的情况下，$S$是叶子的一个子集的方案数。

可以发现$h(S)$与$g(S)$的关系。

$$h(S) = \sum_{S \in S'} g(S')$$

使用反演，可得

$$cnt(V) = Circle_V + \sum_{S \in V} g(S) = Circle_V + \sum_{S \in V} \sum_{S \in S' \in V} h(S) * (-1)^{|S' - S|} = Circle_V + \sum_{S \in V} cnt(S) * W(S, V - S) * -(-1)^{|V - S|}$$

这个可以直接dfs算。于是这个部分就可以做到$O(3^n)$了。

那么算出来了$cnt(V)$，我们怎么算答案呢？

那么再一次使用反演。考虑$ans(V)$代表$V$这个点集的答案，我们设$fake(V)$代表一个『假答案』，具体来说，他对于每一个$T$算的贡献是$2^{|T|}$。这个很好用$cnt(V)$计算出来。

那么$fake$与$ans$的关系是什么呢？

$$ans(V) = \sum_{S \in V} fake(S) * W(S, V - S) * (-1)^{|V - S|}$$

其实就是一个容斥，考虑把每个点颜色染成黑白，但我们不能给叶子染成黑色，考虑时间$v$表示$v$这个点是叶子，而且我们还把它涂成黑色的事件。

[UOJ UR14 B](B.cpp)

### UR \#12 a\^-1 + b problem

**题意:**

现在给你$n \leq 10w$个数字$a_i$，现在对这些数字在$MOD 998244353$(一个质数)下有$m \leq 6w$次操作，第$i$次操作有两种可能的方式：

-   每个数字加等于$x_i$。

-   每个数字取逆。

每次操作之后输出所有数字的和。

**题解:**

首先这个题目的操作十分有意思，都是对全部数字在做，那么可以想象得到算法肯定是要基于这个的。

考虑一个数字$a_i$在若干操作之后会变成什么样子。

可以发现，肯定是这样的形式$\frac{ka_i + b}{ta_i + c}$。

换个形式，其实就是$e + f \times \frac{1}{a_i + k}$。

那么也就是说，我们只要可以算出来$\sum \frac{1}{a_i + k}$即可。

这个很难算，但是题解里面给了我们一个好算的形式:

$$\sum \frac{1}{a_i + k} = \frac{\sum \Pi_{j \neq i} (a_j + k)}{\Pi (a_i + k)}$$

很明显，这个式子可以拆成前后两个式子来算。对于后者，$a_i$是常数，也就是我们需要知道$f(x) = \Pi (a_i + x)$即可。

这个可以插值或者分治FFT算出来多项式，然后使用FFT多点求值方法算出来。

而对于前者，可以发现时后者的导数。。easy了。

### UR \#6 懒癌

**题意:**

现在有$2^{n}$个村庄，每个村庄有$n$个人，每个村庄恰好对应了一个每个人是否生病的一个configuration（每个村庄都至少有一个人生病）。

对于每个村庄，我们知道每个人$i$是否能知道$j$的健康情况（恰好每个村庄的这种知晓关系是一样的）。但是他们之间不会互相透露他们知道的其他人的健康情况，但是每个人都知道这个图长成了什么样子。

现在有一个外来人到达每个村庄，告诉大家这个村庄有人生病了。

现在一个猜疑链开始了。如果第$i$天，某一个人通过之前的推理知道了自己得了病，就会在一天中的下午6点开枪自杀。且如果一个村庄有人开枪自杀，大家就会停止猜疑，剩下的人继续幸福生活。现在题目问:

-   每个村庄开枪自杀的时间和。

-   每个村庄死掉的人的和。

注意，可能这个猜疑链永远不会结束。

$n \leq 1000$。

**题解:**

不得不说这个题目着实有趣。。出题人的脑洞真的大。

首先这个问题的特殊情况就是每个人都完全掌握别人的健康信息。这样的话，如果有$k$个人生病，那么在第$k$天，这$k$个人会同时自杀。

但是现在这个图是残缺的，那么我们是通过怎么样的推理来推断自己的健康情况呢?

注意到一个有趣的问题，我们在什么情况下会认为自己得病了？当且仅当自己不得病的可能性消失的时候。我们考虑一个configuration，假设集合$V$里面的人得病了，我们设$f(V)$代表在这个情况下，第一次开枪的时间。对于$i$这个人来说，他会枚举所有的，自己没得病情况下的configuration。如果当前的天数大于可能的configuration下的天数的话，他马上就回去自杀。

可以观察到如果第$i$个人得病了，那么他可能的开枪时间和到底哪些人得病了无关。我们可以设$g(i)$为第$i$个人的开枪时间，可以得到两种转移。

-   第一种是$g(i) = max_{V} f(V) + 1$，其中$V$要和实际情况相符合(即$V$是
    $i$能看到的并且真的生病的人 与 $i$不知道的人里面的一个子集的人
    的并)。

-   第二种是$f(V) = min_{i \in V}g(i)$，这个很容易理解，这个集合里面有人开枪了就结束了。

如果这个转移没有环，我们显然可以有一个底数不大的指数级算法$O(2^n \times n) ~ O(4^n \times n)$。而如果一个config在环里面，可以想象肯定就是推理不出来了。

但是这个$n$太大了，如果我们真的要算$f(V)$肯定没法摆脱指数的厄运。按道理我们接下来需要直接考虑一下$g(i)$到$g(j)$的转移，但是在这个题目里面我们还是考虑$f(V)$到$f(S)$之间的转移比较好。

首先我们建立一个新图$G$，如果$i$不知道$j$的健康情况，那么我们从$i$到$j$连一条有向边。设$N(i)$代表$i$的出边到达的点集合，$Sub(V)$代表$V$的子集。

考虑转移$$f(V) = min_{i \in V}g(i) = min_{i \in V} max_{S = Sub(N(i))} f((V \cup S) 去掉i) + 1$$。

其实这个就相当于我们一开始有一个点集被染成了黑色，然后我们转移是把一个黑色的染白，并且把这个染白的点的某一个后继的子集染黑。

首先，如果我们知道了把谁染白，那么后继的选择是需要选个尽量大的，那么显然我们肯定都选，因为通过couple的方式，多了一个黑点不会让答案变小。

所以我们的转移变成了$$f(V) = min_{i \in V}g(i) = min_{i \in V} f(V \cup N(i) 去掉i) + 1$$

小小观察一下，如果$V$里面有点在一个大于一个点的强连通分量里面，我们可得没法在有限步结束，所以我们可以直接把那些导致无限的点直接删了，那么剩下的就是一个DAG。

考虑到我们在转移的过程中，$V$不断变化，为$V_1, V_2, V_3$，为了最小，我们每次选择的$i$必然不能相同（因为是DAG，我们可以把它弄小）。自己脑补下就知道，这个其实就是问$V$这个点集在$G$上直接和间接后继的个数。

我们直接考虑每个点的贡献，其实就只要算出来有多少个点到达点$i$。假如有$c$个点能到达$i$，那么贡献就是$(2^i - 1)2^{n-i}$，其中$n$为我们删掉那些无限点后，剩下的点的个数。

最后一个问题就是，我们还要算有多少人死掉了。

考虑一个人什么时候会在这个configuration里面第一批自杀。首先肯定需要这个config里面有他，其次我们第一步可以选择他进行dp扩展而不会使得这个答案变大。

换句话来说，这个config里面，$i$是唯一一个能到$i$的点。

那么答案也很容易算了。。直接压位$O(\frac{n^3}{64})$。
