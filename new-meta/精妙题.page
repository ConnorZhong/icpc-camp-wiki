### SwappingParentheses \[TCO 2016 FINAL 500\]

**题意:**
给你一个"balanced"括号序列，现在有$n$个操作，每个操作是交换位置$p_i, p_i + 1$，你要按顺序执行这些操作，但你可以跳过任意操作。现在问你，最后的括号序列中，有多少的不同的，且依然"balanced"括号序列。

**题解:**
首先两个括号序列相等，当且仅当他们的前缀和数组相等。首先我们来观察什么样的括号序列能被我们制造出来。（不考虑balanced）

考虑我们观察某一个位置的前缀和。这个位置的最小前缀和可以贪心弄出来（每次只有遇到$"()"$才交换），最大的也同理，那么在最小和最大之间的就都能弄出来了。

然后继续观察，只要每个前缀和都在对应的最小和最大之间，我们都可以达到这个状态。

于是接下来就是Dp了。

[code](TCO2016%20FINAL%20500.cpp)

### HamiltonianPaths \[TCO2016 FINAL 1000\]

**题意:**
给你一个无向图$G_1$，它只有$k \leq 14$个点。现在构造新图$G_2$，它是把$G_1$复制$n \leq 5e4$遍，然后这个有$nk$个点的图的边取补集。

问在这个新图上，有多少个哈密顿路。

**题解:**

考虑如果最后的图是个满图，我们可以直接算出答案来。

那么删掉了一些边，而且这个边很少，我们可以考虑使用容斥原理来做这个题目。

考虑我们最后的哈密顿路上用到了$m$个被我们枚举的删掉的边。

可以发现这些边肯定在每个copy中都是一些不相交的路径。而我们只要把这些不相交的路径的顺序枚举一下，我们就知道整个的方案数（就是路径条数的阶乘）。

对于一条路径的方案数，我们可以通过$k*2^k$个状态的dp方法来统计。

对于一个copy内部多条路径，我们就用枚举子集dp的方法来统计。

最后因为有$n$个copy，考虑一些我们把他们组合起来，其实就是一些简单组合数，这个可以直接FFT。

注意到这个题目MOD的数字特殊，直接上NTT。

[code](TCO%20FINAL%201000)

### XorRank \[ TCO SEMIFINAL2 1000 \]

**题意:**
定义一个数字集合为完美的，当且仅当对于任意两个数字$a, b$，他们的异或和也在这个集合内。容易发现这样的数字集合的大小肯定是2的幂次。

现在告诉你这个集合的大小为$2^k$，与一些限制，问有多少个数字集合满足这个条件。

限制是给你$n$个数对$rank_i, value_i$，代表把集合里面的数字排序之后，第$rank_i$大的数字值为$value_i$。

**题解:**

考虑我们怎么来表示一个集合。很容易可以发现，我们可以用$k$个线性无关向量组来表示。并且我们对这些向量进行消元，使得每一个向量的主元在其他的向量中没有出现过。并且每个向量的主元是这个向量的最高位。

那么可以发现，这样的表示是唯一的，而且对于某个$rank_i$，我们甚至可以知道它是哪些向量的异或和。

我们对$rank_i$进行消元，然后开始$dp$。

首先如果最后没有一个value中用到了最大的那个向量，答案是无限的。

否则，设$f[i][j]$代表我们弄完了最大$i$位的全部信息，并且最大的$j$个向量的主元位置确定了。

那么转移就是考虑

-   $i-1$这一位是第$j-1$这个向量的主元，直接check就好

-   $i-1$这一位不是某个数字的主元。这样的话根据限制列个方程，解出来自由元的个数，就是转移系数了。

口头BB，没有代码。

### Listening to Music \[ Codeforces Round 302 Div1. E\]

**题意:**
给一个长度为$n \leq 2e5$的序列和一个数字$m$，现在有q个询问，每个询问用$l, r, v$表示，要你求一个位置p，满足$l \leq p \leq r$且$p ~ p + m - 1$中大于等于v的个数最多。

最后输出这个个数最多是多少。注意时限7s，空间64MB。询问强制在线。

**题解:**

Common sense:
考虑如果可以离线，我们把询问和序列上的值一起当成事件，按照权值倒序排序。假如我们有一个数组v，按照权值倒序扫描我们的事件，对于每一个序列上的值，假如位置在pos，我们就把v\[pos
- m + 1 \~ pos\]加一，对于询问，其实就是问max v\[l \~ r\]。

由于询问强制在线，我们需要一些数据结构帮助我们做到这些。

standard algorithm version 由于时限7s，空间很小，考虑分块。

由于询问强制在线，考虑按照序列上的值分块，这样好在可以快速的得到大于某个值的v的信息，但是问题是不好处理$l, r$的限制。考虑按照pos分块，但是这样对于权值的限制又不好弄了。

所以两个一起分块，对每连续的sqrt n个权值，我们当做一个check
point，并且存储一些信息。因为空间太小了，所以我们对于每一个check
point其实只能存O(sqrt n)个数字,
首先对于位置分的每一段我们要存一个当前的段内最大值（当前最大的v），但是问题是，我们对于接下来的sqrt
n的权值，每个权值是一个区间，有些更新区间可能在块的内部，而我们没有记块内部的每个v的值，我们到时候询问的时候无法还原。

一个很聪明的方法就是，我们把这些区间的端点也当做一个关键点考虑到分块中去！这样一来对于每个check
point，我们的块大小其实都不同的。

这样一来我们的更新都是整个块的更新了，但是还有一个问题，我们的询问咋办呢？询问有可能在块中间啊！所以问题就是如何极快的回答一个左端点对应的答案了。我们可以对于每一个块，存储第一个左端点对应的答案！这样的话，我们的左端点往右边移动，其实我们是可以O(1)维护出来当前的答案的！

所以最后的复杂度就是O(nsqrt n)啦！

**可持久化线段树:**
可以发现，可持久化线段树是一个很容易想到的算法，但是卡空间！经过计算，恰好卡了1倍的空间，因为我们对于每个节点，我们要记录左儿子，右儿子，和lazy还有max。

一个简单的trick就是我们不用每次push，update就直接

``` {.cpp}
x->max = max(x->left->max, x->right->max) + x->lazy.
```

然后可以发现这样一来我们可以不用加lazy。。。 因为

``` {.cpp}
lazy = x->max - max(x->left->max, x->right->max);
```

然后利用struct中压位的技术，把剩下的三个参数压成一个ULL即可。

### Three Swaps \[Codeforces Round 197 Div2. E\]

**题意:**
有一个长度为$n \leq 1000$的排列，其中$a[i] = i$，给你经过了三次reverse操作后的排列，输出这三次reverse的一个可能方案。

**题解:**
首先一个简单想法是由于reverse的次数很少，那么肯定有一些关键区间我们可以抠出来，然后只枚举在关键区间上的reverse。而且这种关键区间应该是常数个。

那么什么样的区间算是关键区间呢？一个直接的想法是，区间的端点是『断掉』的地方，这样区间貌似就确实就是常数个了。但这种猜想显然是错误的。

第二种猜想，我们每次reverse之后至少要让『断掉』的部分少1，满足这个条件的区间个数的确是常数个，因为要让其断点数少1，那么一开始两边就要有一个断点，而另外一边要么也有一个断点，这个是被常数bound住了，如果另外一边不是断点，那么至少也要和a\[l-1\]有关系，也bound住了，所以这个猜想的区间个数的确是常数。接下来是证明，也是这道题目最重要的地方。

为了方便，我们设断点数为t，当前剩下的reverse次数为c。t为0时我们就做完了。并且每一次我们最多让t少2，而且最后一次时，t
&lt;=
2我们肯定可以做完。而且可以证明我们每一次至少可以让t少1。（可以自己画画构造）

如果有一次我们没有让断点少1，并且这一次之后我们还有c次reverse操作可以做。t为做这一次之前的断点个数。

首先为了有解，我们需要t &lt;= 2c，而如果t &lt;= c +
1我们就已经保证可以做完了，这一次的reverse我们完全没必要做。又因为c
&lt;= 2，所以t &gt;= 4，且c = 2。

那么也就是说一开始断点数大于等于4，并且我们可以reverse
3次，如果断点数是4，那么我们第三，二次每次减少1，第一次减少2，就解决了，如果一开始断点数是5，我们第一回合一个断点都没有消除，下面两次也肯定无解了。更大同样。

### RPSRobots \[Topcoder TCO2016 3B Hard\]

**题意:**
现在有$n \leq 10w$个长度为$k \leq 18$的字符串，每一个字符串由'R','S','P'组成，分别代表石头，剪刀，布.
每两个字符串称为好的，当且仅当他们之间的任何shift后对决的胜负场数一样。

现在问有多少个好的集合（集合里面两两之间都是好的）。

**题解:**
首先观察两个字符串什么时候是好的。考虑卷积，假设认为w是3次单位复根，那么我们让$R = 1, S = w, P = w^2$，那么两个字符串s,
t在以上赋值的情况下，把t
reverse后取共轭复根，再卷积之后，每一项都相同就是说明s，t是好的。

再简化，每一项相同说明如上卷积之后，只有常数项非0，也就是说DFT后也只有第一位非0，而两个非0复数乘积也非0，还有DFT(rev
conj t) = conj
FFT(t)，综上可得，两个串他们是好的，当且仅当DFT后，除开第一位，非零位置各不相同。

然后就是mask的事情了。
