D. Demolition Time \[cloned\]
=============================

**题意:**
给你一个字符串$s$，我现在有$q$个位置$p_0 \leq p_1 \leq p_2 ... \leq p_q \leq |s|$会依次删去。现在问有多少个$s$的子序列是好的并且这个子序列恰好就是给你的另外一个字符串$t$。一个$s$的子序列是好的，当且仅当我们删除到了某个过程中，这个子序列在这一刻是一个子串。

**题解:**
考虑一个暴力的方法，我们枚举$l, i, r$，代表我们已经删掉了$p_1, p_2, p_3, ... p_i$这些位置的字符之后，在原串上从$s[l..r]$剩下的字符组成的字符串恰好等于$t$。为了避免重复统计，我们需要$l \leq p_i \leq r$。

为了方便，假设$s'$是$s$删掉所有$q$个位置的字符后剩下的字符串。

$l, i, r$合法，当且仅当

-   $s'[l .. p_i] = t[0 .. ?]$

-   $s[p_i + 1 .. r] = t[?, t.size() - 1]$

-   $l + i + ? = r$

其中的问号是和一段区间中有多少被去掉的位置有关，我们可以通过一些处理使得他们都放到$l, r$头上去，成为一个常数。

可以发现前两个要求可以使用EXKMP对每一个$l, r$解出$i$的合适的区间。那么剩下的就是$l, r$之间的关系如何表示。

联立以上式子，转换一下坐标系，可以发现变成了在平面上一些横线竖线，求交点个数，直接$O(n \log n)$的线段树来做。

[D.cpp](2016-10-23 D.cpp)

J. Juice Degustation \[cloned\]
===============================

**题意:**
给你$n$杯果汁，每一杯果汁味道都不相同，并且量为$vol_i ml$现在要求把他们放到最少的杯子中，使得每个杯子中包含果汁量相同，而且不能超过2种味道。

**题解:**
假设把这个看成一个图，每一种味道的果汁就是一个点，如果存在一个杯子中同时包含了味道为$u, v$的果汁，那么我们从$u$到$v$连边。

**Fact 1. 答案不超过$n$。**

考虑假如答案是$n$,
如果一开始每种果汁量相同，那么我们就结束了。否则一点有一个小于avg，一个大于avg，这里我们就能凑出来一杯果汁了，然后情况递归到$n - 1$。归纳法可得证。

考虑一开始从小到大枚举用到的杯子个数$k$。如果当前的$k$可行，直接输出答案结束。

**性质1.
如果$k$可行，那么总存在一种方案对应的图，这个图中不存在环（这个环不考虑self-loop情况）**

考虑在最优答案的图中出现环，我们可以相应调整，重新分配这个环上每一条边上两种果汁的分配比例，从而把这个非自环弄成一个自环。

重复这个过程，我们可以消灭点所有的非自环。

**性质2. 存在一个最优答案，这个图中不存在自环**

不考虑$n = 1$的情况。

考虑存在自环，也就是某个果汁$vol_i$单独塞满了某个杯子。

考虑其他杯子，如果其他的$k - 1$个杯子都是一种果汁塞满，那么$k$显然不可能是最优答案。

否则考虑有一个杯子，由两种果汁$x + y = avg$塞满，考虑把$y$换到我们当前的杯子中，当前杯子换出去相应的$y$容量的果汁，答案还是合法，而我们这种情况减少$1$。不断执行这个过程即可。

这样一来，我们可以发现，我们想求的答案肯定对应了一个森林，而且它用到的杯子数严格就是$n - #connected component$。

考虑我们把$n$个果汁排成某个顺序，使得最后的每一个联通块中的点集下标对应的是这个顺序下的一个区间。由于每个联通块一定是
果汁总量等于$(点数-1)*avg$，直接状压DP枚举顺序，即可。复杂度为$O(n^2 \times 2^n)$。

[J.cpp](2016-10-23 J.cpp)
