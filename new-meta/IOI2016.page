molecules
=========

**题意: ** 有$n$个物品, 每个有个体积. 现在要求你构造一个子集,
使得这个子集中的物品的体积和在$[l,r]$内. 保证$r-l\ge w_{max}-w_{min}$,
其中$w_{max}$和$w_{min}$分别表示所有物品体积最大和最小的.

**做法: ** 枚举选择$k$个物品, 然后把最小的$k$个加起来,
最大的$k$个加起来, 如果这两个值形成的区间和$[l,r]$有交, 则有一组解.
可以用调整法得到.

[IOI2016p1]()

railroad
========

**题意: ** 有$n$个变速器,
第$i$个可以把速度不超过$s_i$的火车变成速度为$t_i$的火车.
现在$n$个变速器都必须使用, 但可以任意排列.
如果前一个变速器的$t_{k_i}$值超过后一个的$s_{k_{i+1}}$值,
那么必须付出$t_{k_i}-s_{k_{i+1}}$的代价减速. 问最小代价.

**做法: ** 跟踪火车的变速情况, 假设最终火车速度要达到$INF=1e9$.
那么火车经过每个$i\rightarrow i+1$($i<INF$)的净次数都是$1$次.
我们把所有变速器强制的次数加起来(即$s_i\rightarrow t_i$都加一,
如果$t_i<s_i$则都减一)(用离散化实现).
现在每个$i\rightarrow i+1$如果净次数大于$1$次, 就要减速几次,
花费对应的代价, 如果小于$1$次, 就要加速几次, 不花代价.
这些代价都是必须的. 最后, 因为花费这些代价后,
每个$i$的出度和入度相等(除了起点和终点$1$和$INF$), 所以有欧拉路,
即这已经是可行解了. 但是注意到一个小trick, 可能图不连通.
这时用一个最小生成树把图连起来即可.

(交yandex crash@61, 本地测试AC)

[IOI2016p2]()

shortcut
========

**题意: ** 有$n$个车站顺次分布在火车道上, 易知他们相邻两个之间的距离.
这$n$个车站每个还连接着一个岔道, 长度为$d_i$, 连接到当前车站的附属车站.
这$2n$个车站构成了一棵树, 树的直径定义为两个点之间距离的最大值.
现在你可以建造一个魔法轨道, 连接$n$个车站中的两个,
且魔法轨道的长度为$c$. 问连接魔法轨道后, 图的直径最小能达到多小.

**做法: ** 二分答案. 假设要判断是否能连接一条魔法轨道,
使得图的直径不超过$k$.
那么原来距离超过$k$的点对都必须使用魔法轨道进行交通,
即如果$s_j-s_i+d_i+d_j>k$, 那么必有$|s_j-s_p|+d_j+|s_i-s_q|+d_i+c\le k$.
其中$s$是车站的位置, $p,q$是魔法轨道连接的两个点, $j>i,p>q$.
这里必须原来的距离超过$k$, 否则不能强行要求经过魔法轨道.
注意到后一个绝对值不等式可以拆成4个. 再发现一个性质,
如果魔法车道对$(i,j)$有贡献, 那么减小$i$或者增大$j$,
魔法轨道依然对$(i,j)$有贡献(即使得距离减小). 所以我们枚举$j$以后,
只要求出来距离超过$k$的最大的$i$,
此时可以对所有的$(i',j)(i'\le i)$建立不等式(即强行要求不超过$i$的点到$j$都使用魔法车道).
这个不等式拆成4个后是关于$s_p$和$s_q$的,
可以分别维护关于$i'$限制最严格的一个, $O(1)$更新限制.
最后我们将得到$s_p-s_q$的上下界以及$s_p+s_q$的上下界,
需要判断是否存在这样的$p, q$. 随着$p$的增长, $s_p$也增长,
可行的$q$的范围是两个根据$p$对向移动的区间的交.
所以我们维护可行的$q$的区间里最靠近某一侧的$q$,
时刻检查是否满足另一侧的限制即可.

[IOI2016p3]()

paint
=====

**题意: ** 有一个长度为$n$的$0,1$序列, 现在有些位置已知, 有些位置未知.
同时, 如果把这个序列每段连续的$1$的长度写出来, 是$b_0,\ldots,b_{m-1}$.
注意数组$b$是由原序列唯一生成的,
即一段连续的长度为$2$的$1$不能分开写作两段长度为$1$的$1$.
现在要求你尽可能复原序列,
即判断每个位置是否在给出的信息下的所有可能解内都是$0$或者都是$1$,
或者不能确定.

**做法: ** 瞎DP一下. 和题目无关, 可以去玩立体绘图方块(1,2).

[IOI2016p4]()

messy
=====

**题意: ** 有一个数据结构可以存储长度为$2^b$的$0,1$串.
将欲存储的$0,1$串都放入数据结构内以后(会自动去重),
必须调用一次$compile$函数才能询问. 调用函数的同时,
数据结构会把所有存储的$0,1$串按照某个(所有串都是同一个)排列交换其中的$0$和$1$的位置.
之后你可以任意询问一个$0,1$串是否存在(交换后).
现在要求你适当的加入和询问, 以确定那个排列是什么.

**做法: ** 现在的困难之一是, 所有的串必须一次放入, 所以我们询问的时候,
仅仅知道某个串存在, 并不能知道它是谁变成的. 考虑我们把所有只含一个$1$,
且这个$1$在奇数位的串全部放进去. 编译后询问每个只含一个$1$的串.
这样就知道$p({1,3,5,\ldots})$了($p$是那个排列),
同时做个补集也知道所有偶数位置的像集.
如果我们能对二进制的每一位做这个事,
那么把每一位对应的奇数或者偶数的像集交起来就是某个数字的像.
二进制的第二位我们可以用只含一个$0$的串解决.
第三位和以后就不能这样简单的解决了, 因为随便设计询问串的话,
结果串会和我们以前的混在一起. 现在我们的结果串可能有$0,1,2^b-1,2^b$个1,
所以只要新的询问串的$1$的个数合适就不会冲突.
注意到我们问完二进制第一位(个位)以后, 就知道了那个大小为$2^{b-1}$的像集.
所以问第三位的时候, 可以放入所有由$0101\ldots 01$某一位翻转得到的串,
其中这一位应该在二进制的第三位上为$1$.
这样得到的串应该是由那个像集代表的二进制串翻转某一位得到.
只要$2^b$次询问就知道翻转了哪些位, 这就是二进制第三位为$1$的数的像集.
这里占用了$1$的个数在$2^{b-1}\pm 1$的串. 后面的每一位,
由于已知信息越来越多, 可以放入$00010001\ldots 0001$某一位翻转得到的串,
占用$2^{b-2}\pm 1$的串. 这样以此类推, 刚好询问完最后一位,
放入的串形如$0\ldots 010\ldots 1$某一位翻转.

[IOI2016p5]()

aLIEns
======

**题意: ** 在一个正方形的棋盘上, 某些格子是关键的.
现在要求你用若干对角线与棋盘主对角线重合,
平行坐标轴的整点正方形覆盖所有的关键格子.
要求每个关键格子都被覆盖至少一次, 最多使用$k$个正方形.
问这些正方形的面积并最小是多少.

**做法: ** 如果不限正方形数, 可以DP. 其实也不用DP,
就是轮廓线求出来结束了. 现在要限制正方形的个数,
注意到题目的答案关于$k$形成一个凸函数. 我们二分导数.
具体做法就是假设每用一个正方形, 有一个固定代价, 其实就是我们二分的导数.
这样答案的函数不但凸性不变, 我们二分的导数的切点还变成了最小值点.
这个最小值可以直接DP, 因为我们只二分了导数, 并没有正方形数限制.
DP完了求出来我们的最小值是由几个正方形得到的,
就知道现在二分的导数的切点是靠左了还是靠右了.
注意到一个实现细节是二分的导数应为整数+eps的形式,
即要求达到这个切点的最小的正方形数. 不然二分时只能确定到$le$和$ri$差$1$,
且这时并不知道真正的导数到底是$le$还是$ri$.

[IOI2016p6]()
