C. Minimum Cut-Cut
==================

**题意:**
现在有一棵$n \leq 20000$个点的树。还有$m \leq 2e5$非树边，保证非树边两个端点的LCA是$1$号节点。求一个最小的图的割，使得这个割恰好包括$2$条树边。

**题解:**

因为每一个非树边的LCA是1，我们可以把整个树看成$1$号点和许多以$1$号点儿子为根的大子树。

不失一般性，我们设$out[u]$为$u != 1$的子树中，有多少个非树边。由于此题的特殊性，这个子树中必定没有两个端点都在内部的非树边。

考虑那两个作为割边的树边的位置。有三个情况：

-   这两个树边有祖孙关系。很简单，我们发现在这种情况下，如果上面的那一个树边是$u -> father[u]$,
    位于下面的树边是$v -> father[v]$。那么我们最后肯定是$u$当前在树上，被砍掉这两条树边后所处的联通块和剩下的所有的点形成了一个割。而这个割包含的边数是$out[u] - out[v] + 2$。显然，我们的$v$选的越靠上越好，那么就有$father[v] = u$。这个可以直接枚举

-   这两个树边在同一个大子树中，没有祖孙关系。那么不失一般性，假设一个是$u->father[u], v->father[v]$。这个的答案其实就是$out[u] + out[v] + 2$。显然，$u, v$都会选叶子，trivial。

-   最难的情况，两个不在同一个大子树中。那么答案是$out[u] + out[v] - 2 * E(subtree(u), subtree(v))$。E(A,
    B)代表的是多少条边一个端点在$A$中，另一个端点在$B$中。

现在集中讨论如何解决第三种情况。
关于$O(m \log^2 n \log m)$的方法我就不说了。接下来是一个空间为$O(n \log n)$，时间为$O(m \log^2 n)$的方法。

考虑我们枚举$u->father[u]$，对于一个固定的$u$，我们维护一个线段树seg(u)，他维护的是答案数组，也就是$seg(u)[v] = out[v] - 2E(sub(u), sub(v))$。我们需要能够回答一个区间内的最小值。

为了维护这个线段树，我们需要做两件事，一个是添加进来一个非树边，这个对应的操作是把一个点到根这条路径上的所有点权值$-2$，或者我们要合并两个线段树，使得他们的对线段树的影响可以合并起来。

对于到根的路径操作，我们可以维护剖分的dfs序，这样的话到根的路径是剖分序上$log \n$个区间。

对于合并，我们可以使用线段树的合并操作，可以做到和单纯的一个一个按顺序修改一样的总复杂度。在这道题里面由于总的修改次数是$O(m \log n)$，所以总复杂度就是
$O(m \log^2 n)$

现在的问题是空间使用量是$O(m \log^2 n)$的。考虑我们要每次dfs，先去size最大的那个。并且对于每一个线段树，我们采用懒惰建树（也就是一个节点我访问或者修改到才真的建立）。这样一来我们每时每刻最多只会有$O(\log n)$个线段树存在，而且每个线段树由于采用的是懒惰建树，所以不会有建树带来的额外复杂度。

[C.cpp](2016-10-30 C.cpp)

K. Kykneion asma
================

**题意:**
现在有$0 ~ 4$，5个digit，各有$a[i] \leq 30000$个。现在要你凑一个没有前导0的$n(n \leq 15000)$个digit的数字，问多少种方案。

**做法:** 一个简单的想法是FFT，但是其实可以容斥。

考虑我们枚举哪些digit超过了个数限制，而其他的不用管，然后考虑算出在这种情况下的方案数。所以我们外围先是一个MASK的枚举。

其实可以考虑DP，$f[i][mask]$代表我们目前放到了第$i$个位置，$mask$代指我们哪些位置真的超过了限制。考虑下一个填什么，它既可以是我们没有作要求的digit，也可以是我们已经超过限制的digit，如果是会超过限制但是当前却没有超过限制，说明我们还没有开始放。用组合数处理这种放置方法即可。

考虑到$mask$肯定是$MASK$的子集，所以我们的复杂度是$O(3^5 \times n \times 5)$，但是可以发现MASK只要枚举它的1的个数就可以转移了，所以最后复杂度为$O(2^5 \times n \times 25)$

L. Number Link
==============

**题意:**
一个$n \times m (n, m \leq 50)$的棋盘，格子有三种情况，0，1，2。要求在上面画圈和一些线，要求圈只能经过0，线必须从一个1连到2。每个格子只能被覆盖一次。线穿过一些边有一些花费，现在要求花费最少。

**做法:**
考虑为0的格子，肯定一进一出，为1的只出不进，为2的只进不出。这样的话其实就可以看成是一个带权匹配了，我们肯定想每个点出去一条路径，而且花费最少。直接费用流即可。

[L.cpp](2016-10-30 L.cpp)
