G. Scaffolding
==============

**题目描述**

实在太水不想描述了

**题解**

其实就是弄成一棵树的样子（最小值当根，两边递归下去）就好了，然后就是从叶子开始贪心。直接$O(n)$即可。

主要是怎么写比较好写。维护右链的方式固然可行，但是有个小trick时要对相等的东西合并处理。于是我们就把这个特殊处理吧。

为了好写，我一开始在两边加了两个0，这样扫完就OK了。

[CODE](2016.11.6 G.cpp)

H. Slim Cut
===========

**题目描述**

对于一个无向图G = (V, E)，定义割(S, S')的权值为
$\frac{w_{uv}}{min(|S|, |S'|)}$，其中$u, v$分别属于两个割集。问最小权值割。
其中$|V| \leq 14000, |E| \leq 30000$。

**题解**

容易发现我们枚举这条边的权值，本题就变成了一个并查集合并，并且要求每次合并之后，剩下的点集合凑出一个集合$S$，使得$min(|S|, |S'|)$最大。

这个就是一个背包，但是直接背包的话复杂度爆炸。可以发现这个问题可以抽象为我们在并查集的过程中不停地假如一个物品，删除一些物品，并且问当前的物品的01背包组成方案。

考虑直接算出每一个物品的存活区间，在线段树上用bitset来暴力做背包。

复杂度为$O(n^2\log n / 32)$

[CODE](2016.11.6 H.cpp)

I. Special Tour
===============

**题意：**
$n*m$的网格图，从一个格子出发，每次可以走曼哈顿距离2或3，求不重复经过格子，覆盖所有格子的回路。

**做法：**小数据暴力dfs。利用352461可以构造任意$1*n,n\geq 12$：两个放在两端，中间不停地连i和i-2；可以构造任意$n*m,n\leq m, n\geq 2, m\geq 6$：一个放左上角，然后连i和i-2连完第一行，画一个X(连接(1,m)和(2,m-1)，(1,m-1)和(2,m))换行，再连i和i-2连完一整行，最后放一个1\*6的接上就行了。所以只需要暴力$5*5$以内的。

代码是基于赛场上的改对的，不是用的这个方法。

[CODE](2016.11.6 I.cpp)
