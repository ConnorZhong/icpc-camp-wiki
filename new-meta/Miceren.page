Miceren's Personal Page
=======================

Blog
----

-   [Flip coin](Flip Coins)

Doing
-----

-   [Suffix Tree](Suffix Tree)

Done
----

-   A fast suffix array algorithm
    [details](A fast suffix array algorithm)
-   matroid intersection algorithm
    [details](matroid intersection algorithm)
-   Codeforces GoodBye2015 All Kill
-   KM O(n\^3) method [KM](KM)

Solo
----

### [Topcoder专题]()

### [UOJ专题]()

### [精妙题]()

### 构造题专题

#### E. Design Tutorial: Learn from a Game \[Codeforces Round \#270\]

**题意:**
在一个$n*m$的棋盘上，每个格子有个token，你可以一开始选定一个位置开始，每次可以把当前的token和八个附近的格子交换，并且选定的格子也就跟着移到了那里，然后你可以继续交换。给你一个初始结束状态，要求你构造方案。

**题解:** 由于是八个方向，可以简单发现我们可以做到交换两个格子。特判n =
1 or m =
1的情况，剩下都可以做到，具体就是进行其他相邻格子之间的交换做到从初始到结束。需要注意的是，你不能在帮助别的格子移动的时候破坏了弄好的格子，而且最后一行需要特别处理。但是一些好的写法可以不用管这件事情。

#### Princess and Her Shadow \[Codeforces Round \#188 (Div. 1)\]

**题意:**
在一个无穷的棋盘上，有一个人和他的影子，还有若干障碍物(障碍物坐标绝对值
&lt;=
100)，每一个物体都占据一个格子。现在人想得到他的影子（和他的影子重合），他只能往上下左右走，并且他每走一步，影子也会如法炮制，在不撞到障碍物的情况下朝本体走得方向走一步。要求你构造方案。

**题解:**
首先假设影子不动，如果人走不到影子的地方就无解。第二种无解是如果没有障碍物，也无解。

否则分两个情况，如果人和影子能走到无限远，那么我们就用上下左右的障碍物来使得人接近影子。

如果人和影子本障碍物包围起来了。那么我们先找到一条从人到影子的一条道路，然后人沿着这个路走，走完了就沿着相应的影子的路径走。这样一定最终能找到影子，因为他们之间的路径长度非增，如果一直不减，那么说明位移总量为0，这是不可能的。

#### Berserk Robot \[Codeforces Round \#300\]

**题意:** 有一个点在二维坐标中，初始位于(0,
0)。现在告诉你他有一个周期为$l(l \leq 2e6)$的 cyclic movement
schedule，每一个movement是U,D,L,R中的一个。现在不告诉你它的schedule，只知道$n(n \leq 2e5)$个信息，分别是在$t_i$的时候到达了$x_i, y_i$。要求你构造出来这个schedule。

**题解:**
首先因为有上下左右四个方向，直接做的话，我们还需要关心横着总共走了多少步，竖着走了多少步，而且不能有一步又往上，又往下。所以把横纵坐标变换

``` {.cpp}
x' = x + y;
y' = x - y;
```

这样一来，我们可以变成每一个横着走一步，纵着走一步，就可以分开考虑了。现在我们的问题变成每一步只能L,R，信息是在$t_i$到达了$x_i$。

考虑把信息按照$t_i$ mod
$l$分类，如果对于同一类有大于等于两个，其实我们就知道了一个周期的横坐标偏移量。这个知道的话，对于相邻的类，根据偏移总量和事件之间的信息，我们可以知道这两个类之间的偏移总量，通过简单判断我们可以直接构造出来这里的方案。

如果没有一个类大于等于2个，就会有点麻烦。我们通过一些处理可以发现对于每两个相邻类之间的关系会对偏移总量有限制，而且可以发现只要两个类之间的关系正确，所有的东西也就正确了。对这些建立不等式，求出偏移总量的上下界和奇偶性情况，得到一个合法的偏移总量，然后和上面一样做了。

#### Shift It! \[Codeforces Beta Round \#68\]

**题意:**
现在有一个6\*6的棋盘，1\~36的排列已经填在了每一个方格子上。现在我们可以选择某行或者某列shift一下，让你构造一个方法把它弄到一个特定的形态。

**题意:**
首先肯定有解，对于前5行容易构造，关键在于最后一行。搜索得出一个变换，可以让最后一行其他数字相对顺序不变的情况下，一个数字往前走2步
(1 2 3 4 5 6 -&gt; 2 3 1 4 5 6)。

``` {.cpp}
    go(j + 2, DOWN);
    go(i + 0, RIGHT);
    go(j + 2, UP);
    go(i + 0, RIGHT);
    go(j + 2, DOWN);
    go(i + 0, LEFT, 2);
    go(j + 2, UP);
```

有了这个变换，其实就随便做了。

#### Black and White \[Codeforces Beta Round \#45 \]

**题意:**
你要把一些方块填到一个$n*m$的网格图中，方块有$a$个全黑的，$b$个全白的，还有$c$个半黑半百的(斜着分割)，且保证(a+b+c
= n\*m, c &gt;=
m),现在这些方块可以旋转，要你把这些填到网格中，使得没有黑白边touch到。

**题解:**
感觉不难，主要看怎么写好写，最简单的写法就是我们从左下角填到右上角，先用黑块，再用m个白黑半百的块，再用白块，在把剩下的白黑半白用了。可以发现这么用下去，由于下面和左边确定了，半黑半百怎么放也就是确定的，该怎么放就怎么放。唯一需要确定的是放那m个半黑半百的时候，肯定有一个左边是空的，这时候不能随便放，讨论一下奇偶性就好了。

#### Restoring Map \[VK Cup 2015 - Finals\]

**题意:**
本来有一个大小为$n \leq 1000$的树，现在告诉你对于原来的每一个点，和他们距离小于等于2的点的集合（包括自己），可惜的是，现在这些集合都是被打乱的，我们只知道有这n个集合与其中的元素分别是什么，但是并不知道原来的那个点对应哪个集合（但集合中的点的标号是确定的）。现在要求你还原原来的树（多解随便输出一个）。

**题解:**
很惭愧，离正解很接近了，还是没有想出来。一个显然的思路，我们肯定要从叶子下手，如果一个点确定是叶子，那么它对应的集合必然是包含它的最小的集合，接下来看上去就很可做了。但是这道题目的难点在于，你无法快速判断一个点是不是叶子。

巧妙之处在于，我们可以通过得出所有的非叶子，从而推出所有的叶子。

首先特判放射型，那么对于其他的情况，必然有一条边连接两个非叶子节点（内点），对于这样的两个点，设为a,
b，
必然存在两个集合的交恰好为这两个点。枚举所有的两个集合，用bitset求交，得到所有的内边，从而得到所有的内点。

那么剩下的问题就是询问每一个叶子对应的内点。这个可以通过找到对应的集合，分情况讨论得到答案。

注意一个特殊情况，就是dumbbell情况，很容易判断。

#### Cube Snake \[Codeforces \#125 Div1 D\]

**题意:**
给定一个$n$，要求你用$1 ~ n^3$这些数字不重不漏的填进这个边长为$n$的cube，并且要求对于每一个$1 \leq i \leq n - 1$，在这个大cube中有两个不同的subcube大小为$i^3$,
且其中的数字构成的集合恰好是连续的。

**题解:**
很显然是递归构造，考虑长度为$n-1$的subcube在什么地方。可以发现几乎是不能能在对角的，因为两边空白的部分是需要连接起来的，而这两个subcube把整个cube分成了两个部分。所以所有的合法的成对的小cube必然恰好『相邻』，考虑构造$k*k*(k+1)$的合法立方体，最后只要在上面加盖就好了。容易发现如此还是比较好构造的。

[官方题解](http://codeforces.com/blog/entry/4764)

#### MaterialImplication \[Topcoder Open 2016 Round 3B\]

**题意:** 给定$n,k$，构造一个只有implication operator
的命题表达式，由n个variable组成，且有k个assignment使得其值为true.

**题解:** key observation: Impossible iff $k \leq 1 << n - 1$。

简短的证明:
用变量个数归纳，假如对于所有的n个变量的式子，$k < 1 << n - 1$不可能，对于一个$n+1$个变量的式子，考虑枚举某一个变量的值，可以发现，某一个变量的值确定后，剩下的式子还是一个合法的，$n-1$个variable的implication
operator only expression. over.

于是，剩下的构造很简单，我们分两种情况用$x->S$ or $S->x$来递归下去.

#### TopologicalOrdering \[Topcoder Open 2016 Round 3A\]

**题意:** 给定一个$n(1 \leq n \leq 32767)$,
构造一个点数不超过50，边数不超过100的有向图，使得其的拓扑排序的方案恰好就是$n$。

**[题解](https://async.icpc-camp.org/d/533-topcoder-open-2016-round-3a):**
主要思路还是 如何构造a + b这种形式，这个明白其实其他的都简单了。。

### 网络流专题

#### RabbitWorking \[SRM Round 542 Hard\]

**题意:**
给一个题，每一条边有一个权值，要求你选择一个点集合，设选的点集合大小为$K$,
要求最大化点集合内部边权和除以$K(200-K)$

**题解:**
考虑分数规划，但是分母是在过于诡异，没法很好地分配到点上。考虑到分母中$K^2$项和选的边集同阶，而且边权都为正数，所以选了$K$个点，必然会选$K^2$条边。

进而可以把这一部分权值分配到边上进而成为最大权闭合子图求解。

由于精度要求高，所以要预处理出所有可能答案，在那上面二分。

#### OldBridges \[SRM Round 556 Hard\]

**题意:** 给定无向图，每条边流量限制为0，2或者oo, 现在有两个流,
分别是$S_1 - T_1$ with $2C_1$与 $S_2 - T_2$ with $2C_2$,
求是否可行。（对于同一条边的流量限制表示为两个流总共使用次数的限制）

**题解（意识流版本）:** 考虑直接连边 $S -> S_1$, $S -> S_2$, $T_1 -> T$,
$T_2 -> T$, 显然最大流为$2(C_1+C_2)$为必要条件。

但这样求出来的解不一定合法，可能的情况是$S_1 -> T_2$,
$S_2 -> T1$这种交叉流的存在，考虑交换$S_1, T_2$
再做一次如上操作，最大流为$2(C_1+C_2)$也同样为必要条件。

假如还是出现了交叉流，这两次的交叉流可以协调一下即可，所以充要。

**题解（正式版本）:** 设$g_1$为直接连边$S -> S_1$, $S -> S_2$,
$T_1 -> T$, $T_2 -> T$求最大流的残量网络，而$g_2$为$S -> T_1$,
$S -> S_2$, $S_1 -> T$,
$T_2 -> T$求最大流的残量网络。则$\frac{g_1 + g_2}{2}$与$\frac{g_1 - g_2}{2}$分别为从$S_2 -> T_2$的流量为$C_2$的残量网络和从$S_1 -> T_1$的流量为$S_1 -> T_1$的流量为$C_1$的残量网络。

考虑$g_1 + g_2$组成的残量网络，只要证明对于每一条边的流量不会超过上界即可

$f_1(e) + f_2(e) = \frac{|g_1(e) + g_2(e)| + |g_1(e) - g_2(e)|}{2} \leq \max(g_1(e), g_2(e))$

#### SurroundingGame \[SRM Round 558 Hard\]

**题意:**
给定一个20\*20的棋盘，选择某个格子有一个花费，对于每一个格子，如果被包围，就有一个收益。

包围是指，格子本身被选，或者相邻格子被选（四连通）。

**题解:**
考虑最小花费所导出的最小割模型。先我们把所有的benefit算上，由于棋盘天然的二分图性质，我们把所有的格子黑白染色。

那么现在问题是如何定义『不合法收入』：如果一个格子自己没有被选，而且周围也有一个格子也没有被选，就不合法！

这个给我们一个提示，这是一个自己格子到旁边格子的一个流，而我们要求的是这上面的最小割。

有了这个思路，剩下的就不难了。把每一个点拆点$u, u'$,
对于拆的点之间连边，为这个点被包围的收益，对于每个黑(白)色格子u(v)，u(v)向源点(汇点)连边，边权为占领这个点的代价。考虑不合法情况，假如u,
v两点相邻，且分别为黑格子与白格子。那么我们连无限边$u -> v'$,
$u' -> v$即可。
