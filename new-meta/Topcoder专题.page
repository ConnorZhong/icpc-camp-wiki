嘴巴AC，SRM708到达SRM687 + SRM677

Unsolved
========

-   677 Hard

OptimalBetting \[SRM708 Hard\]
==============================

**题意:**

你现在有$a$元钱，但你的梦想需要你拥有$b$元钱。为了实现梦想，你可以去赌博最多$k$次。每一次赌博，你都傻傻的随机一个你可以赌的钱数去赌（当然，你有了$b$元钱就不会继续赌了）。一半的概率输赢，输了本金没了，赢了翻倍。现在问你，有多少概率你看起来好像是用了最优策略一样。

$a, b \leq 1e5, k \leq 5$。

**题解:**

一个傻傻的办法是分两步，第一步，我们算出来在还剩$i$轮，我们还有$j$元钱的情况下，我们有多少概率最后能弄到$b$元钱。

第二步就是dp算出到了第$i$轮，我们还有$j$元钱，并且此时我们还被认为采用了最佳策略的情况下的概率是多少。

第一步dp十分简单，第二步就用第一步的结果去选概率最大的集合即可。但是很容易发现，这样复杂度是$K \times N^2$的，GG。

观察第一步，假如我们把概率相同的区间给合并在一起。

在你还没有赌博钱，明显分两段，\[0, b), \[b,
oo)。然后往前递推，你可以发现，在还有$i$轮的时候，区间平均分为了$\frac{2^{i+1}}$段，并且每一段的获胜概率恰好是$\frac{j}{2^{i+1}}$，其中$j$代表第$j$段。

由于$k$很小，我们可以在这里做文章。

第一步可以很轻松弄出来（每一次往前面迭代，算出来新的分界点）。

第二步我们dp的时候，不用直接$O(n)$转移，而是对于相同的段一起做。注意这里为了只有一个$2^k$的复杂度，有些地方我们要用指针来优化复杂度。最后复杂度就是$O(k2^kn)$。

[code](TopCoder_SRM708_Hard)

AlienSkiSlopes \[SRM687 Hard\]
==============================

**题意:**

现在给你一个元素非负的$n \times n$矩阵$A$，现在要求你给定一个长度为$n$的非负数组$d$，使得新矩阵$B[i][j] = A[i][j] - d[j]$，且以这个矩阵建立二分图，结果存在一个完美匹配，使得每一行的匹配位置的值就是这一行的最大值，且值非负。

保证$n \leq 50$。

**题解:**

这个题目看上去十分自然，让人很容易想到线性规划，费用流，KM。

但是这个题难点在于问的是存在性，并给出方案，注意原题说无解输出-1。

根据这种题一般性质，还有和KM的千丝万缕的关系，我猜肯定是有解的。

观察，如果我们知道了每一行选哪一列，为了方便，我们来观察两行$a, b$，和他们对应选择的列$c, d$。设$delta$数组为每一列减少的值。

我们有不等式

$$A[a][c] - delta[c] \geq A[a][d] - delta[d]$$

$$A[b][d] - delta[d] \geq A[b][c] - delta[c]$$

注意，我们可以消除$delta$变量，两式相加得

$$A[a][c] + A[b][d] \geq A[a][d] + A[b][c]$$

这一下就没了$delta$的干扰，说的完全就是原矩阵的性质！！这个式子不就是说我们弄了个匹配，不能通过一个简单的换边操作使得我们的匹配答案更加大嘛。

那我求个KM最大权匹配，不是肯定满足这个性质么！

但是说到底，这个还是个必要条件而已，它充分么？ 答案是肯定的。

我们可以通过构造证明。如果一个匹配方案对于一个$delta = 0$的满足性质（KM出来的最大匹配当然满足啦）。可以发现我们不管怎么对一列减少多少，这个性质恒成立！那么我们从左上角开始，按照正方形大小从小到大做，发现可以构造出来！

但是这个构造太麻烦了！怎么快一点构造$delta$呢？

答案是直接输出$ly$数组即可（就是KM里面，右侧的label）。为什么呢？因为你在做KM的时候，一直保证了$lx[i] + ly[j] \geq A[i][j]$，换句话来说，有

$lx[i] \geq A[i][j] - ly[j]$，而对于匹配对，有$lx[i] = A[i][j] - ly[j]$。也就是说$lx[i]$就是在减少$delta$后的每一行的最大值！

代码就是贴个KM的板子，就不贴代码了。

ForAny \[SRM706 1000\]
======================

**题意:**

要求构造一个长度为$500$的序列，每个数字为不超过$1e18$的非负整数，且这之中每两个不同位置的数字互质当且仅当他们的距离恰好为$1$。

**题解:**

考虑用$p_i$代表第$i$个质数，每个数字肯定是一些质数的乘积。

**随机算法**
我们只使用前31个质数，考虑我们构造序列，使得它们都是$11$个质数的乘积。我们先随机一个数字作为开头。对于下一个数字，我们考虑去掉前一个数字包含的$11$个质数，在剩下的$21$个位置随机，找到$11$个质数生成这一位，在check是否与其他数字不互质，不合法就重新随机。

这个算法之所以正确就是因为两个数字之前不互质，概率其实是基于$\frac{11}{31}$指数分布的，适当的选择参数，使得他们不相等的概率大概为$\frac{1}{n}$，就大概能得到一个比较好的界。实践的话，1s不到就好了。

**确定算法:**
考虑到差不多前14个质数的乘积就是极限了。而500的log大概就是8。这提示我们可以在线段树这种结构上考虑问题。

考虑一个构造算法，我们按照线段树那样分层，把中点标记一下。

一开始，我们对于奇数位置的数字乘以2，偶数位置的数字乘以3.

然后对于每一层，我们拿出来两个质数，从把这$500$个位置左边扫到右边，这一层被标记的中点跳过，交换的乘以这两个质数。

考虑为啥这样对。首先相邻的数字肯定互质没得说。现在来说为什么不相邻就一定互质呢？

如果这两个数字，本身都是奇数位置或者偶数位置的肯定一开始就不互质了。否则，假如它们在线段树的某一层，恰好被一个中点分开，那么他们也不会互质了（考虑上面这个每一层在乘以质数的时候，遇到中点会跳过，而他们在原本的数轴上位置奇偶性不同，所以这么一来正好乘了同一个质数。）

否则，他们这两个位置被分开的时候，肯定有一个是那一层的中点。

考虑继续往下划分的时候，一定有一个时候，恰好有一个中点割在这两个位置之间，根据前面的分析，他们肯定又不会互质了。

由于总共就log层，每个数字每一层最多乘以一个质数，所以随便过了。

maxAndCount \[SRM705 1000\]
===========================

**题意:**

现在给你$n$个灯泡，$m$个开关，每个开关会flip一些灯，现在灯有一个初始状态，问有多少种开关的按的方法，使得最后亮的灯最多，同时问方案数。

时限4s，$n, m \leq 50$。

**题解:**

首先看时限，就知道肯定要折半弄一弄了。

首先高斯消元肯定是必要的。假设$v[i]$代表最高位为第$i$位，且第$i$位为主元的向量。

分两种情况，假如向量个数少（少于27个），我们直接$O(2^27)$走起。

否则，把那些没有主元的位置记下来，然后开始DP,
$f[i][mask]$代表前i个向量做完了，然后那些的mask就好了。。这个mask最大就$2^23$。

感觉不是个难题。

TreeSums \[SRM692 500\]
=======================

**题意:**

现在给你一个串$S$，长度为$L$。那么对于一个串$T$，他的cover
number定义为$S$在$T$里面的，不overlap得最大的作为子串的出现次数。

现在问你对于长度为$L * K - L * K + N$的串，cover
number恰好为$K$的串$T$有多少个。

$L \leq 100, N \leq 1000, K \leq 1e9$。

**题解:**

自己在想的时候，第一时间感觉$L^3$矩阵乘法什么的？但是事实证明，因为要求恰好$K$次，矩阵乘法不是太好控制这个。

然后转念一想，一个special
case，如果$N = 0$会怎么样。。其实答案就是1了对吧。

也就是说，$N$越小应该越简单。

考虑$N$很小为什么简单呢？因为最后$T$应该长成这个样子

$$a_0, S, a_1, S, a_2, S ... S, a_k$$

而且对于每个$a_i$，满足$a_iS$中S出现的最早位置就是在最后。虽然拗口，但是还是可以暴力算出来的。

然后我们设$f(l)$代表长度为$l$的这种$a_i$的个数。

然后其实就是多项式乘法了，相当于有$k$个$f(i)$，这些$a_i$的和为一个常数。而且可以通过倍增来算的快点。

最后复杂度是$O(NL + N^2\log K)$

Finding Friends! \[SRM702 1000\]
================================

**题意:**

现在给你一个长度为$10w$的数组，现在要求你找到一个最小的$k$，使得存在一个**happy**的，长度不小于$m$的子串。

一个子串**happy**当且仅当这个子串中$\forall u, \exists v, |u - v| \leq k$。

**题解:**

首先二分$k$。

对于某个$k$，我们可以先求出来每个元素左边和右边的一个和它差小于等于$k$的元素。我们记他们为$L[i], R[i]$

那么剩下的问题就很简单了，我们需要选择一个子串，使得这个子串中的每个元素$i$，要么$L[i]$选了，要么$R[i]$选了。

那么剩下来就是套路了。我们枚举一个选择的子串的左端点$L$，那么右端点$R$有什么限制呢？考虑每个$i$

-   $L[i] < L$，那么我们要选$i$，就要求$R > R[i]$。换句话说就是$R$不能选在$[i, R[i])$以内。

-   $L[i] > L$，那么我们要选$i$，就要求$R > i$即可。可以发现对$R$没有任何限制。

那么既然对于$R$的限制只是个区间而已，那么我们用线段树，给不能选的位置$+1$，最后看看在我们想要的区域里面有没有是$0$的位置就好了。

本题最后复杂度$O(n \log n)$。
