A. A Poor King
==============

**题意:**
国际象棋，一个黑王，两个白棋（Rook,Bishop,Queen），白方将死黑方最少步数。

**做法:**
从将死状态往外BFS。黑方要尽量和棋/延长比赛，所以黑方的某个状态需要所有后继状态都已经转移过来了，才能加进队列。

[A.cpp](2016-10-26%20A.cpp)

F. Flight
=========

**题意:**
给一棵树，一个询问$u,v,d$，一步能从$x$跳到$y$，当且仅当$dist(x,v)\geq d$，问$u$跳到$v$的最少步数，或无解。

**做法:**
答案只可能是-1,0,1,2,3。首先判掉0和1的情况。找出直径。3的情况是u跳到直径的一端，再跳到另一端，再跳到v，这都不满足就是无解。2德清狂是存在一个中间点，到$u$和$v$的距离都$\geq d$。如果中间点不在$u,v$在直径上的根$pu,pv$的中间，那么一定是直径的两端。如果在中间，可以按照到$u$和$v$的距离分成两部分，两边都只需要判较近的一边是否满足条件。到$u$的距离是$d[u]+pf[x]+|x-p[u]|$，所以预处理直径上每个点延伸的最长路径$pf[x]$，以及$pf[x]+x$和$pf[x]-x$的区间最大值(rmq)，每次$O(1)$查询就可以了。

时限比较紧，尽量少用lca。

[F.cpp](2016-10-26%20F.cpp)

G. Generator \[Yuzuriha Inori\]
===============================

**题意:** Given $N$ strings of length $L$, output the expected time when
all the $N$ strings occur in a random generated infinite string.

**做法:** [link label](/monkey.pdf)

[K.cpp](2016-10-26%20K.cpp)

H. Honey Tour
=============

**题意:**
给你个$n*m$的地图，完整的地图是从上往下重复$k$次。第一行每个格子上面有入口，最后一行每个格子下面有出口，询问从每个入口到每个出口的最长路径和方案数对1e9+7取模。

**做法:**
插头dp+矩乘。$m$只有7，插头是个括号序列，由于有最上面进来的一个所以最后匹配完一定还剩一个左括号，dfs发现只有196个状态。插头dp跑出一个$n*m$迷宫这些状态的转移，然后矩乘。写个答案类，重载+（更新答案）和\*（连接两条路径）。

[H.cpp](2016-10-26%20H.cpp)
