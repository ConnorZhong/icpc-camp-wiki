F. Ber Patio\[Yuzuriha Inori\]
==============================

**题意:** 你在一家商场作为会员拥有一些点券. 每一点点券可以抵一元现金,
但是每件物品最多使用点券抵消一半的现金花费. 购买一件物品后,
你所花的现金数量除以10下取整会加到你的点券中去.
现在已知你拥有的初始的点券数量, 以及你要按顺序依次购买$n$个物品,
他们每个需要$a_i$元现金. 现金与点券最小单位都是1元.
现在问你如何安排每件物品的点券花费, 使得你花费的总现金最少.

**做法:** 假如我们疯狂花点券, 可能产生的问题是, 可能我今天花了点券,
会导致我少付现金, 今天返还给我的点券也就减少了,
间接导致我以后可用的点券少一张. 但是我今天多花了一个点券,
是不会导致今天返还给我的点券少两张或更多的. 所以我们从后往前贪心.
每天先都假定前一天没有使用点券, 即手中多了前一天商品价值/10的点券.
由于今天返回的点券数量是今天实付的现金/10下取整,
所以今天的总价模10的那些钱可以花昨天的点券而不必导致可用点券减少. 并且,
如果今天产生的点券在以后用不完,
那么产生今天的多余的那些点券的钱也都可以随便使用昨天的点券付账,
同样不会导致可用的点券减少. 这之后如果还有点券要使用,
就只能减少一张今天或以后某一天产生的点券. 这时,
产生这一张点券的10元钱就只剩了9元, 这剩余的9元已经无法产生点券,
所以是可以随意用点券抵现金的. 要注意每天只能最多用价格一半的点券.

K. Roads Orientation Problem \[Yuzuriha Inori\]
===============================================

**题意:** 给你一个无向图和其中两个点$s$, $t$.
要求你将这个无向图定向成一个从$s$到$t$的格(定义: $s$是唯一的入度为0的点,
$t$是唯一的出度为0的点, 且整个图无环).

**做法:** 首先我们有一个无视时限的做法. 先把$s$到$t$连起来,
这条链从$s$到$t$定向. 然后每次找从链上出去再回来的一条路径,
按照出去和回来的点在链上的先后给他们定向. 但是为了不超时,
需要实现这个做法. 方法是从$s$开始做个dfs树. 这棵树上有一些返祖边,
还有点$t$. 我们考虑下面一个递推过程: 首先置$t$于队列中,
并标记$t$为"沿树向上". 每次取队列中任意元素$v$,
如果$v$到$v$的父亲之间的边没有定向, 就照$v$上面的标记来定向,
同时把$v$赋值为$v$的父亲, 标记不变. 在这个过程中,
如果对一条边$(father[v], v)$定向, 并且存在一条以$father[v]$为祖先,
以$v$的某个后代$u$为后代的返祖边$(father[v],u)$,
就将这条边按照$(father[v], v)$的相同方向定向,
同时将$u$标记为$v$相反标记(沿树向上&lt;-&gt;沿树向下), 将$u$插入队列中.
这个过程能正确的定向所有边(当有解的时候. 无解的判断法是,
有条边在递推过程结束后还没有被染色. 这说明有无法走到$t$的死路.).
因为在这个过程中, 如果$(father[v], v)$被定向为$father[v]->v$,
那么从$v$的任意子孙无法走到$father[v]$, 对称地,
如果$(father[v], v)$被定向为$v->father[v]$,
那么$v$无法走到$v$的任意子孙(除了$v$自己). 这个可以循环不变式证明.

[K.cpp](2016-10-25%20K.cpp)

L. Expression Queries \[Miceren\]
=================================

**题意:**
给一个仅仅有$+, *, 0 ~ 9, (, )$的表达式，每次问一个区间的答案是多少（要判断非法）。

**做法:**
首先，由于只有$+$与$*$，考虑没有括号的情况，有的括号我们可以看成一个数字。我们可以把要求的表达式看成

$$a*b+c+d*e$$

的形式，其中$a, e$可以是某个数字的一个前缀或者后缀。$c$可能是许多数字的连乘，但是此处我们把他们看成一个加项。我们对我们分的每一块分别处理，内部多个连乘或者连加使用倍增优化掉即可。

实现起来稍微有点麻烦，需要预处理每一个加号，乘号往后连续弄$2^j$后的答案。

[L.cpp](2016-10-25%20L.cpp)
