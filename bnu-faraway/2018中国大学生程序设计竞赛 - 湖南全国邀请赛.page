Info
====

Date:2018.05.19

[Link](http://acm.hdu.edu.cn/contests/contest_show.php?cid=798)

Solutions
=========

A Easy h-index
--------------

solved by gjy

------------------------------------------------------------------------

gjy's solution

做后缀和，$\max \limits_{0<=i<=n}min(i,sum[i])$即为答案。

B Higher h-index
----------------

solved by gjy

------------------------------------------------------------------------

gjy's solution

如果$a>=n$则答案为$n$,否则为$n/2$

C Just h-index
--------------

solved by sk

------------------------------------------------------------------------

sk's solution

将区间$[l,r]$里的数从大到小排序后，假设存到$b_1,b_2,\dots,b_{r-l+1}$，那么询问的东西就是$max(min(b_i,i)),1\le i \le r-l+1$。

二分答案+主席树区间查询第k大，时间复杂度$O(nlog^2n)$。

D Circular Coloring
-------------------

upsolved by gjy

------------------------------------------------------------------------

gjy's solution

黑白独立，$f[i][j]$表示i个珠子j段所有情况的权值和，转移
$f[i][j]=\sum_{L=1}^{N-1}L*f[i-L][j-1]$

由上式得到答案：$Ans=\sum_{L=1}^n \sum_{k=1}^{Min(n-L,m)}L^2*f[n-L][k-1]*f[m][k]+\sum_{k=1}^{Min(m-L,n)}L^2*f[m-L][k-1]*f[n][k]$

记$g[n-L][k]=L*f[n-L][k]$，即考虑首段shift次数之后的结果。

转移方程完全相同，初值$g[i][j]=i^2$。

但是这么处理出来是MLE的，于是离线询问，在做$g[i][j]$的过程中求答案就好。

E From Tree to Graph
--------------------

unsolved

F Sorting
---------

solved by sk

------------------------------------------------------------------------

sk's solution

排序就好了，避免浮点数误差用了int128。

G String Transformation
-----------------------

solved by sk,gjy

------------------------------------------------------------------------

gjy's solution

首先可以观察到，任意串一定可以通过某种方式消除成
空串，a,b,ab,ba,aba,bab,baba 中的一种。称这些串为基本串。

添加或删除aa,bb,abab的过程是可逆的，所以只需要将串消除成基本串，判断基本串之间是否可以互相转化即可。

判断基本串间是否可以互相转化，奇偶分类手玩一下即可。

H Infinity
----------

unsolved

I Longest Increasing Subsequence
--------------------------------

upsolved by gjy

------------------------------------------------------------------------

gjy's solution

先对于不是0的位置，做一次LIS，得到$Ldp[i]和Rdp[i]$。

首先可以观察到答案只会是$LIS$和$LIS+1$，且答案为$LIS+1$的情况为，原本是0的位置左边为$L$，右边为$LIS-L$，现0的值在$(a[i],a[j])$中。

对于$a[i]$,找到它之后0的位置$x$，再找到$x$之后的$Rdp[j]==LIS-Ldp[i]$的$a[j]$的最大值，那么在$(a[i],a[j])$范围内答案则为$LIS+1$。

上述操作可用单调队列实现。

\*需要特别处理的trick

(1)全是0的情况需要特判

(2)0左端不取，右端取$LIS$的情况：找到$Rdp[i]==LIS$，若$i$位置前有0出现则$(0,a[i])$均可。

(3)0右端不取，左端取$LIS$的情况：令$a[n+1]=inf,Rdp[n+1]=0$即可。

J Vertex Cover
--------------

solved by gjy

------------------------------------------------------------------------

gjy's solution

对选了的点，一定存在更大的未选的点与他有一边。

对未选的点，一定不存在更大的未选的点与他有一边。

对于任意点，更大的选过的点与他可以有边可以没有边。

从高到低扫一遍，记一记选过和没选过的个数即可。

K 2018
------

solved by sk

------------------------------------------------------------------------

sk's solution

$2018=2*1009$，手动分类容斥一下。

Replay
======

ghc
---

gjy
---

组合还需要加强，菜。

sk
--
