A. Balance [zmy]
=================================
首先可以发现的性质是，每一行（列）的差分结果相同。因此我们设第一列的值为 $y_1$,$y_2$,...,$y_n$，第 $i$ 列与第 $1$ 列的差分结果是 $x_i$。那么我们要求的目标函数是 $n*\sum(x_i+y_i)$，且有一些约束 $x_i+y_j>=a_{i,j}$。这个可以用 KM 求解。

B. Entanglement
======================


C. Gravity [wbr]
=========================
将一个联通块看作一个点，设 $d_i$ 表示第 $i$ 个联通块下落的时间。考虑每一列相邻的两个联通块$i$,$j$，如果其纵坐标的差为$w$ ，那么有限制 $d_i-d_j\leq w$。可以用差分约束解决。

D. Infinite Pattern Matching [jds]
====================
暴力枚举 A 中第一个数和第二个数的分界线，再暴力枚举第二个数的截止位置。注意要考虑进位的情况，以及第二个数的截止位置超出 A 的位置，这两种情况。

E. Inheritance
==========================


F. Movies
=================================


G. Origami
==========================


H. Qnp
======================



I. Salaj [zmy]
================================
考虑 dp $f[i][j][k]$ 表示现在有 $i$ 条边，联通块个数缩了 $j$，且有 $k$ 个环的方案数。转移方程显然。

J. Taxi [wbr]
================================
考虑确定好每个乘客和每个出租车的位置后，如果计算答案。考虑每个边的贡献。如果这个边所对应的两个子树分别有 $c_a,c_b$ 的乘客，$t_a,t_b$ 的出租车，那么这条边会被贡献 $\min\{c_a,t_b\}+\min\{c_b,t_a\}$

K. Tris
================================

L. Xormites [zmy]
================================
拆位考虑。如果当前这一位，有偶数个 $1$，那么显然无论怎么操作，两个玩家在这一位上只能打成平局。
考虑第一个有奇数个 $1$ 的那一位，胜负会在这里分晓。
如果此时 $n$ 为偶数，那么我们将格子黑白染色，其中一色必然是奇数个，且先手有办法一直选这部分。
如果此时 $n$ 为奇数，那么必须先选个 $1$ 然后模仿后手行动。