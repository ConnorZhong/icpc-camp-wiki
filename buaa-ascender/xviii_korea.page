A. Donut [zmy]
=================================
扫描线，用线段树维护每个点为矩形左上角的答案。注意各种边界情况。

B. Circular Arrangement
======================


C. Earthquake [zmy]
=========================
贪心。首先对于每段路，我们肯定先查最后可能坏的，然后算出结束这段路径检查的期望步数 $s$ 和这条路毁坏的概率 $p$。然后考虑这些路的检查顺序。

考虑两个相邻的路径，前面的是 $a$ ，后面的是 $b$，应满足：
$$a.s+a.p*b.s < b.s+b.p*a.s$$
 

D. Dynamic Input Tool [jds]
====================
贪心，每次选取前面最长的一个合法字串。维护一个 next 数组，存储这个点之后最近的每个字母的位置。更新的时候暴力向前更新，直到遇到相同字符。

E. Central Lake
==========================


F. Computing MDSST
=================================
状压 dp。 $f[s][i]$ 表示点集为 $s$ ，根为 $i$ 的代价。看上去是 $3^n*n*n$，实际可以通过预处理优化到 $3^n*n+2^n*n*n$

G. MST with Metropolis
==========================


H. Number of Cycles
======================


I. Sum of Squares of the Occurrence Counts [jds][zmy]
================================
先对整个串建后缀自动机。对 parent 树进行树链剖分。显然平方的贡献我们通过差分来维护。每次加字符会让 parent 树上这个位置到根，每个串出现次数加 $1$，注意 parent 树每个节点的串的个数实际上是 sam[p].val-sam[sam[p].par].val

J. Game of Sorting
================================


K. Subsequence Queries
================================

L. XOR Transformation [wbr]
================================
