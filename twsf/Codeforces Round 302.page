A
=

题解：可以如果没有bug的限制，可以看成是一个完全背包。加上bug后，只需再开一维记录当前有多少bug了即可。

B
=

题解：如果两条路径不相交，则答案一定为m减去这s1到t1与s2到t2的最短路。如果这两条路径有相交，可以证明相交部分一定是一直连续的。（不可能中间有分叉）因为，一旦分开，后面还会汇合，则中间分开那部分两个同时走最短路最优。于是预处理出任意两点最短路，可以使用bfs。枚举他们相交的部分是那部分。然后算答案。注意相交那部分，他们可能是相向而行的。

C
=

题解：因为字符集是26，而最多有20个字符串，所以修改任意一个字符，都可以让被修改字符所在字符串被识别。逐列考虑，$f[mask]$表示考虑完前$i$列，$mask$位置的字符串已经被识别的最小花费。在第$j$列，一共有两种方式可以让第$i$个字符串被识别，一种是直接修改这个位置的字符，让它单独被识别。第二种是修改这一列与它字符相同的其他所有字符（原因是修改这个位置的字符代价太大了。）使得被修改的字符串以及这个字符串共同被识别。第一种转移很简单，注意可以不修改它就被识别了。第二种转移预处理下字符$x$在这一列的状态$flag[x]$,
总代价$tot[x]$,最大代价$mx[x]$,$f[mask | flag[x]] = min(f[mask | flag[x]], f[mask] + tot[x] - mx[x]);$

D
=

题解：放一条坏路相当于砍掉一颗子树，于是对于节点i来说，答案就是它儿子们答案加1（加1为在它连向儿子的那条边上放一条坏路，儿子下面都不能放了）乘起来。然后换根时相当于父亲除掉自己的贡献加1然后乘自己儿子的贡献即可。但是做除法时可能为0。所以维护一下乘积的前缀与后缀，同时换根时将父亲的贡献传下来即可。
