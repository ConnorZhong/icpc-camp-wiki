A. Ambitious Plan \[zxa\]\[jsy\]
================================

枚举B点，把A、C点极角排序，先考虑枚举两个C点，发现能与AB相交当且仅当两个C夹角不大于pi且A可以选择两个C之间的任意一个A。

所以枚举极角小的C，转出极角大的C的最远的范围后累计答案。

B. Borderless Words\[jsy\]
==========================

考虑求not-boring的字符串方案数$dp[n]$，总方案数减去存在$k$满足前$k$个和后$k$个匹配的方案数。$num[k]$代表最小的$k$使得前$k$个和后$k$个匹配的方案数。

有一个性质：$k$一定小于等于$\frac{n}{2}$。

$num[k] = dp[k] \cdot 2^{n - k * 2}$

$dp[n] = 2^n - \sum_{i=1}^{\frac{n}{2}}num[i]$。

求某个字典序只需要，枚举前缀，然后计算前缀意义下的方案数即可。

C. Catalan Combinatorial Objects
================================

D. Decomposable Single Word Languages \[zxa\]
=============================================

水……找串里两个不相同的字符且都不与自己后一个位置相同的字符加上`*`就可以了。

E. Elegant Square \[jsy\]
=========================

第一步：把所有格子都填上恰好一个质数。

(1,1),(2,2),...,(n,n)
填一个质数,(1,2)(2,3)...(n,1)填一个质数，依次类推。

第一步做完之后，矩阵中有n种数字，每种有$n$个。

第二步：所有格子再填一个质数。

(1,1),(2,n),...,(n,2)填一个质数,(1,2)(2,1)...(n,3)填一个质数，依次类推。

如果是奇数的话，已经构造好了，如果是偶数的话，转到第三步。

第三步：

格子(i,j)和(i + $\frac{n}{2}$, j +
$\frac{n}{2}$)相同的，并且每种数字就两个。

(1,1)(2,1+$\frac{n}{2}$),...,(n-1,$\frac{n}{2}$-1)(n,n)这样填即可。

F. Four Colors \[zxa\]
======================

瞎搞，每次找一个可填颜色最少的节点填色。

G. Greater Number Wins\[jsy\]
=============================

$f[i][j][op]$代表第一个人当前数字情况为$i$，第二个人当前数字情况为$j$，且当前$op$先手，第一个人获胜的概率。

$i$和$j$都是$b+1$进制，存的是数字大小再额外压一位是否填过数字了。

然后暴力转移即可。

H. Higher Math Lesson
=====================

I. Isomorphism
==============

J. Jinxiety of a Polyomino\[jsy\]
=================================

把边界点都扣出来，然后有一种做法是：枚举边界上的起点和终点，暴力$check$转弯次数。

这里计算转弯次数可以贪心计算，一直沿着某个方向走，走到不能再走后转弯。这里是$O(n)$的。

对上述做法进行改进：现在只枚举起点，然后枚举一对方向，暴力走，然后走的过程中更新所有边界上的点，这样是$O(K^2)$，$K$是边界上的点。

这样边界上的点数还是太多了，如果边界上一条直线只保留两个端点，这样就能在规定时间内算出答案了。
