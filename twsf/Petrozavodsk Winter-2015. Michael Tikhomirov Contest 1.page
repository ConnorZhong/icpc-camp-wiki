A. Aarelia Mountains \[jsy\]
============================

对原系列做差，然后每次操作只修改两个点的值，并且是一个加1另一个减1。这就很像网络流，而且每个点有个最多减少的值，以及至少增加的值。然后建图跑费用流。

B. Bar \`\`Duck'' \[jsy\]
=========================

先二分区间长度。然后check的时候枚举区间中点$m$，m左边区间内的点要往左端点移动，右边区间内的点往右端点移动。这样能量函数就是一个关于中点坐标的二次函数。

只要区间内的点集不变，函数就是相同的。所以至多有$3n$种函数，每种函数取个最小值再判断即可。

C. Collections In Containers \[zxa\]\[jsy\]
===========================================

大概画一画可以发现至少可以匹配出对于每一维度，任意匹配的两个向量的这一维的和都不大于这一维度的最大值。

方法就是先考虑一维问题，一维问题直接对着匹配就行了。

然后考虑k维问题，先把所有第k维相等的向量组按k-1维的方法匹配好，然后考虑怎么修改匹配能使得这一维匹配后能使得任意两个匹配好的都不大于最大值X，只需要考虑每个向量，如果这个向量第k维的大小是x(x&gt;X/2)，那么肯定存在一个第k维大小为X-x且1\~k-1维都一样的向量，只需要把它们匹配的向量交换一下就可以了。

D. 1D Spreadsheet \[zxa\]
=========================

把询问分块，对于一个块内的询问只有那些属性被修改的点是有用的，把它们的拓扑结构建出来。然后对于每个节点，如果它实际的权值不会在这块询问内盖改变，那就把这些点对答案的贡献拿前缀和统计好，否则找到这个点往上第一个有用的点，意味着在这几步操作内这个点一直和这个有用点绑定在一块。然后对于每次操作直接O(1)更改属性，询问对于每个有用点求出它实际的值是多少以及它所管辖的点有几个在这个区间内部，就可以知道这个点对答案的贡献。

E. Even Separation \[jsy\]
==========================

每个点看成一个变量$xi$，取0/1分别代表染两种颜色。对每个点建一个xor方程：所有边的两个端点的xor。如果答案是1，说明删除了奇数条边，否则删掉了偶数条边。然后高斯消元即可。

F. Fibonacci's Nightmare \[zxa\]
================================

$E(X_n)=n+1$，由于$Var(X) = E(X^2) - E(X)^2$，所以只需算$E((X_n)^2)$，设这个是$h(n)$。

把$E((X_n)^2)$展开然后使劲转换发现要求一个$E((\sum_{i=0}^{n-1}{X_i})^2)$，设这个为$g(n)$。

把$g(n)$也展开然后使劲推导，最后可以发现$g(n)$和$g(n-1)$与$h(n-1)$有关，然后递推就做完啦。

训练中没做出来的主要原因是本身工具使用不熟练，E和$\sum$代换模糊等等。

G. Guess The String \[zxa\]
===========================

先试出这个串每种字符有多少个，然后考虑合并两个字符串，只需将一个字符串按顺序一个一个插入到另一个字符串中即可，合并两个长度为A和B的字符串所需要的询问长度之和大概是O((A+B)\^2)的，所以用分治的那种结构或者哈夫曼树来让这个长度之和尽可能小。

H. Hilbert's Maze
=================

I. Infinite Binary Embedding
============================

J. Jitterbug \[jsy\]
====================

用大约一半的点构一个团，然后后面跟一条链。写check然后调参数。
