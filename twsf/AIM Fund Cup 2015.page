A. Substrings and Subsequences \[zxa\]
======================================

串只能是aaa...aaa或者aaa..aabb.bbb的形式，分别计算概率。

B. Bus stop
===========

C. Collection of sets \[jsy\]
=============================

对于$K \leq 7$时，把14尽量均等划分，每一部分取一个元素，然后把求一下他们的笛卡儿积。

对于$K > 7$的情况，先求出$14-K$的解，然后每个集合取个补集就行了。

D. Decomposition
================

E. Easy Everest \[jsy\]
=======================

排序模拟

F. Sum of divisors \[jsy\]
==========================

$n = \sum_{i=1}^K \frac{n}{ai}$ =&gt;
$1 = \sum_{i=1}^K \frac{1}{ai}$。由于$K$比较小，所以可以暴力预处理出$ai$组合的$lcm$。接下来的事情就是用这些数字来做容斥。因为数据组数过多，所以得预处理出每个数字对答案的贡献。

G. Guess sinus \[jsy\]
======================

先用$x = 10^{-9}$判断$a$的符号，是负数就打个标记。如果$a$的取值范围是$[L, R]$，那么令
$x = \frac{2 \cdot \pi}{L+R}$来判断$a$是属于$[L, \frac{L+R}{2}]$还是$[\frac{L+R}{2},R]$，总次数是$log$级别的。

H. Matrices dot product \[zxa\]
===============================

暴力水题

I. I18n \[zxa\]
===============

暴力模拟

J. Segment Sort \[jsy\]
=======================

假设$[li,ri](1 \leq i \leq m)$是一组操作序列，如果$[li, ri]$和$[lj, rj]$有交集，那么可以用$[min(li, lj), max(ri, rj)]$来代替前两个操作。

先把所有的数字离散化成$n$的排列$P$。对于所有的区间$[min(i, Pi), max(i,Pi)]$，至少要有一个操作包含该区间，设这些区间内除了右端点的所有元素都为禁止节点。显然所有操作的右端点都不能是禁止节点。

设$F[i]$代表考虑了前$i$个元素，且前$i$个元素都已经排好序的最小代价。暴力的方法是枚举一个非禁止节点$K$，更新$F[k]$的答案。由于代价只有$\sqrt{n}$种，所以可以枚举代价来转移。

K. Tree generation \[zxa\]
==========================

用度数的平方和来check
