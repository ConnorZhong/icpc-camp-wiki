A. Abstract Picture \[jsy\]
===========================

倒着做，每次删掉一行或者一列，这个过程是个拓扑排序

B. Battle Mage \[zxa\]
======================

求圆的面积并的重心，拆成弓形和三角形，弓形的重心靠[查表](https://en.wikipedia.org/wiki/List_of_centroids)或积分。

注意弧度极小的弓形的重心很容易产生精度问题。

掌握了比较好的圆并写法。

C. Constant Ratio \[jsy\]
=========================

枚举公比，模拟

D. dir -C \[zxa\]
=================

RMQ，暴力。

E. Extreme Permutations \[jsy\]
===============================

$[k+1, 2k+1]$这些数字是互不相邻的，一共有k+1个数字，所以他们只能放在奇数位，剩下的数字放偶数位。

数字分成两类：$[1,k]$和$[k+1,2k+1]$，考虑从小到大放第二类数字：

如果把第$i$个数字放在位置$x$，且位置$x-2$还没放，那么就选一个一类数字放$x-1$。这样做的原因是，$x-2$的数字一定大于$x$的数字，且一类数字一定比二类数字小，所以只要$x$和$x-1$没有冲突，以后也不会有冲突。对于$x+1$位置也是一样的。

设$f[i][mask][k]$代表已经填了前$i$个二类数字，且$mask$的奇数位置已经被填，可以使用的一类数字有$k$个的方案数。转移就枚举填的位置即可。

对于原先就有的数字，只需在转移的时候稍微注意一下即可。

F. Find the Length \[zxa\]\[jsy\]
=================================

考虑floyd的增量的过程，用分治处理出对于每个点就剩这个点没在floyd里滚的矩阵。

G. Game \`\`Minesweeper'' \[zxa\]
=================================

在无法确定时，需要暴力搜索每一个未确定的格子如果不是雷是否会与现在的局面产生矛盾。对于每个翻开的格子，统计它周边还没有确定的格子数量。如果某个数量是0，就看它现在周围的雷数是否一致。找到一个这个数量最少的格子，优先搜索这个格子周边的某个格子。如果搜到一个确定不是雷的格子就把它点了，直到只剩下雷为止。

H. Hierarchy \[zxa\]
====================

STL模拟

I. Interactive Casino \[zxa\]
=============================

维护当前x可能是哪些值，如果剩余的值全是奇数位就有一次必胜的机会，否则赌1块钱来减少可能性。

J. Judgement \[jsy\]
====================

$f[i][j]$代表考虑了前$i$个物品，第一种方法得分为$j$，第二种方法得分的最大值，暴力背包即可。方案用bool数组来存，$f$数组滚动以节省空间。

K. Krotek \[zxa\]\[jsy\]
========================

只需把所有合法的线段连上求个生成树就行，求合法的线段就还是得枚举一个点然后转转转，用set维护当前极角照到的线段。

WA了半天是因为当线段跨越x轴时一开始就要插入set，然而极角向量没有初始化为(1,0)。

L. Liesbeth and the String \[zxa\]
==================================

按他们说的把代码打了上去就过了

M. Matrix, The \[zxa\]\[jsy\]
=============================

先逐格DP转移出$f[i][j]$表示已经填好了$i$行且$n$个列的状态是$j$（0/1/2）时的方案。

对于每个询问，每行按照字典序枚举一整行的状态，通过一些方法计算出能和转移到的状态对接上的方案数。以此来一行行确定答案矩阵。
