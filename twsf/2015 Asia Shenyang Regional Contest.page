A. Pattern String
=================

B. Bazinga \[jsy\]
==================

从前往后暴力，如果$Si$是$Sj$$(i < j)$的子串，那么可以删除$Si$。可以证明这么做只会比较$O(n)$次。

C. Minimum Cut-Cut
==================

D. Pagodas \[jsy\]
==================

$\gcd$

E. Efficient Tree \[zxa\]
=========================

轮廓线状压DP，设f\[\]\[\]\[mask\]为当前转移到了某个格子的最小生成树的最小大小以及其LRdeg的乘积是什么，转移只需要考虑是否往上往左连边维护一下连通性即可。

F. Frogs \[jsy\]
================

所有数字与$n$求一遍$\gcd$，然后容斥，有一个剪枝，不然复杂度会爆炸。

G. Game of flying circus \[jsy\]
================================

第二个人的策略肯定是先打一下第一个人，然后按顺序跑，而且是越早打越好。所以就二分打的最早可行时间。

H. Chessboard \[jsy\]\[zxa\]
============================

维护每次操作后，棋盘上能到达$(x, y)$的所有起点的集合。对于每次操作，大部分点都会向相应的操作移动，只有少部分点保持不动（边界上的点和障碍周围的点），保持不动的那些点就和其他点发生了合并集合的操作。由于障碍和边界上的点就$1000$个，所以每次操作都可以暴力合并集合。

I. Triple \[jsy\]
=================

对于二元组，每个相同的第二元保留最大的第一元。暴力合并剩下的二元组和三元组，然后二维树状数组就可以了。

J. John's fences
================

K. Kykneion Asma \[jsy\]
========================

设$W(n,a0,a1,a2,a3,a4)$代表可以有前导$0$的$n$位$5$进制数字，至多$ai$个数字$i$的方案数。

$W(n,a0,a1,a2,a3,a4) - W(n-1,a0-1,a1,a2,a3,a4)$就是最后的答案，相当于减去一定有前导$0$的方案数。

接下来的问题就是求$W(n,a0,a1,a2,a3,a4)$：

考虑容斥，设$f[i][j][mask]$为考虑了填了$i$位数字，有$mask$的数字使用次数超过了限制，且考虑完全部$n$位数字后有$j$种数字超过限制。

考虑转移：

对于一定要超过限制的数字$k$，第一次填的时候直接填$a[k]+1$个，然后就当作普通的数字来看了。

$f[i][j][mask] = f[i - 1][j][mask] \cdot (5 - j + |mask|) + \sum_{mask (1 << k) > 0} f[i - (a[k] + 1)][mask - (1 << k)] \cdot \binom{i-1}{a[k]}$

最后用 $f[n][j][mask] (|mask|=j)$更新答案。

[代码](http://paste.ubuntu.com/12977852/)，复杂度$O(n \cdot 5^2 \cdot 2^5)$

实际上，稍微改改状态就能优化成$O(n \cdot 5 \cdot 2^5)$。

[代码](http://paste.ubuntu.com/12977943/)

L. Number Link \[zxa\]
======================

上下界费用流，建图十分显然。

M. Meeting \[zxa\]
==================

水题，建好图跑两次最短路即可。
