A. Area of Effect
=================

B. Canyon Mapping \[zxa\]
=========================

只要覆盖所有的线段整个图形就被覆盖了，又因为正方形必须平行于坐标轴，所以二分答案check的时候只要搜索当前还剩那些线段没有被覆盖，枚举选择哪个角落把线段覆盖就行了。复杂度为$O(n^{K-1} \log A)$。

C. Magic Checkerboard \[jsy\]
=============================

对格子进行分类，枚举每一类格子的奇偶性，然后贪心放数字。当$n=1$或$m=1$时需特判

D. Extensive OR \[jsy\]
=======================

先考虑可以有相同数字且数字有序的方案$res[i]$，设$f[i][j]$代表考虑了前$i$块，有$j$个数字和$R$相等，其他数字比$R$小的方案数。设$tr[a][b]$代表考虑一整块数位之前有$a$个数字和$R$相等，考虑了这一块数位后又$b$个数字和$R$相等的方案数，这个可以用数位$dp$，每次枚举$n$个数字在这一位分别是什么。

有了$res[i]$，就需要删掉有相等数字的方案数。这时候就枚举$n$个数字的最小表示，然后奇数个数字只保留一个，偶数个数字都不保留，然后看看剩下了几个不同的数字，用之前计算出来的方案来统计。剩下的偶数个数字就任意选没出现过的数字。

E. Primal Partitions \[jsy\]
============================

二分答案$x$，然后check的时候贪心计算至少需要拆的段数，这个也用一个二分或者暴力来计算（因为区间扩展的时候权值只会减少）。

F. Sand Art \[zxa\]
===================

先把每个区域每种土按最小值填好，然后答案中的最高高度肯定就是当前最高的区域。然后二分最低的高度，剩下的就是个网络流。

G. String Stretching \[zxa\]
============================

枚举答案的长度，那么就能知道答案最后的组成，枚举符合要求的子串，接下来只要检查它是否合法，设f\[i\]\[j\]\[k\]表示当前已经匹配了i个位置，已经完整了匹配j个这个串且当前匹配了到这个串的第k个位置是否可能，转移就按题意很显然。这样做估计最坏是$O(n^{4.5})$，可能实际是$O(n^{3.5})$。

H. Vending Machine \[zxa\]
==========================

统计出每个零食最小的卖价和次小的卖价，然后如果最小的卖价的指向形成了环，就代表环上只有一个零食不能以最小的卖价买，只能用次小。

I. Rainbow Zamboni \[jsy\]
==========================

每走四步，起点的坐标$(x,y)$会变成$(x+2,y-2)$。当步数超过$max(n,m)$的时候，每次染色相当于染整行或者整列。而起点坐标的循环节不超过$n*m$，所以我们只需要做最后的$n*m$步以及最开始的$max(n,m)$步。

J. Zig Zag Nametag \[jsy\]
==========================

长度为$L$的相邻差值之和为$25(L-1)$。所以很容易知道最终长度是多长，至于最小的字典序，就一位一位枚举即可。
