A
=

题解：s串每一位单独考虑相当于与t串的每一位都比较一次，再乘n。合并同类项后总贡献为s串中A的出现次数乘以t串中A的出现次数加上s串中G的出现次数乘以t串中G的出现次数加上s串中T的出现次数乘以t串中T的出现次数加上s串中C的出现次数乘以s串中C的出现次数。可以发现让s串中出现最多的那个字母乘的数越大约好，有相同数量的最大值，则哪个字母都可以。所以就是最大值个数的n次幂。

B
=

题解：将可以取走的方块放入set中，轮到先手时取最大的，轮到后手时取最小的，注意取出来的时候还要判断它是否可以取走（因为有可能别的方块取走后，它就变得不能取走了。）。如果可以取走从set中删掉再找。拿走这块之后，再在这块底下寻找可以取走的重新放入set。可以证明每块最多进入set常数次，应该不超过3到4次。至于存块的位置，可以离散化，我直接用map存了。

C
=

题解：每一位分别考虑。无论正号怎么放置，对它有影响的其实只有它后面的第一个正号，影响它对答案贡献是乘10的多少次幂。所以每一位可以算出对答案的贡献，具体算法就是枚举它后面紧接着的正号在距离后面多远的位置，就能算出剩下还有多少个位置，要放k－1个加号。组合数一下即可。还有就是末端相当于默认放了一个”加号“，这个对答案也有贡献。这些贡献合并同类项后，即可算出答案。
