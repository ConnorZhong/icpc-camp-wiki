A. Associated Vertices \[jsy\]
==============================

暴力的做法是，对于每个点刚开始沿着反边走，在任意时刻可以转变一次方向改成沿着正边走，这样就能知道每个点能和多少个点配对。这个可以用$bitset$优化成$O(\frac{n^2}{64})$。

B. Bishops \[jsy\]
==================

预处理出每个对角线是否被占领，对于每个被占领的对角线统计格子数。这样会有重复的情况，重复的情况肯定是一正一反对角线同时占领某个格子，对于每个正对角线，和它有冲突的反对角线一定是一段连续的区间（分奇偶讨论）。然后用前缀和就可以解决问题了。

C. Cool Numbers \[zhy\]
=======================

晒出质数，枚举$1e6$以内所有满足要求的数即可。

D. Diagram \[zhy\]
==================

要选出$k$个，所以两点间距离为$xn / k$，所以对所有距离模$xn / k$,看是否有一个余数有k个。

E. Effective Hiring \[jsy\]
===========================

$Ci$作为第一关键字从小到大，$Ai$作为第二关键字按$(2, 3, 1)$的顺序排序，这样的话每一对搭档肯定是实习生在前，正式员工在后的形式。这样就可以$dp$了，设$f[i][j][k]$代表考虑了前$i$个人，有$j$个实习生，$k$个正式员工的最小代价。

F. First And Last \[zxa\]
=========================

用py打了一个表

G. Game of Solitaire \[jsy\]
============================

$gcd(N, K)$

H. Hero’s Quest \[zxa\]
=======================

设f\[i\]\[j\]为当前连通情况是i且hero在j号点的期望，则可以列出转移方程。第一维的大小是n的分拆数，最大不到700。则可以发现转移的环只有f\[i\]内部有，外部对于f\[i\]都是常数。所以只需做n的分拆数次大小为n的高斯消元。

I. Important Or Not? \[jsy\]
============================

先处理出后缀数组，对于前两个操作，相当于选择一个子串，然后将它设置为$important$或者非$important$。显然，对于每个子串，以它作为前缀且$rank$最小的后缀是唯一的，将它作为这个子串的位置。然后前两个操作就相当于单点插入或者删除子串。

对于第三个操作，相当于查询一个区间大于$len$的所有$important$的子串中长度第$K$大的有多长。

前两个操作都可以通过线段树套$multiset$来解决，对于最后一个操作，可以把线段树中对应的区间找出来，然后在这些区间中挑出$K$个不小于$len$的子串。这里的区间个数是常数级别的，且$K$比较小，所以复杂度是对的。

J. Joining Powers \[jsy\]
=========================

首先 当 $p$是$d$的约数时，$S(d)$ 是 $S(p)$的子集，所以先把这样的$d$
都去掉。

二分答案$x$，然后统计有多少个数字小于等于$x$。这部分可以暴力容斥做，唯一的剪枝就是如果当前指数大于$64$直接计算答案。

K. Keyboard Map \[jsy\]
=======================

$dp[i][j]$ 代表考虑了前$i$个按键以及前$j$个字符，最小代价是多少。

$dp[i][j] = min(dp[i-1][k] + \sum_{l = k + 1}^{j} fl \cdot (l - k))$，这个东西化简化简就发现可以斜率优化了。

L. Light Sources \[jsy\]
========================

有一个明显的性质：肯定选凸多边形不会使得答案更差。

枚举一个一定要被选的点$s$，把剩下的点极角排序，然后就可以$dp$了。

$dp[i][mask]$代表最后一个点为$i$，且包含了$mask$的颜色的最小长度。

$dp[k][mask | opt] = dp[i][mask] + len(i,k)$，$opt$是三角形$(s, i, k)$中包含的颜色。

M. Merging \[jsy\]\[zhy\]
=========================

$N$不超过$10^5$，且每个多项式所代表的序列是递增的，所以可以用堆维护答案。
