A. A + B \[zxa\]\[jsy\]
=======================

进位的话就看这一位后面第一个和不是9的位的和是否超过9，判断的方法是用倍增和hash。

hash应该是必要的，二分判断T成狗，后缀的hash还写反了。

B. Break Free
=============

C. Covering Words with Carrying \[jsy\]
=======================================

枚举覆盖的串，暴力记方案

D. Decisions \[jsy\]
====================

背包，biset优化

E. Enigmatic Matrix \[jsy\]
===========================

dp,用map记录状态，一行一行转移。由于列可以随意交换，所以把列按$1$的个数排序，状态就会减少很多。然后转移的时候，拥有相同的$1$的列看成相同的，最后乘个组合数即可。这样能在一分钟内把所有情况跑出来，然后就打表。

F. Four Russians on a Tree \[jsy\]
==================================

先预处理出每种大小不超过$K$的树，再预处理出，一棵$p$树根接一个$q$树转移到的状态。然后设$G[i][j][mask]$代表考虑了第$i$棵子树，且根所在的树为$j$，一共有$mask$类子树是否可行。转移就用or运算的fwt就可以了。

G. Grundy \[zxa\]
=================

一行一行填数，维护一下每列每条斜对角线已经填的数的bitset就能简单地判断某个格子是什么数了，大概维护一下填数区间的上界以及利用对称性能简化不少代码。

H. Hardware Hashing
===================

I. Interactive Proofs
=====================

J. Jackpot \[zxa\]\[jsy\]
=========================

费用流
