A. Bowling game \[zxa\]
=======================

贪心，小心分析所有的情况。

B. Memory leaks
===============

C. Wallet \[jsy\]
=================

初始顺序是按所有数字第一次出现顺序，然后后面每次就看两个相邻的相同的数字之间不同的数字个数，这个离线加树状数组即可。

D. Faulty dial \[jsy\]
======================

对所有的位置，计算出所有可能的数字，然后贪心从大到小枚举每组数字即可。

E. Poker
========

F. The Guardian of Traditions \[zxa\]
=====================================

环长的种类只有$O(\sqrt{n})$种，对于每一种长度$L$都可以通过合并模$L$剩余下$i$相等的$q_i$，从而转换为两个$O(L)$维向量的卷积，使用FFT即可，这样FFT的总复杂度还是$O(n \log n)$。

一个麻烦的地方是答案最大为$2.5 \times 10^{18}$，所以需要用两个足够大的质数来做FFT，需要手动找这些数。

G. Technical debt \[jsy\]
=========================

物品可以分为两类，第一类是对答案贡献为零的物品，第二类是非零的物品。第一类物品肯定放在第二类物品前面，第二类物品肯定按$a[i]$从大到小的顺序放置。

所有物品按$a[i]$排序，设$f[i][j][k]$代表考虑了后$i$个物品，现在使用第一类物品可以把$X$减到$j$，第二类物品初始的$X$为$k$的最大代价。然后每次枚举物品属于哪一类转移即可，$k$等于$0$的转移和其他不同，要注意一下。

最后用$f[1][i][i]$更新答案。

H. Magic Programmer \[jsy\]
===========================

树分治，用Hash维护从一个节点到根的所有数字出现情况，然后用map统计答案。

I. Find Denis
=============

J. Trains \[zxa\]
=================

先把树建出来，因为保证了答案在一个量级里面，所以可以直接用 Treap
维护每辆火车到达每个节点的时间，合并的时候分段暴力合并，合并的次数和答案同阶。

K. Nostalgic Evening
====================

L. Experienced coach \[zxa\]
============================

每个连通块都满足边数不大于点数就合法，方案只需要dfs一下。
