[A. Anagrams](http://codeforces.com/gym/100792/problem/A) \[zxa\]
=================================================================

结合样例，不难得出只有k-1的约数满足条件。

[B. Banana Brain's Bracelet](http://codeforces.com/gym/100792/problem/B) \[jsy\] \[zxa\]
========================================================================================

先把$A$串倍长，然后求一遍扩展$kmp$。把两个串取反再做一遍扩展$KMP$。假设A\[i...k\]
+ A\[l..j\]匹配$C$串，则用
$m + i - j - 1$更新答案，且要让$m + i - j - 1 \leq n$，这个过程可以用树状数组来优化。

[C. Colder-Hotter](http://codeforces.com/gym/100792/problem/C) \[jsy\]
======================================================================

每次把平面分成四个部分，然后取中间$5$个点，使用8次操作很容易判断出点属于哪个部分，递归处理。

[D. Delay Time](http://codeforces.com/gym/100792/problem/D) \[zxa\]
===================================================================

解一元二次方程。

[E. Entertainment](http://codeforces.com/gym/100792/problem/E) \[jsy\]
======================================================================

最暴力的方法是枚举两个人$i,j$计算他们对答案的贡献，具体计算方法是：枚举他们比赛的层数$K$，计算方案数。把公式写出来后发现可以用前缀和优化掉。

[F. Flow Management](http://codeforces.com/gym/100792/problem/F) \[jsy\]
========================================================================

分类讨论

[G. Garden Gathering](http://codeforces.com/gym/100792/problem/G) \[zxa\]
=========================================================================

要求$\max\{ \max(dx , dy) + \min(dx , dy) \cdot (\sqrt{2} - 1)\}$，枚举一下max和min和里面dx,dy的符号共8种情况即可。

[H. Hashing](http://codeforces.com/gym/100792/problem/H) \[zxa\]
================================================================

猜测最后至多不选500多个数字，然后DP。

[I. Illegal or Not?](http://codeforces.com/gym/100792/problem/I) \[zhy\]
========================================================================

模拟，暴力将每个区间标记在一个数组上，然后暴力扫描每个长度为180的区间，判断是否有大于90个点被标记了即可。

[J. Jealousy](http://codeforces.com/gym/100792/problem/J) \[jsy\]
=================================================================

上下界费用流（需要用zkw费用流）或者把带下界的边权设为负无穷直接跑费用流。

[K. King's Rout](http://codeforces.com/gym/100792/problem/K) \[jsy\]
====================================================================

建反图，求字典序最大的拓扑序，再把序列取反。

[L. Locomotive](http://codeforces.com/gym/100792/problem/L) \[jsy\]
===================================================================

把原图中的边当作点，边之间的关系当作边建新点。保留当前到那些点，并且最近经过的$12$条边是哪些，然后就是$bfs$了。
