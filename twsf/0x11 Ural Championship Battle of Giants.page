A. Snow Removal \[jsy\]
=======================

暴力斯坦纳树。

B. Rebroadcast \[jsy\]
======================

dp,每次枚举合法的一段，用树状数组优化。

C. Hideouts \[zxa\]
===================

选择的两个点一定是沿着这个向量方向的最远点和最近点，求出这些点之后要检查两条路径上的坐标的单调性，用线段树里套个凸壳处理。

D. Multisets
============

E. Screen \[zxa\]
=================

暴力

F. Crates \[jsy\]
=================

先二分答案$X$，然后把底面积为$2^{k1}, 2^{k2}$, ...
高度为$0$的容器加入答案，其中$2^{k1} + 2^{k2} + ... = X$。然后把输入的容器按照底面积从高到低考虑。

假设现在考虑底面积为$2^l$的容器，且答案中的容器大小均为$2^l$的。现在只需要看是否能用当前的容器替换某个答案中的容器使得答案变大。

假设考虑完底面积为$2^l$的容器了，现在把答案中每个容器都变成两个大小为$2^{l-1}$的容器，递归做子问题。

G. Popcount \[zxa\]
===================

答案至少是popcount(x)，然后按这个界在模x剩余系下BFS即可。

H. Gift Boxes \[jsy\]
=====================

排序，然后枚举4种放盒子的方法。

I. Coprime Sets \[jsy\]
=======================

求出不大于$\sqrt{n}$的所有质数，最多有16个。然后设$f[i][mask]$代表考虑了前$i$类数字，且$mask$集合的质数已经被使用过的方案数。对于大于$\sqrt{n}$的质数，每个数字里至多出现一次，所以按照大于$\sqrt{n}$的质数分类，每类最多取一个数字，然后dp就好了。

J. Piggybank \[zxa\]
====================

线段树套凸壳，离线可以做到一个$\log$。

K. Juggling
===========

L. Fibonacci Graphs \[jsy\]
===========================

首先，最短路径长度是很简单的，每次看看起点终点是否在同一个模块内就可以了。假设$u$在模块$n-2$，且$v$在模块$n-1$，那么$u$在模块$n-2$走一些边后，再往模块$n-1$走过去，然后就是一个$n-1$的子问题了。

$f[i][j]$代表现在是图$G[i]$，在$i-2$模块走了$j$条边后，再往模块$i-1$走的方案数。这个只要部分和优化优化就能算出答案了。
