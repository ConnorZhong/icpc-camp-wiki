A. Aho-Corasick Automaton \[zxa\]
=================================

对Trie做后缀数组，然后枚举成为前缀的串，用线段树更新最大值。

B. All Pair Shortest Path \[jsy\]
=================================

$bfs$维护每条链的长度，每次往后面加一条边，更新新链的长度，用$bitset$来加速操作。

C. Chessboard
=============

D. Around the World \[zxa\]
===========================

用一棵生成树就能构造出方案，分奇层点和偶层点。

E. Intersection \[zxa\]
=======================

有一个结论是如果m=0，凸包就是斜率相邻的两条直线的所有交点求出来后形成的凸包。

对于m&gt;0，定义节点含有被删除点的直线为坏直线，则最多只有100条坏直线。把好直线排序后的点以及好直线与坏直线的交点都加入集合求凸包。

F. Data Structure You've Never Heard Of \[zxa\]
===============================================

需要维护一个数据结构支持修改一个元素，询问一个子集和。

维护一个东西把最近的修改都记录下来，然后如果修改的数量爆炸了就重做一次FWT然后清空修改。

G. Huffman Coding \[jsy\]
=========================

$f[i][j][k]$代表考虑到第$i$层，现在有$j$个节点被占领，有$k$个空闲节点的最小代价。有两种操作，一种是分配一个空闲节点给字符串，一种是把空闲节点分裂到下一层。

H. Non-descending Sequence \[jsy\]
==================================

$f[i][j]$代表考虑了后$i$段权值，有$j$个数字已经被确定的方案数。
$f[i][j] = \sum_{k = j + 1}^{n} (f[i + 1][k] \cdot \binom{n + k - j - 1}{k}) \cdot [min(a[l], l >= j , l <= n) >= i]$。

把式子优化之后可以$FFT$加速运算。

I. Perfect Matching
===================

J. 24 Data Structures You've Ever Heard Of \[zxa\]
==================================================

枚举2和3的位置，然后看1和4是否是被放在了两个不同的段。如果在不同的段是简单的，如果在一个段则还需要用一个线段树维护一下。
