A. Senseless and Merciless \[jsy\]
==================================

设$f[x]$为以$x$作为根的子树中所有结点到$x$的距离乘标号的和，然后在维护一个从父亲到$x$的值$g[x]$，然后就需要维护一个类似毛毛虫的东西了。

B. Multithreading \[jsy\]
=========================

期望的线性性，设$f[x][y]$代表个数为$x$的物品对个数为$y$的物品的贡献，个数总共就$5000$种，所以可以先预处理，然后暴力计算答案。

C. Polynomial \[zxa\]
=====================

给多项式求导可以使得多项式的重根的阶减1，求出所有k阶导与k+1阶导的最大公因式，最后一个degree大于0的多项式就是重根阶最大的多项式，然后就能依次得到所有重根。

D. Openspaces \[zxa\]
=====================

外公切线都在凸包上，把凸包线性合并一下就可以了。

E. Game \[jsy\]
===============

最多就$2^n$类数字，对于每类数字算一下，看是否是后手必胜。

F. Password \[jsy\]
===================

先对第一个串做一遍后缀自动机。

设$f[i][j][mask][x][l]$代表，考虑了前$i$个字符，当前$lcs$长度为$j$，当前串和第二个串的大小关系为$mask$，后缀自动机的匹配结点为$x$，匹配长度为$l$的方案数。

这个状态比较稀疏，可以冲过去。

G. Random Shuffle Ranking \[zxa\]
=================================

一位一位做，先排序长度为1的串，然后长度为2的串都是i和i\^1拼起来的，类似求SA那样就可以求出长度为2的子串的rank，再排长度为4的依次类推。

H. Query Matching \[jsy\]
=========================

合并两个$trie$，然后对$trie$做后缀自动机，后缀自动机中两个trie公共的结点对答案有贡献。
