A. Audit \[zxa\]
================

读懂题直接模拟。

B. Bank \[jsy\]
===============

dp,分x-&gt;0, 0 -&gt; x, x -&gt; y三种情况进行转移，注意1 -&gt;
1的情况。

C. Christmas tree \[jsy\]
=========================

最优情况是每列尽量均分。每个格子能对$w$个子矩阵有贡献，所有子矩阵的物品个数总和为$m*s$。所以矩阵内至少要放$\lceil \frac{m * s}{w} \rceil$个物品。接下来就贪心从价值低的物品开始放，每次放最高能放的位置。一直放到达到要求为止。

D. Delicious pizza \[jsy\]
==========================

二分答案然后dp，记录切$K$刀，剩余弧度区间是$[l,r]$的最小面积。

E. Expression
=============

F. Fashionable tile
===================

G. Game with XORs \[jsy\]
=========================

把每一位拆开，决定胜负的那一位一定是$1$个数为奇数的最高位。然后就变成只有0和1的问题了，这时候直接数位dp就可以了。

H. Harvest \[jsy\]
==================

最后的策略是，Bob快速走到一个$X$，路上能剪芒果就剪。然后等Alice到X，等的过程中不断剪芒果，如果已经没有了就往$Y$走，然后走的过程中同样能剪就剪。

I. Incredible string transformation \[zhy\]
===========================================

先将b串中没有的字符在a串中删掉。然后用随便一个字符将a串填满。然后从左到右扫描，依次将a串变为b串。每次改变为，如果b串位置是'.'，先不管它，如果b串与a串这个位置相同，则不管它。
若不同，则根据a串中这个字符出现次数分类。
第一种，这个字符出现多次，则可直接删掉，找到这个位置应该填的那个字符位置，dup一下即可。
第二种，这个字符出现一次，则找到一个可以删除的字符(因保证有解，则肯定存在，因为若a、b不完全一样的话，b串最多有n-1个不是'.'的字符，而a串全是不是'.'的字符，这个没用的字符肯定是某个字符的多次出现)，将那个可删除的字符删掉，dup当前位置的字符到那里，然后删掉这个位置，找到这个位置应该填的那个字符位置，dup一下即可。
上述操作避免了“概率”问题。

J. Jeerman \[jsy\]
==================

在AC自动机上暴力dp。

K. Kuzbass Mine \[zxa\]
=======================

函数式线段树维护DFS序列，对询问二分。

L. Lightbulbs
=============
