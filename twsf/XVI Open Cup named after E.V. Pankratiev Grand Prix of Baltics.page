A. Covering \[jsy\]
===================

一个团的子集也是个团，如果点集$mask1$可由$k$个团组成和点集$mask2$可由$l$个团组成，那么点集$mask1 | mask2$可由$k+l$个团组成，独立集的情况和最大团的情况是一样的。

对于给定的$(p,q)$，用$or$形式的fwt可以在$O(n * 2^n)$的时间内判断出$mask$子集是否可以由$p$个团以及$q$个独立集组成。但是，fwt的累计子集和部分可以通过预处理做到$O(n*2^n)$。

由于，我们只需要知道{1,2,...,n}这个集合的答案，而不需要知道它子集的答案，所以完全可以用容斥代替掉高维差分，这样就可以做到$O(2^n)$的复杂度。

如果$(p,q)$是合法的$(p+1,q)$和$(p,q+1)$也是合法的，所以可以$O(n)$次判断构出矩阵。

B. Hovels
=========

C. Ancient City
===============

D. Kites \[zxa\]
================

处理好每个三角形然后维护个set就可以了。

E. Unique Element \[jsy\]
=========================

二分答案，每次通过检查相邻两个是否相同来判断解在哪边

F. Pizza Delivery Key \[jsy\]
=============================

$f[mask]$代表已经选了$mask$的物品，所需要最小的$i * S + j$，其中$i$是之前已经放了多少个背包，$j$是当前背包的容量。然后加个第一次必须放$1$的优化就过了。

G. Reversed Continued Fraction \[zxa\]
======================================

直接模拟。

H. Technical Support \[zxa\]
============================

由韦达定理两个根x,y满足x+y=-p ,
xy=q即xy-x-y=A，整理一下枚举A+1的约数就可以了。

I. Stack and Subroutines Machine \[zxa\]\[jsy\]
===============================================

维护从栈顶开始的5个数字，栈里的元素数量以及1，所有的指令都可以看做一个转移矩阵。之前题意理解以及写法上都出了奇妙的问题。

J. Draw Straight Walk \[jsy\]
=============================

递归模拟建树的过程。
