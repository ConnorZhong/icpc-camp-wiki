A
=

题解：分类讨论题。我是先判断答案是否全是1，不是的话从R的高位开始，是0填0，是1先判断是否后面全是1，是的话就都填1，否则填0，后面全填1。巧妙的做法是每次把L的最低位的0变成1，也覆盖了我考虑的所有情况。[http://codeforces.com/contest/484/submission/8683043]()

B
=

题解：从小到大，枚举每一个数的倍数，查找当前枚举到的这个数小于它的最大的是谁(链表实现)，取模更新答案。调和级数复杂度$nlgn$

D
=

题解：$dp$,
$f[i]=max{f[i-1], f[j]+abs(a[i]-a[j+1])}$，其中$j$从$0$到$i-1$。因为将最终答案划分好后，每段连续的组中若端点不是这一段的最大最小值，则可以将这个端点从这一组中删掉放入别的组中，答案不会变差。所以上面那种$dp$默认$i$与$j+1$都是这一段中最大最小值是可以覆盖包括最优解的所有极优解的。考虑优化上式，将绝对值拆开。可以发现当$a[i]>a[j+1]$时，$f[i]=max{f[i-1], f[j]+a[i]-a[j+1]}$，即要找到最大的$j$使得$f[j]-a[j+1]$最大，所以前面维护一个这个值的最大值即可。同理$a[i]<a[j+1]$时，维护$f[j]+a[j+1]$的最大值。即维护两个最大值，分别更新答案。
