A. Salad Bar \[jsy\]
====================

如果只考虑，从左往右的限制。那么，固定一个左端点，合法的右端点是从左端点开始的一段连续区间，反过来也是一样的。然后线段树维护维护就可以了。

B. Hotels \[zxa\]
=================

考虑枚举三个点的LCA，那么这种形状可以变成两种形状拼起来的，一种是叉状，一种是链状。

然后设$f[x][i]$为以$x$为根的子树内到$x$的距离为$i$的有多少个，$g[x][i]$为以$x$为跟形成的叉状结构还差的长度为$i$的方案数，那么转移方程比较显然，然后在以$x$为根的子树内子树不同的$f[y][i]$与$g[z][i]$都能匹配出一种方案。注意到$f[x][i]$的$i$不大于$size_x$。所以所有DP可以启发式合并，复杂度即$O(n \log n)$。

分治和这个是一个道理，这个代码很短而且不难写，只是在开火车上面MLE了(64M)，可以在[这里](http://www.lydsy.com:808/JudgeOnline/problem.php?id=4543)提交且通过。

C. Bricks \[zxa\]
=================

按个数从大到小排序，然后分奇偶性交错放。

再从两个方向扫一下检查一下是否合法，如果不合法可以交换相邻两个，如果通过交换也无法让它合法就无解。

D. Couriers \[jsy\]
===================

暴力的话，用一个栈来维护答案，如果栈顶元素和将要处理的元素不同，那么弹出栈顶元素，否则插入要处理的元素。最后留在栈的元素才有可能是答案。这个过程可以用线段树来维护。

E. Solar Lamps \[zxa\]
======================

先把坐标转一转变成标准的二维平面问题，稍微判一下覆盖角度是一条线的情况。

然后思考暴力，坐标是一个拓扑序，按这个顺序枚举每个点，可以通过二分答案得到这个点的时间。

再用整体二分来优化上述过程即可。

F. Solar Panels \[jsy\]
=======================

小于
$\sqrt{n}$的gcd，可以直接枚举check。对于大于$\sqrt{n}$的gcd，倍数肯定是小于$\sqrt{n}$的，这时候枚举倍数，然后得到若干个gcd区间，然后两组区间取个并再拉出最大值更新答案。

G. Criminals \[jsy\]
====================

由于每个强盗每种颜色最多抢劫一次，所以就对于每个位置，记录从该位置出发最终到达的最近的点。然后枚举两个强盗的起点颜色，肯定是一个站在最左边的位置，一个站在最右边的位置。这样就能得到一个最终的区间，这段区间内所有终点颜色的点都能记录到答案。

H. Rally \[zxa\]
================

DP出每个点的in和out，表示从这个点进和出的最大长度。然后通过枚举每条边和每个点的极长路径，维护对于每个点来说不经过这个点的最长路径能有多长。这个用线段树在拓扑序列上维护维护就行了。

I. Supercomputer \[jsy\]
========================

如果只有一个询问的话，就贪心放节点。第一次放根节点，第二次放所有可放的节点（即根节点的儿子们），如果不够放，多余的节点就放在下一次处理。用并查集按询问从大到小维护答案。

J. Tourism \[zxa\]
==================

高速解？对每个连通块单独做，求出从某个点出发的DFS生成树，则非树边只有竖边。然后考虑最暴力的DP，设f\[x\]\[i\]\[j\]为以x为根的子树已经全部被支配且从x往上那d个点(d是x节点的深度)是否被选的mask是i，是否被支配的mask是j的最小代价。那么转移是显然的，这样看起来是$O(n 4^{10})$的，实际上只有
(i|i&lt;&lt;1|i&gt;&gt;1) 是 j
的子集的状态是有用的，这样的状态数量只有$(1+\sqrt{2})^k$，所以可以通过，时间复杂度为$O(n (1 + \sqrt{2})^{10})$。

K. Freight \[jsy\]
==================

$n^2$的dp很显然，$f[i]$代表前$i$个人走完的最短时间。$f[i] = min(max(f[j] + i - j - 1, a[i]) + i - j - 1 + S * 2)$，容易发现只要去掉了max，两种情况都很容易优化。
还有一个性质，就是$a[i]$可以调整为严格递增的。然后
$a[i] - i$就是一个不下降的序列了，这样就可以用堆来维护满足$f[j] + i - j - 1 <= a[i]$的$j$了。然后就变成了两个简单的转移了。
