A. Data Coding \[jsy\]
======================

枚举所有进位的可能，然后暴搜

B. Kingdom Division \[zxa\]
===========================

考虑一个暴力点的方法，枚举所有点对，一组点对可以算出一个Ax+By=C且gcd(A,B,C)=1,C&gt;=0。去重后发现极限情况大概只有6e5条直线。

所以考虑每条直线以O(n+m)来算它经过的格子就能过了。

C. Farmer's happiness \[jsy\]
=============================

枚举两个点$S,T$，先把平面分成两部分，每部分单独处理，三个点$(S,T,X)$内部没有点当且仅当不存在$Y$满足
$(S,X)$在$(S,Y)$顺时针方向，$(T,X)$在$(T, Y)$逆时针方向。然后排序，扫一遍即可。由于时间卡的比较紧，把排序拉到外面预处理。

D. Generalized Fibonacci Numbers \[jsy\]
========================================

暴力搜索，注意，如果 A &lt; X &lt; B直接返回$1$。

E. Hello Space! \[zxa\]
=======================

把所有数排序之后枚举其中大数和小数的分界线再判断是否可行，最后再把结果打出来即可。

F. Equivalent Images \[zxa\]
============================

模拟，直接计算每个格子的面积。注意利用好容斥，以及不要用浮点数。

G. Labyrinth \[zxa\]
====================

从起点终点出发各计算一次最短路，再分最短路的奇偶性枚举充当中点的点或者边是否唯一。

H. Mafia forever! \[zxa\]\[jsy\]
================================

考虑t=1的情况，每个人对应一个01向量，向量相同的人可以在一个组，所以最后最多会剩下$2^K$个人，相当于少了$2^{K-1}$组。

t=k的情况只需要把t=k-1的每组人看成一个人继续做上述的过程就可以了，最多会少形成$\sum_{k=0}^{K-1}{2^k}$组，满足题目条件。

I. Password \[zxa\]\[jsy\]
==========================

最后一个数仅是把原数拆成两半相加，所以从高到低枚举最后一个数的每一位是否进位，就可以知道第$i$位与第$i+2^{K-1}$位的和，把这两个数对输入的贡献删去之后继续枚举下一位，知道最后枚举完看是不是都是0。一开始预处理一个数位之和等于k的有多少种就做完了。

J. Buying roads \[jsy\]
=======================

枚举主链，然后用堆维护外挂的边的最小值
