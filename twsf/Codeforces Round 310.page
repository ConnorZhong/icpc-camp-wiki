A
=

题解：如果想得到里面的小套娃，就要将它外面的全部打开。而一副套娃最里面不是1，则最里面的那个必须要打开，则外面的都要打开。1外面连续递增的$（1，2，3...）$这些套娃都不需要打开。则上来直接找1所在套娃链，除去连续递增的部分，剩下的全需打开，并将他们正确套好。

B
=

题解：很容易得到连续两个岛间可放置桥的长度区间。现在问题变为给你若干区间和若干点。问是否可以使得每个区间都至少有一个点，且点不能重复使用。这个是有贪心策略的。将区间按右端点排序，依次处理区间。将当前点坐标小于当前区间右端点的点放入set中。在set中查找一个大于等于当前区间左端点的坐标最小的点。因为这个点已经是坐标最小的了，剩下能放这个区间的点坐标都比这个点大。如果这个点不放这个区间，则未来可放入的那个区间比当前这个区间右端点要大，剩下的那些点中更容易选出点放入未来的那个区间。

C
=

题解：考虑U操作。对他有影响的只有L操作。那么设这个U操作的点为$x，y$，L操作的点为$tx，ty$。且L操作向左延伸到$l$。那么卡住U的L操作为$l <= x <= tx$的最小的$tx$，这个可以用线段树维护。每一个L操作完后，将$[l,x]$这个区间全部与$tx$取$min$，每次U操作单点查询即可。L操作同理。$n$过大离散话即可。

写完后看了jsy的做法：对于每一个操作，相当于将要操作的部分分成两部分。一部分就是这个问题的子问题。另一部分是这个问题的子问题并在某一方向上每个东西都加一个相同值。于是维护这个问题的左右端点，上面要全体加多少，左边要全体加多少，将这些放入一个set中，每次查询时lower\_bound一下找到对应的部分即可。代码比我自己的短多了。。。[jsy的代码](http://codeforces.com/contest/555/submission/11953007)
