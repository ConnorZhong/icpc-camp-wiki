[题目连接](http://acm.hust.edu.cn/vjudge/contest/view.action?cid=107431#overview)

Solution
========

### **A. 4600 Harvest Moon**

### **B. 4601 Letter Tree**

### **C. 4602 Partition**

题意：将一个数分成多个整数的和, 有很多种方式, 对于一个数n, 一共有f(n) =
2\^(n-1)中分割方式

例如n = 4

4 = 1 + 1 + 1 + 1

4 = 1 + 1 + 2

4 = 1 + 2 + 1

4 = 2 + 1 + 1

4 = 2 + 2

4 = 1 + 3

4 = 3 + 1

4 = 4

一共8中方式,现在跟定n,k,问在所有n的表达式中k这个数字出现了几次,例如n=4时,4出现了1次,1出现了12次

原思路：

比如n=n-4+4就是在4的各个分裂式中插入n-4，所以只要计算出对于一个数k的分裂式中i个加数的式子数即可

然后找规律+排列组合+快速密

注意：/2后取模方法是 %（2 \* mod）/2

现思路：

首先将这个数分成n个1,考虑将其中连续的k个1连成一个k的种数：

当这k个数靠边时, 有2 \^ (n-k-1)种也就是f(n-k)种

当k个1在中间时,左边有t1个1,右边有t2个1时,有f(t1) \* f(t2)种也就是2 \^
(t1+t2-2) = 2 \^ (n-k-2)种

然后特判当n = k时有1个,当n &lt; k有0个，当n = k + 1时有两个

### **D. 4603 Color the Tree**

### **E. 4604 Deque**

题意：给一个deque然后有n个数，依次进行操作，每种操作，

你可以把这个数放在deque首部，也可以放在尾部，也可以扔掉不管，

但是要保证deque中的数是非递减的。最要求deque中最长能是多少

思路1：

dp1\[i\]表示的是以i为开头的最长不降子序列，dp2\[i\]为最长不升，num1\[i\]和num2\[i\]为相应的重复的数

枚举开头，减掉重复的部分，即两个子序列中有该数个数较少的序列中该数的个数

具体操作类似于二分求LIS的方法：

从a\[n\]开始操作到a\[1\]，维护一个LIS，如果a\[i\]比LIS中最大的数还大，就添加到最后

否则就找到第一个大于a\[i\]的数的位置，把这个位置的数替换成a\[i\]

相同的数的个数用equal\_range(vec.begin(),vec.end(),a\[i\])维护，返回lower\_bound,upper\_bound两个指针

num\[i\]即等于upper-lower

递增求完后把a\[i\]取反，再做一遍即可求出递减

思路2：

分别用BIT维护最长不降、下降子序列和最长不升、上升子序列即可

BIT的update和query同时改变+-lowbit的方向即可由维护前缀改成维护后缀

维护不严格序列的方法，以不降为例：先query出&lt;=pos的最长长度，设为val，然后update(pos,val+1)

### **F. 4605 Magic Ball Game**

题意：有一颗树(1e5结点)，所有结点要么没有子结点，要么有两个子结点。

然后每个结点都有一个重量值，根结点是1。然后有一个球，从结点1开始往子孙结点走。

每碰到一个结点，有三种情况：

如果此球重量等于该结点重量，球就停下了

如果此球重量小于该结点重量，则分别往左右儿子走的可能都是1/2

如果此球重量大于该结点重量，则走向左儿子的概率是1/8，右儿子的概率是7/8

然后若干个询问（1e5次），问一个重量为x的球经过结点v的概率

思路：

离线，边走边处理，走到一个点，便处理这个点的所有询问

因为路径唯一，所以用两个BIT维护到现在左转右转经过的节点即可(dfs)

每到一个点，先查询，再更新

答案x=3\*(ls+rs)+lb+rb y=rs

注意：节点的w值要先离散化

### **G. 4606 Occupy Cities**

题意：给出n&lt;=100个城市需要去占领，有m&lt;=100条线段是障碍物，不能触碰到，有p&lt;=100个士兵可以用。

占领城市有个先后顺序，每个士兵有个背包，占领城市之后，仅能补给一次背包

问背包容量最少是多少，可以用这P个士兵完成任务，起点任意

思路：

N=n+2\*m最多300个点，预处理出这些点之间的距离：

计算几何判断两个点是否和障碍物相交，若相交，距离先处理为inf，否则就直接计算

然后floyd处理各个点之间的距离

然后二分答案，把所有的距离&lt;=答案的建边，注意只建先占领的到后占领的边

判最小路径覆盖是否&lt;=p，是答案即符合要求

### **H. 4607 Park Visit**

题意：给定一棵树，有n&lt;=1e5个节点，m&lt;=1e5个询问，每个询问给出一个K，

从树中的任意选一个顶点出发，遍历K个点的最短距离是多少？(每条边的长度为1)

思路：

设树的最长链长度为len

如果K&lt;=len，最短距离为K-1

如果K&gt;len，则走到拐点把比最长链多的点走完再返回，这样多走的为(K-len)
\* 2，总路径为len-1+(K-len) \* 2

先求出最长链长度，然后O(1)作答即可

### **I. 4608 I-number**

题意：求比x大的最小的各个数位的和为10的倍数的数，x的长度&lt;=1e5

思路：

最大不过+10，大模拟即可

### **J. 4609 3-idiots**

### **K. 4610 Cards**

Summary
=======

菜......

个人参与率低，粗略回忆...

首先shy看题意最短的C，感觉可做，便做，lwt看中间，lcy看后面，发现I可做

5min后哇一发，说题意看错。后来便与lwt讨论，具体情节不知，10min后a

后来两人去看E，shy继续坑C，慢慢找规律推出了公式，只差最后一步，此时两人发现E想错了，lwt转攻E，lcy转别题

shy一开始不想告诉lwt思路，怕误导，后来lwt说他不会做，就说了，此时最后一个公式不会算

于是lwt去算那个公式，shy检查前面有没有推错，此时已经有75人a了，lwt怀疑是不是想歪了，但是两人都想不出别的办法

后来shy知道怎么算，就去敲了，中间问了一发如何%(2\*mod)，然后交了以后tle了

三人一起看代码，代码没几行，很快锁定是n&lt;k的情况，改了以后wa了，然后看了很久无果

后来shy猜是先%mod，在%(2\*mod)的锅，想想感觉有道理，就交了，然后a了

shy去看E，H是在shy没参与的情况下a的，后来两人一起看E，换了几种思路还是错的

过了n久，shy发现新思路，另外两人整理后ac

后来F题接近正解，由于肚子饿弃疗。。。

以下是个人总结：

### shy

感觉推公式、找规律能力有了提升。。。

既然C不是太难，那么是不是当时就不应该告诉lwt自己的思路，让他自己想？

### lwt

感觉非常蛋疼 - - 模型抽象能力有点弱(Deque) 一碰到推公式就瞎了(Partition)
感觉还是只能慢慢攒题

### lcy

太憋屈了 一个题接近正解了然后没想完
