题目地址
========

[快戳我](http://codeforces.com/contest/536)

Pro.A Tavas and Karafs
======================

题意： 给定数列a，ai = A + (i - 1) \* B 定义操作"eat -
m"为选择m个不为0的ai，将其变为 ai - 1 给定Q个询问，每个询问给出L, M, T,
要求回答最大的R，满足对\[L, R\]进行至多T次“eat - M” 后，\[L, R\]变为全0
1 &lt;= A, B &lt;= 1e6 1 &lt;= N &lt;= 1e5 1 &lt;= L, T, M &lt;= 1e6

题解： 每个询问L, M, T， 一个合法的R要求满足两个约束： 1） \[L, R\]
内最大的元素不大于T 2） \[L, R\]内ai之和不大于M×T 两个条件分开处理
1）离线扫描 2）二分判断 总复杂度O（NlogN）

Pro.B Tavas and Malekas
=======================

题意：
给定一个长度为M的串T，串T精确覆盖了长度为N的串S的某些位置，这些位置用数列P给出
要求求出串S的可行方案 字符仅有小写字母集 1 &lt;= M &lt;= N &lt;= 1e6

题解：
预处理KMP的fail数组，每次覆盖时判断该前缀是否合法，如果合法暴力（不重复）覆盖即可
O(N)

Pro.C Tavas and Pashmaks
========================

题解： 将点(1/xi,
1/yi)丢到平面上，求下凸壳，并去掉一些严格劣于其它点的点，最后留在凸壳上的点都是可行解
证明： 因为耗时可以看成(1/xi,
1/yi)与（S,T）的点积，因此可行答案即是每个方向上投影最小的点，即凸壳上的点

ps : 这道题精度要求很高，long double 1e-14后才艹过去 ps2 :
其实俺用的是整数→\_→

Pro.D Tavas in Kansas
=====================

题解： 将\[dist(S, i), dist(i,
T)\]丢到二维平面上，权值为Pi，每次操作就是将横向/纵向一个半平面内的点全部取走（并至少取一个）
剩余可取的点形成一个右上角的矩形，可以用\[x\]\[y\]表示，因此DP即可
状态DP\[x\]\[y\]\[0/1\]
表示当前可取的点在\[x,y\]右上角，且是先手/后手取，能取得的最大值
然后随便优化优化就能把复杂度降到O(N\^2)

Pro.E Tavas on the Path
=======================

题解：
求答案的公式是满足结合律的，又是一个在树上的询问，很容易想到　树剖＋线段树
那个 L &lt;= Wi 的约束可以离线处理掉，之后就是询问树上某条01链的贡献
一条链的话很好搞不是么…
