**A Ants**

二维平面坐标上有$n$个巢穴，每个巢穴坐标$(x, y)$，如果一个蚂蚁在一个巢穴，那么接下来他会走到离他最近的巢穴，如果多个最近，就走到$x$最小的，如果x还相同就走到$y$小的。然后给定两个蚂蚁从不同巢穴出发，蚂蚁速度相同，问最后两只蚂蚁是否会相遇
每个巢穴出发走到的路径连起来，会发现在一个连通块上面的结点，走到最后肯定会在某两点之间来回走，也就是从同一个连通块出发的两个结点走到最后必然会相遇。那么问题就剩下如何快速找出$n$个点的最近点，这个用一个靠谱的kdtree板子你就可以求出来啦！

**B Balls and Boxes**

打表找到规律。主要是不会推。

**C Colosseo**

$N$个人，给出一个$N*N$的01矩阵，表示$N$个人两两PK谁会赢。
分成两队，一队有$M$个人，一队有$N - M$个人
先问是否两队中都满足存在一种排列，使得第$i$个人，都能打败$i$之后的每个人。然后如果存在，在问要尽可能多能把第二队里面一些人加到第一队，使得仍然满足这个条件，问最多能加几个人？
第二队里面去掉人，并不影响约束，问题在于加到第一队里面，可能破坏第一队的约束。然后发现，第二队每个人加到第一队里面，位置是唯一的，那么问题就变成第二队中选一些人出来，在不改变他们相对顺序的情况下，插入到第一队中的位置也不改变顺序的最大个数。那么其实这个问题本质上就是一个二维的最长上升子序列，然后一维排个序，一维最个上升子序

**D Distance**

给定三种操作： I x：集合插入一个x D x：删除集合里的一个x Q
x：查询集合一个y，使得d(x, y) = z
$d(x, y)$的定义为，把数字x，只能经过乘除操作变成y，最少需要几次操作
首先$d(x, y) = f(\frac{x}{gcd(x, y)}) + f(\frac{y}{gcd(x, y)})$，
$f(x)$表示x的质因子种类数。gcd只存在因子中，那么一个数的因子并不多，可以考虑从因子入手。插入一个x的时候，枚举一个x的因子d，把$f(\frac{x}{d})$统计下个数统计到d里面，然后如果个数大于1的时候就把值保存起来，由于一个数质因子个数很少，可以考虑把每种种数压成一个二进制状态存起来。删除是插入的逆操作，同理查询的时候同样枚举因子，然后在之前存下来的二进制状态上，利用位运算可以快速查询

**E Elegant Construction**

构造一发，把点的度数排个序，然后每个点往前每个点进行连边即可，如果点数不够就是无解

**F Find the Period**

**G Golden Week**

N个结点一棵树，有M个旅行家，每个人有一个目的地C，以及一个预算花费B，现在要给树的每条边定权值，
如果一个旅行家到目的地C经过的边权大于预算花费B，那么他就不会旅行，否则他就会旅行，并且经过的路径就是他的开销
你现在想赚尽可能多的钱，问一种定边权的方案

在树上，如果想赚一个旅行家的花费B，在他的祖先链上就不能定超过B权值 考
虑树形dp，dp\[i\]\[j\]表示到i这棵子树，最大的花费为j的最优解，每次转移考虑以该结点为目的地的旅行家预算大于j的个数cnt，那么转移就是
dp\[i\]\[j\] = cnt \* j + dp\[v\]\[j'\] (j' &gt;
j)，对于每个子树v需要枚举一个j'记录最大值，这样总体复杂度是N\^2M的，然而实际上这个最大值是一个后缀里面的最大值，只要每次DP转移完，在维
护一下后缀最大值，转移就可以降到O(1)了，复杂度降到(NM)

**H Hearthstone**
状压DP转移，预处理出伤害和还可以取多少张牌。伤害够时不再转移，累乘之后的全排列。

**I Ice Walls**

**J.Joint Stacks**

用两个set模拟栈，合并的时候启发式合并一下即可

**K Knights**

长度为$n$的数轴上，$1$到$n$每个位置有一个骑士，骑士初始方向可能向左或向右，一个骑士如果走到边界，就会转向，如果两个骑士相遇就会进行PK，胜率55开，问最后留下第$n$的骑士的概率
考虑DP，首先同向的骑士不会互相吃，逆向的吃完会留下一个，$dp(i, j)$表示从左往右第$i$个位置，还剩下$j$个往右走的骑士
这
样每到一个位置，如果下一骑士是右走，就转移到$dp(i + 1, j + 1)$，如果是左走，就可能吃掉$0,1,2,3,..$
全吃完个骑士，那么就是转移到$dp(i + 1,j ... 1)$上面，注意如果全吃完，最后他肯定会碰到边界返回，所以$dp(i + 1,1)$要多加一次，然后这是一个成段区间转移，并且加东西都是一样的，可以考虑利用打标记的方法优化到$n^2$

**L Lights**

先把重复的点去掉这个并不影响答案，把每个点上下左右第一个遇到的点处理出来(没有的就是边界)，问题等价于求这个四个点围成的矩形中，是否只包含这个点，扫描线树状数组即可
