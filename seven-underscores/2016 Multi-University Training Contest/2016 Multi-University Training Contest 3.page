**A Sqrt Bo**

由于开根只有5次，$2^{32}$次方才有解，所以先判断一下位数，如果在范围内就暴力开根一下

**B Permutation Bo**

考虑每个位置的贡献，枚举每个数字x，一个数左右两边选比他小的方案数为$C_{x - 1}^2$，其它数字随便排列位$(n - 2)!$（注意边界只要算一个数字），这样直接计算会乘爆掉，由于最后要除$n!$，所以过程中$\frac{(n - 2)!}{n!}$直接当成$\frac{1}{n(n - 1)}$去做

**C Life Winner Bo**

$sg(n,m)$表示还剩n行m列的胜负态(马要多考虑一个平局态)，然后王和马都可以$O(1)$转移，车和皇后转移完之后还要记录一个该行、列、对角线是否有一个必败态，然后就可以进行$O(N^2)$转移了

**D Gambler Bo**

每个位置能被周围以及自己5个位置所影响，每个位置选几次作为一个未知数，每个位置的值列成一个方程，进行高斯消元即可求出一种可行的方案，对于这题是模3意义下的高斯消元，可以利用bitset进行优化。

**E Boss Bo**

对于一个$A_i$，会把整个子树都变成坏点，那么可以考虑做dfs序，把所有$A_i$的dfs序区间的点扣掉，剩下就是好点，那么问题就是要能快速计算一个点到一个区间的点的总距离，最大值，最小值。
考虑离线版本的话，直接把询问丢到每个点里，dfs过程中，一个点往子树走，相当把到子树的距离都减1，非子树距离加1，用线段树就可以方便的维护，就可以得到每个点的信息
那么对于在线版本就要写一个带区间修改的主席树，由于这题操作只有加减操作，询问的是总和、最大最小值，因此可以打静态标记。

**F Product Bo**

考虑只有正数的情况，把序列按从大到小排序，优先队列要保证能从大到小取所有方案，每种方案表示为$(i, j, k, sum)$表示前$i$个连续的要选，中间有一个$j$，最多后移到$k$的位置，总和，那么每次往后就两种转移，把$j$进行后移，或者从$i$的结尾断开一个后移并把$j$作为最后位置。那么对于存在负数的情况下，就把正数和负数部分记录下来，每次转移就有正数和负数的一共4种转移，不过需要注意的是这样转移可能转移出同样的方案，可以加一个标记，表示上次是正数部分变换还是负数部分变换，如果负数部分变换过就不能再变换正数部分，这样就能保证方案不重复。考虑先做正数，先把负数为偶数个数的初始状态丢进优先队列做一遍，如果还没取到答案，就在把负数为奇数个数的初始状态丢进去做一遍，注意这时候优先级变成值越小越优。至于0的问题，只要把0设置成一个无穷小的数字，就可以当成正数去做了

**G Explorer Bo**

树形dp，选一个非叶子的结点做根，$dp(u, i, j)$记录到$u$结点，还剩$i$条链没有合并，
是否已经合并掉一条多余的链，一个子树如果有超过2条以上的链，肯定是合并掉更优的，到每个结点的时候令$dp(u,1,1) = 0$表示虚拟一个点给多余的链进行合并，这样完树形dp，偶数链答案为$dp(0,0,0)$奇数链答案为$dp(0,0,1)$

**H Gardener Bo**

直接维护答案。更新一个点s时，s点答案更新为单点，儿子和孙子的更新均为$delta(w)*K$，对每个点当儿子和孙子时可以预处理出这个$K$。儿子和孙子可以区间修改$delta(w)$。
对于$s$点以上的点化完式子后变为$delta(w)*W$,
$W$是和边相关的量。考虑树链剖分之后的贡献。轻链直接算，重链的贡献当修改的点在子树时计算。
全部的维护只要树状数组就可以了。 复杂度$O(nlogn)$

**I Palindrome Bo**

$left(i,c)$、$right(i,c)$分别表示位置$i$往左、往右第一个出现字符$c$的位置，那么当$a_l == a_r$时，$dp(l, r)$可以从$dp(right(l,c), lefit(r,c))$转移过来，当固定一个$l$，$r$往后移的过程中，可能构成的回文子序列长度是递增的，那么在移动的过程中记录下$dp(right(l, a_r), r)$的最大值，每到一个位置利用这个值更新$dp(l,r)$即可，但是这样直接计算的话，过程会出现一些本质相同重复计算的情况，在右移过程中，如果遇到某个位置r，它和之前$left_r$的长度相等，要把前一部分的方案值减掉。

**J Rower Bo**

贴题解。现场猜结论。

**K Teacher Bo**

鸽巢原理，曼哈顿距离最多就只有$2*m$，直接暴力最多找$2*m + 2$次就可以找出解了
