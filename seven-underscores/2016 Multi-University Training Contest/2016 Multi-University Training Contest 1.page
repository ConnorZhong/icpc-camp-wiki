**A Abandoned country**

做一遍最小生成树后树形DP。

**B Chess**

用$sg_i$表示i集合的$sg$函数值，预处理出所有$sg$的值，询问只要把对应行$sg$值异或即可。复杂度$O(2^{20})$

**C Game**

Codeforces\#53D
先假设所有距离都是曼哈顿距离.发现只有在两个点之间的路径上每行均有X,且X出现的列上单调的情况下,距离会加2.暴力枚举所有的行对.再计算列.

**D GCD**

$g(i, j)$表示i到j之间数字的最大公因子，那么满足这种性质$g(i, j) >= g(i, k)(i<=j<=k)$且$g(i, j)(i<=j<=n)$的数字种类至多为$a_i$的因子数，于是可以
进行预处理，将i定位左端点，去二分同一种类gcd出现的区间，累加答案即可。

**E Necklace**

8!枚举阴的位置，之后按照空隙做最大匹配。

**F PowMod**

按照题解补的做法 第三行少了个求和符号 降幂公式的证明（原博客已消失）
http://www.ithao123.cn/content-5288189.html

**G Rigid Frameworks**

等价于二分图左边n个点右边m个点且连通的方案数。f(i,j)表示答案。
$f(i,j) = 3^{i*j} - \sum{f(k,t) * 3^{(n-k)(m-t)} * C_{n-1}^{k-1} * C_m^t}$。
复杂度$O(n^4)$

**H Shell Necklace**

分治FFT或者FFT快速幂 以及多项式除法??

**I Solid Dominoes Tilings**

列容斥处理，之后就不考虑列的影响了。之后要处理在列被划分的情况下行不能被分割的情况。
设方案为f，无限制的方案g $f(i) = g(i) - \sum{g(i-j)*f(j)}$

**J Subway**

求出两颗树直径的中点或者树的重心(都可能有两个),然后分别求出以重心为根的树哈希值，如果两树重心哈希值一样，那么将树上点每个儿子哈希值排序，然后一一对应输出即可。

**K tetrahedron**

$o = \sum{\frac{P_i * S_i}{\sum{S_i}}}$, 其中$S_i$为$P_i$点对面面积。
