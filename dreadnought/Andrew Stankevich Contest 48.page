Andrew Stankevich Contest 48

A. A + B \[Bacon\]
==================

题解：对于一个特定的位置，决定它是否+1的是它之后第一个和不为9的位置。所以只要快速找到这个位置即可，直接倍增hash就行了。

B. Break Free \[Rowdark\]
=========================

题解：讨论题。注意到人和老虎能同时到达的点一定构成圆或者一条直线，于是按照速度大小讨论下就能知道情况：对于速度相等，直接找出中垂线就知道哪部分不可行；如果人的速度比老虎的速度慢，那么除了圆内与X轴相交的部分外都不合法；如果人的速度比老虎快，则视圆为障碍物即可，注意下切点在X轴下方的情况。

C. Covering Words with Carrying \[Lolicon\]
===========================================

题解：计数。改一下求和的顺序枚举m即可。

D. Decisions \[Lolicon\]
========================

题解：背包预处理+分治。

E. Enigmatic Matrix \[Rowdark\]
===============================

题解：爆搜打表即可。

F. Four Russians on a Tree \[Bacon\]
====================================

题解：点数不超过5的有根树一共有18种，打一个表预处理出任意两种u和v接起来（v作为u的根的儿子）的新树的编号。先枚举出哪些形态是允许的，再dp\[u\]\[s\]表示u为根，只使用合法的形态，根联通的部分的形态为v，是否可行。

G. Grundy \[Rowdark\]
=====================

题解：预处理，利用对称性，暴力跑的飞快。

H. Hardware Hashing \[Lolicon\]
===============================

题解：双层哈希。30条指令不足以二分，而所有的跳转又都是静态跳转，只能通过打表+load指令的方式来实现动态。所以先找一个模将数分成若干组，再对每组分别再找一个模形成perfect
hash，直接打表。经过实验，第一层模在比1w稍多时，第二层的表长度总和大概在1MB左右，因此这个方法可行。这道题目麻烦的地方主要在于实现它给出的汇编以及出现错误难以调试。

I. Interactive Proofs \[Lolicon\]
=================================

题解：Zero Knowledge
Proof强行出题。由于返回只有0和1，于是可以建一棵字典树，叶子代表一个确定的状态，初始时先随机一个叶子强行改成不正确的值，但除了这个叶子之外都是consistent的。因此只有当问到这个叶子的时候才会出错。可以满足题目条件。

J. Jackpot \[Lolicon\]
======================

题解：裸费用流。
