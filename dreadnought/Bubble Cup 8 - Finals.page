Bubble Cup 8 - Finals

[A. Fibonotci](http://codeforces.com/contest/575/problem/A) Lolicon
===================================================================

题解：如果是纯循环的，直接幂法矩乘即可。插入了一些杂点之后需要能够快速计算杂点之间的转移矩阵，用线段树/倍增预处理回答询问。注意两个杂点相邻的情况。

代码：[12868972](http://codeforces.com/contest/575/submission/12868972)

[B. Bribes](http://codeforces.com/contest/575/problem/B) Bacon
==============================================================

题解：LCA算法的基本使用。

[C. Party](http://codeforces.com/contest/575/problem/C) Lolicon
===============================================================

题解：显然可以先C(N,N/2)暴力然后暴力KM，然而O(C(N,N/2)N<sup>3</sup>)显然会TLE。优化的方法是考虑到KM的过程是增量过程，我们可以依次插入每一行的权矩阵并进行计算。这样就优化到了O(C(N+2,N/2+1)N<sup>2</sup>)可以AC了。

代码：正解[12881383](http://codeforces.com/contest/575/submission/12881383)
/
暴力卡时[12871714](http://codeforces.com/contest/575/submission/12871714)

[D. Tablecity](http://codeforces.com/contest/575/problem/D) Bacon
=================================================================

题解：讨论奇偶性抓两次即可。

[E. Spectator Riots](http://codeforces.com/contest/575/problem/E) Lolicon
=========================================================================

题解：需要有三个结论：1、给出一个凸包，过其上三点作圆，一定有圆可以覆盖整个凸包。2、所有这些圆里半径最大的一定可以覆盖整个凸包。3、这个最大的圆一定可以是凸包上相邻三点做出的。证明思路大体如下。1、考虑一定存在一个三点圆能够覆盖整个凸包。如果是个两点圆则令其圆心在这两点的垂直平分线上移动，一定会被另一个点卡住，并且半径更大。2、假设半径最大的圆不能覆盖整个凸包，则过圆外某点和圆上两点一定可以做半径更大的圆，这个可以只考虑四个点的情况证明。3、先取最大的圆，固定两个点，移动剩下的那个，会发现圆的半径的函数在线段的两端是单谷的，在相邻点的时候取到峰值。于是我们移动两次就容易得出一定是三点相邻了。

代码：[12871832](http://codeforces.com/contest/575/submission/12871832)

[F. Bulbo](http://codeforces.com/contest/575/problem/F) Bacon
=============================================================

题解：每个时刻一定在关键点上，处理出所有的关键点然后暴力DP即可。

[G. Run for beer](http://codeforces.com/contest/575/problem/G) Lolicon
======================================================================

题解：比较好的做法是按照等价类分层求最短路。BFS一遍得出0费的块之后可以只用再做一遍BFS。每次处理一个等价类的点并保证了先处理的前导零较少即可。

代码：重制版[12882151](http://codeforces.com/contest/575/submission/12882151)

[H. Bots](http://codeforces.com/contest/575/problem/H) Lolicon
==============================================================

题解：方法很多。统计每层点的个数或者统计不同深度的叶子个数均可。结论是C(2n+2,n+1)-1。

代码：[12863115](http://codeforces.com/contest/575/submission/12863115)

[I. Robots protection](http://codeforces.com/contest/575/problem/I) Bacon
=========================================================================

题解：$n\log^3 n$的分治是显然而好写的。可以利用前缀和来减掉一个log（思考矩形的两个log的做法，三角形一样可以化成一些奇形怪状的前缀和然后每个前缀都可以两个log求出）。
