2015 JAG Spring

[A. Balanced Paths](http://jag2015spring.contest.atcoder.jp/tasks/icpc2015spring_a) \[Bacon\]
=============================================================================================

题解：裸分治。

[B. Card Game Strategy](http://jag2015spring.contest.atcoder.jp/tasks/icpc2015spring_b) \[Bacon\]
=================================================================================================

题解：如果不求方案的话则是简单的bitset优化背包。如果直接记录NK个bitset显然是存不下的，则每10个物品存一个，求方案时暴力枚举这10个物品是怎么取的。

然而还是有些卡，则可以在取K个和不取N-K个之间取较小者，则总计算量除了4，足以飞过时限。

[C. Casino](http://jag2015spring.contest.atcoder.jp/tasks/icpc2015spring_c) \[Lolicon\]
=======================================================================================

题解：数学概率。对于P=0/50/100/&lt;50/&gt;50的5种情况分类讨论。其中0和100trivial。50和&gt;50的获胜概率可以由概率论知识计算，方案也比较容易。&lt;50的情况比较复杂。贪心暴力算出获胜概率，而方案则需要打表找规律细致分析答案的分布。与$n$和$m$的(比值的)二进制展开有关。

[D. Content Delivery](http://jag2015spring.contest.atcoder.jp/tasks/icpc2015spring_d) \[Bacon\]
===============================================================================================

题解：做了好几遍的题目，对一个固定的物品，将节点按照距离排序，则其收益可以预先算出来，最后按收益排个序即可。

[E. Cost Performance Flow](http://jag2015spring.contest.atcoder.jp/tasks/icpc2015spring_e) \[Lolicon\]
======================================================================================================

题解：费用流。费用和流量是个分段线性函数，而题目给出的是个二次函数。于是可以分段求极值。几乎不需要分数类。重温了一下时代的主流。

[F. ICPC Teams](http://jag2015spring.contest.atcoder.jp/tasks/icpc2015spring_f) \[Bacon\]
=========================================================================================

题解：容斥，瞎算一算。

[G. JAG-channel II](http://jag2015spring.contest.atcoder.jp/tasks/icpc2015spring_g) \[Lolicon\]
===============================================================================================

题解：状压dp。只需知道上一个人是谁和他没看的贴的排序即可确定顺序。注意字典序最小的限制。

[H. Kimagure Cleaner](http://jag2015spring.contest.atcoder.jp/tasks/icpc2015spring_h) \[Bacon\]
===============================================================================================

题解：非常精妙的暴力。

方法1：直接对所有问号进行折半，就变成一个简单的二维询问，随便用个$O(\log n)$的数据结构即可完成。设问号个数为$x$，则枚举量为$O(2^{x/2})$，最坏$O(2^{n/2})$，TLE。

方法2：考虑如果全是问号，则两维完全独立，可分开折半。但中间的一些不是问号的连续一段的符号会受到前一个问号的方向的影响。于是可以先暴力predict所有连续一段的初始方向，之后两维便可独立分治了。设有$y$段需要predict，每段至少确定了了两维各一个元素。则枚举量为$O(2^y*2^{n/4-y/2})=O(2^{n/4+y/2})$，最坏$O(2^{n/2})$，TLE。

balance两个方法，当$x<\frac{3n}{4}$时使用方法1，最坏枚举量$O(2^{\frac{3n}{8}})$。否则使用方法2，此时$y<\frac{n}{4}$，最坏$O(2^{\frac{3n}{8}})$。

时间复杂度$O(n*2^{\frac{3n}{8}})$。

[I. Midpoint](http://jag2015spring.contest.atcoder.jp/tasks/icpc2015spring_i) \[Lolicon\]
=========================================================================================

题解：分类讨论+FFT。由中位线的性质知，先要对于三条直线的平行情况进行分类讨论。对于有不平行的情况直接暴力。对于三条都平行且距离相等的情况需要FFT。

[J. New Game AI](http://jag2015spring.contest.atcoder.jp/tasks/icpc2015spring_j) \[Lolicon\]
=============================================================================================

题解：构造+线段树。精妙的题目。为了简化情况，先考虑所有人的dp都不同的情况。此时与最小hp差不超过c的人当中dp最小的人一定可以赢。（构造证明）然后所有能够存在一条击败链可以最后打败此人的人也一定可以赢。（构造证明）可以证明此时取出的集合正是答案。然后分析存在dp相同的情况。此时与最小hp差不超过c的人当中dp最小然后hp最小的人还是可以赢。由上面的构造可以知道此时能间接击败此人的人还是可以赢。但这一条件不再是必要的。因为dp相同有可能谁先上谁就活到最后了。（考虑所有人dp相同c巨大的极端case）设此时可胜的人的集合为X，易知X集合里的人一旦上位答案就只可能在X集合当中。要阻止此类事情的发生，必须对于X当中的每个人都存在一个不在X集合当中的人能够先上位将其挤掉。如果这个条件不满足答案就是X。否则对于去掉X的集合里，与最小hp差不超过c的人当中dp最小然后hp最小的人也可以赢（构造证明）。然后又可以推出可以间接打败此人的人还是可以赢。得到新的X集合。如此迭代直到条件不满足的X就是答案。实现可以用线段树瞎维护一下，一个log。

[K. Runner and Sniper](http://jag2015spring.contest.atcoder.jp/tasks/icpc2015spring_k) \[Rowdark\]
==================================================================================================

题解：转坐标为极坐标，发现式子特别简单，并且容易发现路径一定是走切线，于是二分下答案即可。

[L. Wall Making Game](http://jag2015spring.contest.atcoder.jp/tasks/icpc2015spring_l) \[Lolicon\]
=================================================================================================

题解：DP。裸sg。
