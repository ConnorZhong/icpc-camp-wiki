Lolicon个人刷题页面

ひみつのしけんじょう　-&gt;　[こちら](http://dreadnought.icpc-camp.org/Secret;Weapon)

Polish Algorithmic Engagements 2011
===================================

[Tulips](http://main.edu.pl/en/archive/pa/2011/tul)
---------------------------------------------------

输出15000-去重后元素个数。

[Rooks](http://main.edu.pl/en/archive/pa/2011/wie)
--------------------------------------------------

在棋盘上放尽可能多的車且不相互攻击。已经给出了一个部分方案，要求将其补全。贪心放即可。

[Unlucky](http://main.edu.pl/en/archive/pa/2011/pec)
----------------------------------------------------

旅行喝水问题。一开始有w单位的水，背包大小k单位，问走完s单位的路之后最多还剩多少水。用微分的观点来看，观察到导数是个分段线性函数，直接分段计算即可。

[Climbing](http://main.edu.pl/en/archive/pa/2011/wsp)
-----------------------------------------------------

有若干个pair(xi,yi)，限制是xi+yi=li,0&lt;=xi,yi。要使得尽可能多的yi=xi+1。贪心，维护当前还能配上的区间，能配则配。

[Journeys](http://main.edu.pl/en/archive/pa/2011/pod)
-----------------------------------------------------

一个图。边是\[ai,bi\]到\[ci,di\]这种形式给出的，求单元最短路。BFS，用线段树查找边。

[Pedestrian Crossing](http://main.edu.pl/en/archive/pa/2011/prz)
----------------------------------------------------------------

实际是问若干个开区间在映射到一个环上之后是否覆盖了整个环。注意环的端点。

[Fuel](http://main.edu.pl/en/archive/pa/2011/pal)
-------------------------------------------------

给出一棵树。可以从任意点开始，问走m步最多能访问多少个点。考虑从某一点开始，则除了最后停留的那个点到起点的那条路径上的点以外，每个被访问的点都要花费2的代价。于是找出直径长度就可以计算了。

[Plotter](http://main.edu.pl/en/archive/pa/2011/plo)
----------------------------------------------------

给出n阶[Dragon
Curve](https://en.wikipedia.org/wiki/Dragon_curve)（由于题目是在整点上，定义略有不同），再给出m&lt;=2000个+-10\^9范围内的点，问每个点在折线的哪些个位置出现。

有点难度，分为两步来解决这个问题。

第一步：观察给出的折线，找规律。此折线有若干种等价定义。从串的角度出发，重要的性质是Ln=Ln-1
L Rev(Ln-1)
其中Rev()表示将这个串翻转并把LR取反。这个可以直接看出来或者用更加容易得到的格雷码定义(i&gt;&gt;1&(i&-i))结合格雷码的对称性质得到。而这对应的几何定义是Ln是由Ln-1以其终点为中心复制一份并顺时针旋转90得到的。

另外我们发现到每个点最多出现两次，并且n&lt;=2000显然是在吓唬人。经过计算，题目中给出范围的点，最多在n&lt;=62的折线中出现（这难道是为了可以用long
long）.

第二步：由于是递归定义的，很容易想到要递归地去求解在折线的哪些个位置。有了上面的几何性质，就可以进行递归了。但直接递归显然会爆炸。我们有强烈的愿望，希望能够快速判断一个点不可能在Ln上。于是我们想到用一个矩形把Ln框起来。这个界不需要很紧，因为折线的范围是指数增长的，我们只需要保证错误的路线不会指数增长即可。

有了这两步的结果，就能很容易地AC了。但所有找规律的工作都手算还是有点困难，比赛中遇到还是要灵活打表。

[Declining Sequence](http://main.edu.pl/en/archive/pa/2011/cia)
---------------------------------------------------------------

给出长度为n&lt;=1e5的一个序列和q&lt;=1e5个询问，询问长度为p，下标字典序第ki&lt;=1e18小的严格下降子序列。

首先用树状数组容易数出以每个位置开头的长度为k的严格下降序列有多少个，超过1e18就用INF表示。后面对于每层，维护一个线段树，在线段树上找第ki大的即可。

[Double Factorial](http://main.edu.pl/en/archive/pa/2011/sis)
-------------------------------------------------------------

问mul\^{n}{x!}末尾有多少个0。n&lt;=1e18。

显然是数5的个数。考虑每个数出现了多少次列出求和式。注意要高精度。

[Trails](http://main.edu.pl/en/archive/pa/2011/szl)
---------------------------------------------------

[Vacation](http://main.edu.pl/en/archive/pa/2011/wak)
-----------------------------------------------------

给出最多三个n&lt;=5000的排列，求一个新的排列代价最小。代价定义为每个元素的新位置和它原来位置之差的绝对值与8取min。

容易想到费用流，需建3\*15\*n条边，用比较快的费用流即可。

[Automorphisms](http://main.edu.pl/en/archive/pa/2011/aut)
----------------------------------------------------------

求树的同构个数。传统的方法是找中心+树哈希，需一个log。可以使用类似拓扑排序的方法，每次处理掉一圈叶子，再结合基数排序和对递增序列的O(n)排序方法做到O(n)。

[Kangaroo](http://main.edu.pl/en/archive/pa/2011/kan)
-----------------------------------------------------

(MLE中……)
有n个区间的sequence和m个区间的询问，询问在这个sequence中和这个区间有交的最长连续子段长度是多少。一个有趣的做法是对询问建KD树，在KD树上打标记维护历史最大值。这样没有log，但常数不小。另一些做法基于分块的思想。其中一个做法是将sequence分块，对于较小长度的子段预处理出答案，用二分套lower\_bound计算答案，对于跨段的答案，需要预处理每段的前缀和后缀区间Sequence，扫描所有段计算出答案。注意这题的空间限制非常紧，需要整体二分来优化空间。
