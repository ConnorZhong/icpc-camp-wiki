[A. Decoding Baby Boos]() \[Bacon\]
===================================

并查集，每种字母c建一个代表节点rep\[c\]，当把字母u改成v时，则将rep\[u\]的父亲指向rep\[v\],而rep\[u\]新创立一个结点。

[B. And Or]() \[Bacon\]
=======================

按位暴力。

[C. A game for kids]() \[Bacon\]
================================

树上DP，f\[u\]\[c\]表示有多少条不同的路径，从u出发向下，每个点选择的都是c的倍数。
转移很简单，最后容斥即可。

[D. Flood in Gridland]() \[Rowdark\]
====================================

由线性规划的对偶定理，将约束条件转化后，容易发现每个变量都只存在于两个方程，将所有方程求和之后会得到0
≤
0，故而所有方程都要取等号；容易发现，这个方程组满足流方程的条件，故可以使用费用流求解。在得到对偶方程的解之后，有线性规划的松弛定理知（变量不等0
→ 对偶的方程取等；方程不取等 →
对偶变量等0），那些非0为指数所对应的原方程必须取得等号，故使用这些等号方程BFS一遍即可。

在网络上有看到求解之后可以使用单纯型推导中的做法，直接构造出原问题的解的方法，但目前并不能理解。

[代码戳我](/Dhaka2014D.cpp)

[E. Refraction]() \[Bacon\]
===========================

直接二分即可。

[F. Reverse Polish Notation]() \[Lolicon\]
==========================================

分类讨论+贪心。插入a一定在最前，+一定在最后。先把a和+的个数补成相同。然后记录栈中有多少个元素。遇到a加一，+减一。剪不动有两个case：

1、栈中有一个元素
优先考虑在前面加一个a最后加一个+。倘若前面没有发生过交换，代价是2。否则前面就可以不用交换，代价是1。如果交换则只会交换+和下一个位置的a代价为1。

2、栈空
这种情况只会发生在开头。不交换代价是4、交换一次代价是3或者交换两次代价是2。同样要考虑到交换次数中。

[G. Just Some Permutations]() \[Bacon\]
=======================================

DP，首先枚举前两位填的人是不是一定happy（如果happy枚举具体哪个）。这样断环为链之后可以直接dp了，dp\[i\]\[j\]\[mask\]表示“前i位已经确定，其中至少j个位置的人是happy的，\#i人和\#i+1人被使用的状态为mask”的方案数。转移是简单的，最后组合数容斥一下。

注意该题有50组，每组如果重做dp的话会很慢，需要预处理前面的dp部分，对每组只做容斥。

[H. Load Balancing]() \[Lolicon\]
=================================

简单DP。

[I. Volume of Revolution]() \[Lolicon\]
=======================================

积分模拟。

[J. Maximum Score]() \[Lolicon\]
================================

显然只要单峰即可保证答案最大。每个数字的对答案贡献等于不超过它的数字个数。方案数是除了最大的数以外的数的个数+1相乘。

[情况小结]() \[Rowdark\]
========================

这场总体来说还是可以的，一个比较明显的问题是前期过于磕磕碰碰（交一题挂一题），错误犯的也是千奇百怪，都是些边角料。中期速度不错，可能是因为准备的时间增加了，通过题目相对顺利很多，2H左右就只剩下2个题，3H多就只剩下D题。但由于这套题是一只狮子（D题）带⑨只绵羊（其他题），能反映的情况并不是很多。
