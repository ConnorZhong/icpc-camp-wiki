A:Gene Shuffle
==============

考虑i 如果pos\[i\]&gt;i 那么i应该变成i\~pos\[i\]中pos最大值
否则就是分出来一段 扫一遍就可以了

B:Top 2000
==========

dp\[i\]表示1\~i最小惩罚 那么dp\[i\]=min(dp\[j\]+cost(j+1,i))
按理说应该往前考虑60m个 可以二分出来sum&gt;m的分界点
然后用线段树求两段的min就可以了

(但是队友只考虑前3m个就过了2333

C:The Twin Tower
================

考虑dp\[i\]\[j\]表示前i层以及放好了 第i+1层状态为j时候的结果
然后就考虑空位是竖着连还是本层连就可以了

答案即为dp\[n\]\[0\]

D:Collatz
=========

简单题 看一下i*2&gt;n 的i个数以及3*i+1&gt;n的个数就可以了

E:Clocks
========

考虑二分答案后check

既然可以放下 那么肯定可以和已有的图形有三个交点
枚举三个交点在哪然后解方程check就可以了

F:Maze Recognition
==================

就是暴力把图读进来 然后bfs

G:Snooker
=========

计算任何时刻场面剩下的最大分数 然后暴力判一下就可以了

H:Pie Division
==============

考虑一个合法解 两边点的个数 一样

然后顺时针开始转 每次当遇到两个点就停下来check一下 复杂度就是n\^2了

I:Keylogger
===========

搞个链表模拟一遍就可以了

J:Wrong Answer
==============

只有横竖会交叉 然后暴力建个二分图 求最大独立集

K:Cunning Minister
==================

考虑树边只会减少 其他边只会增加 记录变化值为ci

那么如果树边i和非树边j构成了环 那么就是wi-ci&lt;=wj+cj

于是ci+cj&gt;=wi-wj

于是就变成了二分图求最大匹配 点编号就是c值

(没想到km那么快 \#L:01

首先已经到位的不用动

然后把改动的0和1两两配对 发现不交叉最好 即最左和最右配对
