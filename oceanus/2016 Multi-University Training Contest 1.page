A. Abandoned country
====================

给出一个图 求最小生成树以及树的路径长度的期望

直接求出最小生成树 然后算每条边被计算的概率即可

B. Chess
========

一个N\*20的棋盘 每次可以移动某一个棋子到他右方第一个空位

不能移动的人输 问先手是否可以获胜

因为只有20 所以可以暴力计算出每一种局面的sg值 然后就可以了

C. Game
=======

可以发现首先所有格子都可以两两到达

而且两个点的路径 最多有一个守卫挡路 所以最多答案会加2

问题就变成了统计有多少个点对 必须要绕一下 这样扫两次就可以了

D. GCD
======

给一个长度为N的序列A M次询问 询问L\~R的gcd以及有多少个区间的gcd与其相同

求区间gcd可以搞一个st表直接计算即可

我们可以发现左端点在l的区间 右端点从l到r 他的gcd值肯定是不断减小的
而且每次最小除以2

所以不同的GCD值最多有NlogN个

于是预处理出来就好了

E. Necklace
===========

有N个A类珠子N个B类珠子 有的A类珠子和B类的相邻会得到1点惩罚
问如何排列使得惩罚值最小

发现N&lt;=9 于是我们可以枚举B的排列方式 因为环装所以共有8!种

接下来就是N个A珠子向N个空里面插 可以判断插进去是否有惩罚 没有则连边
跑一次最大匹配就可以了

F. PowMod
=========

给定N,M,P

K=∑i=1..mφ(i∗n) mod 1000000007

求k^k^k^k^.... %p

设K=f(n,m)

由于欧拉函数为积性函数 那么f(n,m)=∑i=1..mφ(i∗n)

因为n=p1*p2*...

考虑p1 那么f(n,m)=∑i=1..m φ(i∗n)

f(n,m)=∑i=1..m i%p1!=0 φ(i∗n/p1)*φ(p1)+∑i=1..m/p1 φ(i∗n)*p1

所以

f(n,m)=∑i=1..m φ(i∗n/p1)\*φ(p1)+∑i=1..m/p1 φ(i∗n)

所以f(n,m)=(p1-1)\*f(n/p1,m)+f(n,m/p1)

递归计算可以得到k 接下来就是算k^k^k^k^k...%p

可以知道a\^b % c = a\^(b%φ(c)+φ(c)) %c

于是递归计算即可

G. Rigid Frameworks
===================

等价于询问左边N个点 右边M个点 有K条边的联通二分图的个数

由gyz论文可知

假设满足P性质的图有F\[N\]个

满足P性质且联通的图有G\[N\]个

设T\[N\]=F\[N\]-G\[N\]

则T\[N\]=sigma i=1..n-1 g(i)*c(n-1,i-1)*f(n-i)

于是此题可以设f\[i\]\[j\]\[k\]表示左边i个点 右边j个点
中间k条边的联通二分图个数

每次考虑左边最后一个点所在的联通二分图的块容斥一下就好辣

H. Shell Necklace
=================

f\[n\]=sigma(i=1...n)f\[n-i\]\*a\[i\]

不难发现f为卷积形式 直接cdq+fft冲过去就好辣！

I. Solid Dominoes Tilings
=========================

如果没有要求不存在分割线 那就是简单的轮廓线dp

f\[i\]\[j\]表示考虑到第i个格子 他前面m个格子放了还是没放

然后xjb转移一下就好辣

现在考虑如何计算不存在分割线的

那么我们可以考虑枚举竖着哪些位置是分割线 这里2\^m枚举容斥一下

接下来我们就要算横着没有分割线的了 这样才能保证上一步容斥的正确性

和上上题类似 此时我们只要考虑dp\[i\]表示前i行没有横着分割线的方案书
然后考虑最后一行到第j行没有分割线 第j行有了 然后容斥掉就可以啦

M. Subway
=========

问题就是判断是否树同构

发现树的重心最多两个 找一下暴力当做树根 然后树hash一下就可以了

N. tetrahedron
==============

公式题(
