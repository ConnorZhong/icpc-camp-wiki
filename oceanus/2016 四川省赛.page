A.Nearest Neighbor Search\[zsc\]
================================

枚举到每个顶点每条边以及映射到每个面的点即可。

B.Odd Discount\[zsc\]
=====================

考虑两种组合 如果他们相同 他们会有2\^(n-1)种方法都被取到

如果不同 他们会有2\^(n-2)种方法都被取到

于是问题就变成了计算每一对的贡献啦

C.Eight Queens
==============

D.Longest Common Subsequence\[zsc\]
===================================

我们考虑dp\[i\]\[j\] 表示前i段 匹配到aj 最长公共子序列长度

那么他能从dp\[i-1\]\[k\]转移过来
为dp\[i\]\[j\]=dp\[i-1\]\[k\]+maxlen(a\[k+1..j\],b\[i\])

maxlen即为每个数字在两个串中出现次数的最小值的和

那么我们考虑枚举maxlen的值

那么当dp\[i\]\[j\]为dp\[i-1\]\[k\]+maxlen 我们显然要让k最大
因为dp\[i\]数组肯定单增

然后我们可以two-points 因为当j增加时候 k肯定也不减

于是我们总复杂度为O(n\*sigma(k))

E.Coins\[zsc\]
==============

分情况讨论 只有一种很好算 有1 2都能凑 有1 2 3都能凑 只有1 3看1的个数
只有2 3看2的个数

F.Floyd-Warshall\[zsc\]
=======================

求出生成树 然后把新加的边上的点单独抽出来求到每个点的最短路
然后每次枚举x y在哪里集合然后过去即可

G.Road History\[zsc\]
=====================

我们考虑一个联通快
如果是二分图（没有奇环）那么这个联通快答案就是左边点数\*右边点数

如果不是二分图 那么有奇环 考虑x到y 本来是奇数那没问题
是偶数的话我们去走一遍奇环回来也是奇数了 所以任意一对点对都是可行解

所以用并查集维护是不是二分图 以及二分图两边分别有多少个点就可以了

H.Around the World\[zsc\]
=========================

树形dp 考虑f\[i\]表示i子树的答案
那么考虑转移就是首先把i到他孩子的边都选好位置 然后再把孩子的顺序排好
想清楚很好写

I.Longest Increasing Subsequence\[zsc\]
=======================================

n！枚举所有的大小顺序 有了大小顺序直接dp过去就可以了

J.Matrix Transformation\[zsc\]
==============================

用个双向链表连起来就都是O(N)的啦
