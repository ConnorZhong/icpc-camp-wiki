A. A Boring Question
====================

推一下公式可以得到答案为1+m^1+m^2+...+m\^n

所以答案就是(m\^(n+1)-1)/(m-1)

B. A Simple Chess
=================

首先考虑从(1,1)马字形走到(n,m)的方案数 可以发现就是解一个二元一次方程组

横着走X次竖着Y次 那么方案数为C(X+Y,X)

考虑障碍物的话就是容斥一下 dp\[i\]表示从(1,1)走到第I个障碍物的方案数
那么dp\[n\]=sum-dp\[i\]\*f\[i\]\[n\]

f\[i\]\[n\]表示从第I个障碍物到第N个障碍物的方案 由于范围很大
lucas一下就可以了

C. A Simple Nim
===============

可以发现

sg\[8x+7\]=8x+8

sg\[8x+8\]=8x+7

其他sg\[x\]=x

D. Magic Number
===============

E. Master Zhu
=============

F. Stabilization
================

考虑枚举X 实际上两个数的大小只由他们最高的不相同的位决定

那么处理出来f\[i\]\[j\] 表示以第I位决定胜负的数 第J位为0/1 1/0等有多少个
就可以用20\^2复杂度算出每个X的答案

但是太慢了 可以考虑把X最高位变为Y 那么发现除了最高位外 下面的值不变
上面的值可以直接算 于是考虑直接递归计算每个X的值即可

G. This world need more Zhu
===========================

考虑dfs序列的话 子树询问转化为区间询问 直接上莫队就可以了

两点路径的询问 树上莫队就可以了

H. To My Girlfriend
===================

考虑dp\[i\]\[j\]\[0/1/2\]\[0/1/2\]表示前i个数 取得集合的sum为j
已经确定选了几个数 确定不选几个数的方案数

直接暴力转移就可以啦

I. Up Sky,Mr.Zhu
================

队友补的树套树做法 不是很清楚QAQ

J. Windows 10
=============

方案肯定为down一阵 然后停一下或者加1 然后再down下去

那么记录下停了几次 最后答案少加这么多就可以了

K. Zhu’s Math Problem
=====================

考虑数位dp dp\[i\]\[j\]\[f1\]\[f2\]

表示后I为 j表示a b c d的第I位能不能任取 1为可以任取0不能任取

f1表示a+c和b+d的关系 f2表示a+d和b+c的关系

0表示a+c的第I+1位比b+d小1

1表示a+c的第I+1为和b+d相等

2表示a+c的第I+1为比b+d大1

3表示已经确定a+c比b+d大

然后暴力枚举转移就可以啦
