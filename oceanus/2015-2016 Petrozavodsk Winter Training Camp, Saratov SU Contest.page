A.Three Servers
===============

发现ti&lt;=30非常小 那么其实不难发现答案非常小

那么我们考虑dp\[i\]\[j\]\[k\]表示前i个数 第二大比最小的大j
比最大的小k是否可行

那么由i j k可以解出来现在三个变量分别为多大
然后暴力枚举i加在哪个就可以了

这样的话由于答案小 那么j k我给了500的量 确实也过了。。

方案倒着搜回去就可以了

B.Game on Bipartite Graph
=========================

C.Black and White Board
=======================

D.Catenary
==========

E.Evacuation Plan
=================

F.Empty Vessels
===============

G.Maximum Product
=================

从高位向低位看 要不取最高位 要不然少一 后面全取9 扫一遍就好

H.Biathlon 2.0
==============

经典问题 求个凸包然后二分斜率就可以了

I.Archaeological Research
=========================

其实第I行每个数x 实际上的含义即为i+1\~x-1每个数都和x不一样
字典序最小即为i+1\~x-1最小的没出现的数 即为mex函数

那么用个权值线段树记录每个数出现最后一次位置就可以了

J.Sockets
=========

考虑二分答案 假设现在插了x个用电器 那么肯定是b最大的x个用电器
而且插得顺序肯定是按照b从小到大插

那么我们每一层单独考虑 先算出来每层需要多少个插头位置

接下来对于接线板 我们肯定是a大的插在前面 只要这一层够了就接接线板就好了
check一下就好了

K.Toll Roads
============

枚举删除的链的端点 把他当做根来dfs

那么要考虑的就是dfs到一个点x时候
从根到这个点的路径上边变成0后整个树的最长链

那么就是分几种情况了 x子树的最长链 x子树外的最长链
x子树的一个单链+x外的一个单链

所以要维护子树外最长链 子树内最长链 子树外最长单链

而且防止重复 要记录三个最长单链 两个最长链 然后维护下注意细节就可以了
