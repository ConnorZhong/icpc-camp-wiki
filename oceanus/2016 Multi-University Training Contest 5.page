A. ATM Mechine
==============

可以发现只要log(k)次就可以做到最优（类似于二分） 所以w到15左右就够了
直接dp\[i\]\[j\]表示上限i 可以错j次的期望然后就可以了

B. Cycle
========

可以发现如果两个前缀串是循环相等的
那么肯定是A串的后缀和B串的前缀的最大匹配 所以跑一次kmp算出这个值
然后看剩下的是不是相等就可以了

C. Divide the Sequence
======================

贪心就行

D. How Many Triangles
=====================

枚举钝角三角形的钝角顶点，以他为基准点进行极角排序，然后考虑有多少个点夹角&gt;90度
直接枚举二分就行了

E. Interesting
==============

可以发现如果求出来以下两个数组

f\[i\] 表示以i结尾的所有的回文串的左端点的下标和

g\[i\] 表示以i开始的所有的回文串的右端点的下标和

那么答案就是sigma(f\[i\]\*g\[i+1\])

这两个数组可以发现 我们用马拉车得到以每个点为中心的最长回文串
它覆盖的区间为给f数组和g数组区间加上一个等差数列 两次差分就可以了

F. Interval
===========

G. K-wolf Number
================

直接数位dp 把前面几位取得值压进一个状态就可以了

H. Level Up
===========

考虑一个节点 原来权值为X 现在变成10W 对总答案的影响为从他到根的路径上面
中位数&gt;=x的 变成了原来中位数后边的一个数

这个过程就好做了
如果我们知道每个点他的子树里面的中位数和中位数后面的一个数 就dfs下来
用一个树状数组记录&gt;=x的中位数后面得数的值 每次就是一个sum的过程

求中位数和后面一个数 我们考虑每个点维护一棵权值线段树 然后就是线段树合并
类似于主席树那样合并就行了 然后check答案就方便了

I. Permutation
==============

J. Prefix
=========

把每个串插入到一个trie中 每个前缀都相当于trie中的一个节点
那么问题就变成了询问区间内有多少个不同的数 主席树经典应用

K. Two
======

dp\[i\]\[j\]表示第一个串以I结尾 第二个串以J结尾时相似的串对数
转移就是a\[i\]=b\[j\]时候的一个前缀和

L. World is Exploding
=====================

容斥一下就可以啦
