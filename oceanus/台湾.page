A.As Easy As Possible\[zsc\]
============================

对于给定的串进行预处理 求nxt\[i\]\[j\]表示i之后2\^j位应该是谁
然后倍增就可以了

B.Be Friends\[zsc\]
===================

考虑并查集 每次找集合x到其他集合的最长边 这条边肯定会出现在最大生成树
然后将其合并

于是合并完k次后集合大小最小是2\^k 最多重复log次

然后找最大边 就是在trie上面找和自己颜色不一样的
记一个最大颜色最小颜色就ok啦

C.Coprime Heaven
================

D.Drawing Hell\[zsc\]
=====================

最后肯定是个三角剖分 三角剖分的边数是一定的 必然为3\*n-m-3 m为凸包上点数
判断奇偶就可以了

E.Easiest Game
==============

F.Fibonacci of Fibonacci\[zsc\]
===============================

找个循环节然后快速幂

G.Global Warming
================

H.Hash Collision\[zsc\]
=======================

我们考虑长度为i的 hash值差mod m为i的有f\[i\]种

长度为j的 hash值差mod m为i的有g\[i\]种

那么把f\[i\]-&gt;f\[i\*(p\^j)%mod\]

然后f\[i\]和g\[i\] 卷一下就是长度为i+j的解了

于是可以倍增求解 我FFT精度不够 NTT干过去了

I.Increasing or Decreasing\[zsc\]
=================================

简单的数位dp f\[i\]\[j\]\[k\] i位 当前为j k表示增还是减 然后就可以啦

J.Just Convolution\[zsc\]
=========================

我们直接枚举答案 答案肯定是2n-2-&gt;0

然后考虑和为这个的 往答案数组里面扔

这样就是balls and bins 期望不会分析但是很快就是了w
