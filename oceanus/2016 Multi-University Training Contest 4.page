A. Another Meaning
==================

先跑一遍KMP 算出来在串中哪些位置出现了多义词

接着直接dp 若位置i出线 则为dp\[i\]=dp\[i-1\]+dp\[i-len\]
否则dp\[i\]=dp\[i-1\]

B. After a Sleepless Night
==========================

首先我们发现对于一个合法情况 每个值都是一个在树上的链
且不会分叉（即一路向上）

于是得到无解的情况为：分叉 儿子比父亲权值大

接下来我们发现跟肯定是权值为n的 于是顺着拉出来为N的这个链
两边谁做根其实都可以 但是要字典序最小 肯定让编号大的在下面填N
编号小的做根

接下来我们就从叶子向上 拉出来一条条链

现在问题就变为了有一些值 要分配到一些点 每个点被分配的值有个上限
问如何分配字典序最小

那么直接把权值和bound从大到小排序 每次分配值找个编号最大的扔过去就完辣

C. Bonds
========

首先发现 对于一个bond 肯定是把原图分成了两个联通快

那么我们2\^n枚举每一个子图 判断是不是联通

对于一个N个点的联通子图 我们肯定可以找到一个点 删完他剩余还是联通

那么就得到一个2\^n\*n的方法 算出所有子图是不是联通

于是就得到了所有bond的情况

接下来算答案 对于一个子图 肯定是链接两边的点的边答案+1

这个不好处理 于是我们可以算每条边有多少次不被算

即为多少个联通子集包含这条边 然后就是做一个高维前缀和辣

D.Filling
=========

E. Lucky7
=========

直接容斥就行 每次相当于容斥加上mod 7=0这个条件 然后就是裸地容斥了

F. Substring
============

后缀自动机 对于字母用挡板分开就可以啦

G. Treasure
===========

考虑树的dfs序

我们把一条x\~y的路径用(dfn\[x\],dfn\[y\])表示

那么考虑一个宝藏 钥匙在a 箱子在b lca为c

四种情况：

（1） a!=c b!=c

那么起点在a的子树 终点在b的子树即可 即为(l\[a\],r\[a\])
\~(l\[b\],r\[b\])这个矩阵

（2） a=c b!=c

那么考虑a-d-.....-b

起点不在d子树即可 那么即为(1,l\[d\]-1)\~(l\[b\],r\[b\])
(r\[d\]+1,n)\~(l\[b\],r\[b\])这个矩阵

(3) a!=c b=c

考虑b-d-.....-a

终点不在d子树即可 即为(l\[a\],r\[a\],1,l\[d\]-1)
(l\[a\],r\[a\],r\[d\]+1,n)这个矩阵

(4) a=b=c

此时发现含a的路径的矩阵很多 反过来考虑不含他的 这些的和最多是N个矩阵
于是可以先算进答案 再减去即可

然后就是做个扫描线求矩阵最大值辣

H. Turn Game
============

I. String problem
=================

考虑对于一个数字 第一次取他代价为b\[i\] 之后每取一个代价为a\[i\]

考虑w\[i\]\[j\]+w\[j\]\[i\]
相当于取了i和j能获得价值为w\[i\]\[j\]+w\[j\]\[i\]的收益

于是考虑最大权闭合子图 左边m个点表示m条边 中间n个点 代表n个位置
右边10个点代表0\~9

那么左边每个点和源连接即为收益 左边点和中间对应点连接无穷大
中间每个点和右边对应点连接无穷大的边 和汇连接即为a\[i\]

右边每个点和汇连接b\[i\]-a\[i\]

跑一次最大流即可

J. The All-purpose Zero
=======================

答案肯定可以把所有0都取了

那么考虑nlogn的lis做法 每次碰到0相当于把整个栈向右移一位并+1

那么考虑后面为-1即可 这样做一遍lis 加上0的个数即可

K. Where Amazing Happens
========================

暴力

L. Bubble Sort
==============

考虑整个过程 每个数肯定是向右移到最右 然后开始向左移

向右移次数即为右边有几个比他小的 然后左移到应该在的位置

统计记录一下即可
