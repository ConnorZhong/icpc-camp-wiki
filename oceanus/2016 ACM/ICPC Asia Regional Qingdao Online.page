A:I Count Two Three
===================

可以预处理出来所有满足条件的数 每次询问就是lower\_bound一下了

B:Cure
======

数列是收敛的 预处理到收敛就可以了

C:Family View
=============

我们只要把要屏蔽的词建一个ac自动机 然后就是把串在ac自动机上面跑
跑的时候得到以这个位置为结尾的最大匹配单词长度

接下来就变成了给出n个区间 这些区间要变成\* 差分一下最好看被覆盖的就好了

D:Tea
=====

考虑如果L=0 那么最好的方法肯定是给第一杯1 给第二杯2
如果有剩余继续给第一杯2这样下去

否则应该是一开始给每一杯(L+1)/2 然后继续这样2下去即可

E:Balanced Game
===============

奇数yes偶数no

F:The Best Path
===============

欧拉回路一个点一进一出度数-2 然后获得一次收益

于是每个点贡献为(度数/2)mod 2 \*a\[i\]

然后欧拉回路的起点会多一次枚举即可 欧拉同路的起点终点会多一次
这样跑下来就可以了

G:Sort
======

显然可以二分 然后二分得到的k在(n-1)%(k-1)!=0的情况下先把多出来的并起来
然后每次选最小的k个合并就可以了

如果用优先队列会t 考虑合并出来的大小依然有序 于是搞两个序列就可以了

H:XM Reserves
=============

I:Tower Defence
===============

考虑以下几个东西很好处理

子树内最大直径 次大直径 字树内距离最远的距离 次远距离 第三元距离
到字数外最大距离

然后就是xjb dp一下就好啦

J:Herbs Gathering
=================

按照性价比从大到小 然后加个最优性剪纸就搜过去了

K:Barricade
===========

求出原图的最短路径图 就是问这个图的最小割了

L:Eighty seven
==============

考虑不同的询问最多也就50 \* 50 \* 50个 考虑这些询问 每次可以50 \* 87 \*
10 / 64 dp出来 预处理暴力即可

M:String
========
