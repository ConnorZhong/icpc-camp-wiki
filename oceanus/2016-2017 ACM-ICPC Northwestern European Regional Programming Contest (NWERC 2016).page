A.Arranging Hat
===============

类似于数位dp 考虑f\[i\]\[l\]\[r\]\[maxw\] 表示考虑到了第I位
L\~R得数还没有做到递增 这时候第I位的最大值是maxw时候最少要改多少次

考虑转移 首先第一种就是f\[i\]\[l\]\[r\]\[maxw-1\]

第二种就是考虑现在的一段 x\~r的第i位变成maxw l\~x-1的第i位&lt;=maxw

然后就暴力枚举这个x
此时为f\[i\]\[l\]\[x-1\]\[maxw-1\]+f\[i+1\]\[x\]\[r\]\[9\]

记录下转移 然后paint回来就可以了

B.British Menu
==============

缩完点是个DAG 然后每个点中有&lt;=5个点 直接考虑dp\[x\]\[y\] 表示从x出发
他这个点中经过了y状态的这些点之后 最长路的值

然后暴力dp一下就可以了

C.Careful Ascent
================

读懂题就是解个方程了QAQ

D.Driving in Optimistan
=======================

E.Exam Redistribution
=====================

贪心显然是最好的 从最达到最小的顺序走就好了

F.Free Weights
==============

二分答案 然后把&lt;=二分值得都移除了 看剩下的是不是都连续就好了

G.Gotta Nudge 'Em All
=====================

H.Hamiltonian Hypercube
=======================

递归算下格雷码的值就好

I.Iron and Coal
===============

预处理出来三样东西：每个点到煤矿的最短距离 每个点到铁矿的最短距离
1到每个点的最短距离

那么考虑最后肯定是从1开始走 然后走到某个点分叉了 所以枚举这个分叉点
答案就是1到这个点的距离+到煤矿的最短距离+到铁矿的最短距离

这么搞一下就可以了。。预处理都是BFS就好了。。

J.Jupiter Orbiter
=================

长的就像个网络流

于是考虑建图 建立超级源 对于每次下载

先是新建q个点 从源到所属队列连一条下载量的边

然后再新建q个点 每个队列和他对应的队列连一条队列容量的边

然后从后面这q个点 向代表这次下载的点连一条inf的边
然后下载的点到汇连一条下载量的边

最后还要从后面这q个点 向下次下载的点连一条inf的边 表示留在队列内的下载量

然后跑个最大流 如果等同于总下载量 那么就是possible 否则是impossible

K.Kiwi Trees
============

我尽力读了 还是没读懂=w=
