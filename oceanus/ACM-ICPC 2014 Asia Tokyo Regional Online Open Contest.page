A. Bit String Reordering
========================

简单题

B. Miscalculation
=================

简单题

C. Shopping
===========

走的路径肯定是往前走一段路到x 然后回头走 然后往前走再回头

我们发现第二次回头肯定是到x之后 要不然不如一口气走到头再回头

那么我们维护一个东西 若从x+1之后所有点都不用再回到x
那应该在x回头去访问前面的就可以了

D. Space Golf
=============

枚举弹地几次就可以得到抛物线的开口 接下来计算每一个抛物线至少要多高
这样取一个最小值就可以了

E. Automotive Navigation
========================

把交通图建出来 然后暴力bfs模拟在每个点 每个时间点 面朝哪里就可以了

F. There is No Alternative
==========================

求一个最小生成树 然后考虑删掉上面的每条边看最小生成树的权值有没有变大
变大了就是不可替换的

G. Flipping Parentheses
=======================

考虑翻得如果是左括号 那么相当于现在整个括号区间多了一个右括号
我们要把右括号翻成左括号 明显翻最左边的右括号是合法的

于是搞个线段树 维护最左的右括号即可

若翻得是右括号 那么现在要翻一个左括号 我们考虑把括号序列左括号看成+1
右括号看成-1 那么维护整个区间的前缀和
把一个左括号翻成右括号就是给后面所有前缀和-2

由于要合法 所以不能出现负数 于是就要找最靠左的位置
从他开始每个前缀和都&gt;=2 这个东西线段树也可以维护 于是就解决啦

H. Cornering at Poles
=====================

I. Sweet War
============

考虑dp\[i\]\[j\]表示i..n的糖果 获得j的甜蜜度时先手需要领先对手多少能量

那么不吃第I块糖
dp\[i\]\[j\]=min(dp\[i\]\[j\],max(dp\[i+1\]\[k\]+1+r\[i\]+1,1)) k&gt;=j

吃第I块糖 dp\[i\]\[j\]=max(dp\[i\]\[j\],-dp\[i+1\]\[k\]-r\[i\]+1) k&gt;
sum\[i..n\]-j

答案为最大的j满足dp\[i\]\[j\]&lt;=A-B

J. Exhibition
=============

队友说类似于最小乘积生成树那样做了 我还是没太懂QAQ

K. L\_{infinity} Jumps
======================
