A.Checking the Calendar
=======================

差别是0 2 3都可行

B.Batch Sort
============

枚举换的两个列 然后再check每一行就可以了

C.Ray Tracing
=============

还是把原矩阵扩大成四个 然后这样就是看2*n *a +2*m *b =y-x 的a的解了

exgcd解一下就可以了

D.Dense Subsequence
===================

可以发现如果a b都用的话 那肯定先把所有a都用了
这样的话从小到大枚举每个字母 看看现在是不是满足条件
如果是了再看这次选最少的当前字母

肯定选满足条件的最靠后的 然后这样下去就可以了

E.Goods transportation
======================

不难发现就是个最大流模型 但是范围太大了

考虑最大流等于最小割

由于这个图比较特殊 不难想到dp求这个最小割 dp\[i\]\[j\]表示前i个点
j个和s相连的最小割

于是dp\[i\]\[j\]=min(dp\[i-1\]\[j\]+j\*c+p\[i\],dp\[i-1\]\[j-1\]+s\[i\])

然后就可以啦

F.Uniformly Branched Trees
==========================

无根树的话我们看树的重心

N为奇数只有1个 N为偶数最多两个

然后我们考虑dp dp\[i\]\[j\]\[k\]表示大小为i的有根树 j个儿子
最大的儿子siz是k的方案书

那么dp\[i\]\[j\]\[k\]=sigma(dp\[i-t\*k\]\[j-t\]\[k-1\]\*c(dp\[k\]\[d-1\]\[k-1\]+t-1,t))

答案就是dp\[n\]\[d\]\[n/2\]

偶数的话算重的为两边都是n/2的时候会算重
减去c(dp\[n/2\]\[d-1\]\[n/2-1\],2)就可以了

G.Xor-matic Number of the Graph
===============================

考虑每个联通快 我们把所有的环的权值都搞出来 然后消出来一些基

然后每个点记录根到他xor和 然后就是枚举每一位 看基有多少种方法让他为1
有多少方法让他为0 接着相当于枚举两个不同的点
看他们这一位是0还是1然后这样算一下就可以了
