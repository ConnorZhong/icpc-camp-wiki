A.Minimum’s Revenge\[zsc\]
==========================

肯定是1和其他连最优 所以就是2+3+...+n

B.Prediction\[zsc\]
===================

我们可以先对于树dfs 求出来根到i的所有边在原图构成的生成树有用的边
最多n条

于是这个是n\*m的复杂度

然后对于询问 暴力合并这n条边bfs一下就可以了 复杂度是nm+sigma(k)\*n

C.Mr. Frog’s Problem\[zsc\]
===========================

只有A B 符合条件的

D.Coconuts\[zsc\]
=================

暴力把特殊点的行和列拽出来离散化暴力并查集就可以了

E.Mr. Frog’s Game\[zsc\]
========================

只有同一边界的和相邻的可行 check一下就可以了

F.Auxiliary Set\[zsc\]
======================

发现坏点总数很小 考虑只考虑坏点

那么坏点怎么样会变成好点呢？

他的众多儿子里面 有两种对他是有用的

(1)好点

(2)子树含有好点的坏点

于是只对这些点dfs 如果他儿子有&gt;=2个有用的点 他就是好点了

G.Birthday Gift\[zsc\]
======================

最后肯定是一个凸包 我们枚举最下边的那个点s

然后对于剩下的点进行极角排序 我们考虑dp

dp\[i\]\[j\]表示考虑到了最后取了第i个点 一共包含了j个点时候的最短长度

dp\[i\]\[2\]=dist(s,i) 然后考虑转移连了i j这条边 那么考虑s i
j包含了now个点 于是dp\[i\]\[k\]可以转移到dp\[j\]\[k+now\]

这样是n\^3的dp 加上枚举所以复杂度是n\^4

H.Basic Data Structure\[zsc\]
=============================

可以发现只要是最后有0 他肯定把前面的变成1了
于是只用看他后面还有几个1就可以了

于是搞个set维护所有0的位置 每次check最后一个0在哪就可以啦

I.GCD\[zsc\]
============

首先考虑以x结束的所有段的gcd 这些最多有log段

我们搞个线段树 求区间gcd那种

每次考虑以x结束的段 在线段树上面二分就可以把这log段都可以搞出来

于是原来段的所有答案都可以算出来啦

然后我们考虑修改

修改后我们在这个线段树上 可以求出来一个东西
叫做以x结束的所有段和以x开始的所有段

这样都是log范围的 我们暴力修改后 暴力算着log\^2种情况就可以了

J.Mission Possible\[zsc\]
=========================

我们考虑枚举速度v 这样的话就能知道恢复了几次

然后发现 只要第一枪没死 最后一枪没死 最后时刻还活着 就能一直活着

这样的话我们得到了h和r的关系 发现代价函数关于r是单调的

于是我们check一下 r取0和取a两种时候 取个较小值就可以了

K.Backpack on Tree\[zsc\]
=========================

对于询问离线 对于每个子树单独回答

考虑每个子树 我们把所有东西先拽出来 发现体积很小 只到5 我们于是考虑贪心

按照性价比进行贪心 贪心后 暴力取出来&gt;=t的第一组解

但是这样不一定是最优的
我们要考虑扔出去一些前面的换一些后面的性价比不如他的进来

这就是dp了 做两次dp 前缀里面扔掉sum的最小价值
以及后缀里面扔掉sum的最大价值

由于体积都很小 所以枚举这个sum到70左右就差不多了 暴力merge一下就可以了
