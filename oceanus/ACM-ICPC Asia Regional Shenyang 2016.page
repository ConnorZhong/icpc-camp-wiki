A Thickest Burger\[wht\]
========================

答案即为2\*max(a,b)+min(a,b)

B Relative atomic mass\[wht\]
=============================

按照题意计算个分子质量就可以了

C Recursive sequence\[zsc\]
===========================

我们考虑维护 f\[i-2\] f\[i-1\] 1 i i\^2 i\^3 i\^4

则通过一次矩阵惩罚既可以转移到f\[i-1\] f\[i\] 1 i+1 (i+1)\^2 (i+1)\^3
(i+1)\^4

于是矩阵快速幂就可以得到答案了

D Winning an Auction
====================

E Counting Cliques\[zsc\]
=========================

我们枚举每个团里面标号最小的元素 然后在他的邻居中选择出s-1个点
然后check就可以了

于是大力搜索剪枝 bitset快速check就可以过啦

F Similar Rotations
===================

G Do not pour out\[wht&ckg\]
============================

首先二分角度 然后计算出来水的体积进行比较(直接积分公式?)

然后得到角度计算截面面积(simpson?)

H Guessing the Dice Roll\[zsc&wht\]
===================================

首先建一个ac自动机 然后把N个串插进去 得到每个状态的转移后继

由于出现了一个串就结束 于是如果一个状态为终止状态就不参与转移

于是迭代若干次后必然收敛到答案 我计算了该矩阵的2\^30幂 然后就过了

I The Elder\[wht\]
==================

不难发现是一个斜率优化的模型 只是换到了树结构上面

于是按dfs那样维护一个栈 存放当前凸包情况
唯一麻烦的就是回溯的时候要把凸包recovery

于是记录下来搜索时候对于凸包的改变 然后暴力改就可以了
复杂度不知道有没有保证

J Query on a graph\[zsc\]
=========================

其实不难。。就是好麻烦

考虑简单的一棵树的情况 我们通过BFS得到一个BFS序列
那么一个点他的儿子在序列中必然连续 孙子在序列中也必然连续

于是这时候距离一个点为0的就是自己 为1的就是父亲 儿子们 为2的就是孙子们
父亲的父亲 父亲的儿子(除去自己)

于是搞个线段树就可以轻松搞定了

现在相当于多了一个环 然后我们可以这样处理

先把环找出来 算出来每个点的左邻居L与右邻居R 然后现在可以看成是好多棵树
但是他们的根被穿成了一个环

然后我们还是BFS 这时候显然儿子和孙子什么的还是连续的 这时候再进行考虑

首先距离为0的还是自己

距离为1的 考虑x是否在环上

(1) 在环上 那么距离为1的就是儿子们 和他的邻居L R

(2) 不在环上 那么距离为1的就是儿子们 和他的父亲

距离为2的 考虑x是否在环上

(1) 在环上 那么就是孙子们 以及邻居L的儿子们 邻居R的儿子们
    以及**L的L和R的R**

需要注意此时左边的左边有可能和右边是一个节点 于是会算重
我是记录下环的siz然后讨论一下就好了

(2) 不在环上 那么就是孙子们 父亲的儿子们(除去自己)

这时候要考虑父亲在不在环上 如果不在那就是父亲的父亲 在就是父亲的L R

于是分别讨论下 线段树搞搞就可以了

K New Signal Decomposition
==========================

L A Random Turn Connection Game
===============================

M Subsequence
=============
