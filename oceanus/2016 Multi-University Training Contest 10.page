A.Median
========

注意到给出的数组为sorted 那么分情况讨论下就可以了

B.Hard problem
==============

推公式题

C.Captain is coding
===================

D.Death Sequence
================

我们考虑编号为0,1,...,n-1

那么第一轮死的为k的倍数 第二轮编号为i的人 新的编号就为i-(i/k+1)

注意到重新标号后即为新的游戏了 那么就可以递归下去了

所以考虑f\[i\]为第i个人第几轮死 g\[i\]为第i个人在死的轮次是第几个死的

那么i%k==0的话 f\[i\]=0 g\[i\]=i/k+1

否则 f\[i\]=f\[i-(i/k+1)\]+1 g\[i\]=g\[i-(i/k)+1\]

求出来后再算一下每轮死了几个人 这样就得到了整个死亡序列 输出答案即可

E.Road
======

问题等同于求每段路最早哪个时刻要用 最晚哪个时刻要用

这东西搞个线段树就好了 每次从l到r有车走即为给区间求min和max

接下来得到了每段路在哪些时间开启 然后差分一下求个答案即可

F.Counting Intersections
========================

考虑把水平线段当做插入 竖直线段当做查询做一个扫描线即可

那么插入为单点修改 查询为区间求sum 搞个树状数组就好了

G.cjj's string game
===================

考虑最简单的dp dp\[i\]\[j\]\[0/1\]表示前i位 当前结尾匹配j位
0/1为是否已经找到长度为m的lcs

那么把后两位压到一个状态 就是简单的矩阵快速幂了

H.Cube again
============

I.Stone game
============

J.Lucky E
=========

考虑每个节点 他子树中可能的最大值必然是连续的
我们维护这个可能最大值区间的概率分布

那么考虑两个这种概率分布的合并 也是简单的问题 暴力合并就好

不难发现这种合并只有祖先孩子关系要合并
而且这个祖先孩子必然都被攻击到才有合并的必要

一共只有3000次攻击 那么只会合并3000次
而且这个连续的最大值长度也是3000数量级的

暴力合并就可以啦

K.Water problem
===============

按照题目模拟就可以了
