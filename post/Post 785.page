# UESTC 1577 Joyful Palindr0me

[UESTC 1577](http://acm.uestc.edu.cn/#/problem/show/1577)：定义一个字符串 $S$ 的回文程度等于 $S$ 的本质不同回文子串个数。例如 aa 的回文程度是 $2$，aba 的回文程度是 $3$。对于长度为 $N$、字符集大小为 $M$ 的所有字符串，求它们的回文程度之和对 $10^9 + 7$ 取模的值。

数据范围：$1 \leq N \leq 100, 1 \leq M \leq 10^9$

[skywalkert wrote on 2018-03-02T07:29:09]

---

这个题是去年校赛柱爷的防AK题.
大体思路是把指数级的$2^n$的暴力容斥转化到DP上来求解.
把状态作最小表示法会发现状态数并不多,我的实现大概就是map<vector<int>,int>这样暴力转移的,可能存在一定的常数问题.
也可以先把状态搜出来标号后再转移(大概是柱爷的方法).

[xiper wrote on 2018-03-03T10:44:23]

---

@xiper#5594 惊了…我一直卡在最小表示下回文串的数量会达到 Bell(50)，好想麻烦您讲解一下 palindrome border 的情况为什么会那么少呢…

[skywalkert wrote on 2018-03-03T17:04:54]

---

@skywalkert#5596 这个感觉有点像 rng 那个子串计数……

[ftiasch wrote on 2018-03-03T17:44:10]

---

@skywalkert#5596 抱歉我也不知道为什么数量会那么少.~~(大力出奇迹)~~

[xiper wrote on 2018-03-04T15:11:31]

---

@xiper#5598 您好，我想了一个比较暴力的方法，复杂度比较尴尬，不知道是否思路走偏了，还请指正。

考虑某个回文子串 $T$ 对答案的贡献，则需要计算 $T$ 在多少种长度为 $N$、字符集大小为 $M$ 的字符串 $S$ 中出现至少一次。注意 $T$ 在 $S$ 中的出现位置可能有重叠，但在知道了 $T$ 的所有 Border 之后，$S$ 的数量也就确定了，换句话说， $S$ 只与 $T$ 的 Border 集合有关。于是我决定尝试枚举 $T$ 的 Border 形态，再统计有多少 $T$ 满足这种形态，每个这样的 $T$ 会对多少个 $S$ 产生贡献。

- 枚举 Border 集合：不妨设 $T$ 的 (Palindrome) Border 的长度从小到大依次是 $l_0, l_1, \cdots, l_m$，其中 $l_0 = 0, l_m = |T|$ 作为边界情况。一个有效的 Border 集合对于任意的 $i = 1, 2, \cdots, m - 1$ 要么有 $l_{i + 1} > 2 \cdot l_i$ 要么存在 $j = 0, 1, \cdots, i - 1$ 使得 $l_{i + 1} = 2 \cdot l_i - l_j$，而且当 $l_{i + 1} - l_i$ 是 $l_i - l_{i - 1}$ 倍数时必须有 $l_{i + 1} = 2 \cdot l_i - l_{i - 1}$。按照这样的规则可以不漏地枚举到所有 Border 集合，似乎 $l_m \leq 100$ 的情况不超过 $5 \cdot 10^5$ 种。
- 统计合法 $T$ 数量：Palindrome Border 集合限制了位置的等价、不等价关系，其中不等价关系较难处理，尝试用容斥解决。利用只考虑等价情况算出的方案数减去其他也（至少）满足该类等价情况的 Border 算出的方案数，就是当前 Border 算出的方案数。为了完成这个似乎需要写一个高维前缀和，还在撕烤中……
- 统计有效 $S$ 数量：考虑容斥计算不产生贡献 $S$ 的数量，则至少包含 $k$ 个 $T$ 的 $S$ 对数量的贡献是 $(-1)^k$，令 $f(x)$ 表示 $S$ 的前 $x$ 个位置已经确定时其中 $T$ 的贡献之和， $g(x)$ 表示总长为 $x$ 的连续重叠的 $T$ 所有方案产生的贡献值之和，每次加一段 $T$ 或者加一个任意字符即可。

目前卡在第二部分了（哭

[skywalkert wrote on 2018-03-09T03:45:41]

---

手写 hash 过去了（黑人问号.jpg

[skywalkert wrote on 2018-03-09T12:23:24]

---

> @skywalkert#5602 Like

呃，感谢回答，说实话我不太懂字符串的那套Border理论，对于前面的那个有效数量的证明就略过不谈了~~(暴露了自己字符串只会暴力的事实)~~
不过大概感觉我们的容斥计算似乎有点不同，我来仔细讲讲我的容斥如何实现：
1. 首先可以枚举对答案产生贡献的回文串的长度$L$,产生重复的情况只可能是相同长度的串.
2. 对于一个枚举的长度$L$,现在的处理关键是要去掉重复的计数,那么可以暴力的$2^{n-L+1}$来枚举这个串的出现位置,当然一个显然的问题就是这些出现位置可能会产生一些重叠(~~否则就是个很简单的问题了~~),解决重叠的方法暴力的做法是维护一个$O(N)$的$DSU$,不妨有$t$为联通块的数量,之后有式子:
$$\sum_{S,|S|\geq 1}(-1)^{|S| - 1} \cdot m^t$$
3. 接下来需要一点观察,对于一个$L$而言,考虑那个暴力容斥的实现,一些后缀被枚举要满足条件后,做的事其实是将覆盖在某个位置上所有满足条件的位置的$DSU$连起来.
4. 接下来的做法就是把上面的过程转化到实际的$dp$过程中去,对于一个$L$只需要维护一个$O(L)$的$DSU$而不是一个$O(N)$的$DSU$,有$dp(i,j,k)$表示考虑了前$i$个位置,前一次选择的$Suffix$距离$i$的距离为$j$,$DSU$的状态为$k$的方法数.
5. 考虑$dp(i,j,k)$的转移,考虑第$i$个$Suffix$是否选择,若不选择,再看第$i$个位置是否被前一个选的$Suffix$盖住,如果盖住了,则这个位置的字符一定能由$O(L)$的$DSU$表示,否则这个位置的字符可以任选,对答案的贡献为$m$,如果选择了第$i$个$Suffix$,只需要将两个$Suffix$之间重叠的部分的$DSU$并起来,期间用最小表示法维护好就行了.

以上大概就是我的做法,可能讲的有点奥妙重重,建议看下代码.

附上自己的代码(没有常数优化,会TLE 15): https://paste.ubuntu.com/p/VtqyyH7rBB/

Update: 实际咨询了一下柱爷,柱爷的方法似乎和我们两的方法还是有一点细节上的不同(柱爷的代码只跑了1800ms).

[xiper wrote on 2018-03-09T16:27:06]

---

