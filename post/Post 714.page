# CCPC 2017 网络赛题解

免责声明：本题解由 @ftiasch @sd_invol  @zimpha 提供，非官方题解！

---
# 1001.  Vertex Cover

题意：有一个贪心算法求最小顶点覆盖是每次选出度数最大的点然后删去，输出一个图使得这个算法跑出来的答案是你给出的答案的三倍及以上。

题解：

构造一个二分图，设左边有 $n$ 个点，标号是 $1,2,..., n$。对于每个 $i \in [1, n]$，都在右边新建 $\lfloor \frac{n}{i} \rfloor$ 个点，每个点都选择左边的 $i$ 个点连 1 条边，使得左边每个点最多只被多加了一条边。这样构造完成后可以发现贪心的做法会把右边那 $n \log n$ 个点当做一个覆盖集，实际上只需左边的 $n$ 个点即可。对于题目的要求可以设 $n = 80$。

# 1002. Party

题意：给出 20 * 20 的二分图，点有标号。10 组询问，每组询问一个 $g$，表示只考虑标号是 $g$ 的倍数的子图，求非空顶点的子集 $V$ 的数量，使得存在一个匹配盖住 $V$.

题解：每个询问分开解决。假设 $V$ 是由左边的 $X + Y$ 组成的，其中 $X$ 在左侧，$Y$ 在右侧。使用广义的 Hall 引理，可以证明只要 $X$ 可以被某个匹配盖住，$Y$ 也可以被某个匹配盖住（不需要是同一个匹配），那么 $V$ 也可以被某个匹配盖住。

所以，只需要 $2^{20}$ 枚举 $X$ 的顶点自己，跑匹配就行了。聪明一点的话可以 dfs 枚举，维护增广路。


# 1003. Friend-Graph

题意：判定一个无向图是否有三个点的团或者三个点的独立集。

题解：Ramsey theorem，n >= 6 直接输出 Bad 否则暴力。

# 1004. A Secret

题意：给定两个串，求其中一个串 $s$ 的每个后缀在另一个串 $t$ 中出现的次数。

题解：把两个串都 reverse 一下，给 $t$ 做个 KMP 之后让 $s$ 在 KMP 出来的结果上跑一边就好了。

# 1005. CaoHaha's staff

题意：在笛卡尔坐标系下，画一个面积至少为 $n$ 的简单多边形，每次只能画一条边或者一个格子的对角线，问至少要画几条。

题解：如果一个斜着的矩形长宽分别是 $a, b$，那么它的面积是 $2ab$。最优解肯定是离 $\sqrt{\frac{n}{2}}$ 很近的位置。想想 $n=5$ 时答案为什么是 $7$ 然后在那个小范围内枚举一下就好了。

# 1006. Subsequence Count

题意：给出 01 串，要么询问某个区间内不同的 01 子序列数量，要么把区间翻转。

题解：先考虑怎么算 $s_1, s_2, \ldots, s_n$ 的答案。设 $dp(i, 0/1)$ 表示考虑到 $s_i$，以 $0/1$ 结尾的串的数量。那么 $dp(i, 0) =dp(i - 1, 0) + dp(i - 1, 1) + 1$. $1$ 也同理。
那么假设在某个区间之前，$dp(i, 0/1) = (x, y)$ 的话，过了这段区间，就会变成 $(ax + by + c, dx + ey + f)$ 的形式，只要用线段树维护这个线性变化就好了。

# 1007. Palindrome Function

题意：...

枚举$i$之后就是计算区间$[L, R]$内在base $i$下回文数的个数，直接dp就好了。

# 1008. The Karting

题意：线段上有 $n$ 个点，你要选 $m$ 个点组成一个环，代价是相邻两个点的距离 + 转弯的惩罚，问最大的代价。

题解：从左到右考虑 $dp(i,chosen, parts)$ 表示考虑到 $i$，已经选了 $chosen$ 个点，左边有 $parts$ 个连通块（肯定是若干条链）。然后考虑如果选点 $i$，因为是个环，所以肯定 $i$ 肯定是一进一处。讨论一下进出的方向：

(1) 如果是从左边进来，又从左边出去。那么对答案的贡献就是 $+2x[i] + turn$. 同时，也会连通块 -1.

(2) 对称地，如果从右边进来出去，那么贡献是 $-2x[i] + turn$. 同时多一个连通块（它自己）。

(3) 如果左进右出（或者反过来），那么没有任何影响。

注意最后一下要把环闭合，有个特别的转移。


# 1009. The Designer

题意：（看图）

题解：用 http://en.wikipedia.org/wiki/Descartes%27_theorem .

看上去需要解二次方程，实际上这个二次方程的两个根就是左右两个圆的大小。那么我们用 vieta 定理，就能得到连续 3 个圆的一个线性关系，用这个线性关系递推就好。

# 1010. Graph Of Zhuper

题意：...

题解：令$f(n)$表示$n$个点带标号的连通图数目$g(n)$是$n$个点带标号的无向图数目，那么$g(n)=2^{n(n-1)/2}$，$f(n)=g(n)-\sum\limits_{k=1}^{n-1}\binom{n-1}{k-1}f(k)g(n-k)$。分治FFT就可以算出每个$f(n)$。

令$h_d(n)$是带标号$n$点简单无向图且每个连通块大小是$n$倍数的方案数，那么显然答案就是$\sum\limits_{d|n}\phi(d)h_d(n)$。

构造多项式$F(x)=\sum\limits_{i=1}^{n/d}f(id)x^i$，那么$G(x)=\sum\limits_{i=0}^{\infty}\frac{F^i(x)}{i!}=e^{F(x)}$的$x^{n/d}$的系数就是$h_d(n)$。搞个多项式$exp$就好了。

# 1011. Convolution Layer	

题意：...

题解：枚举了最外层的三个 $\sum$ 之后，可以发现里面是一个经典的问题：给一个大矩阵和小矩阵，求小矩阵能放的每个位置和对应位置叠上的大矩阵的一个函数。做法的话因为字符集只有 2 所以首选 bitset，把 -1 看作 1，1看作 0。先搞出大矩阵每一行的 bitset，和小矩阵串起来的 bitset，因为只有 121 位所以可以直接用 __int128。然后首先枚举列，把每行的对应位置上 11 个 bit 扣出来，挨个拼成一串再和小矩阵的 bitset xor 就好，复杂度就是那个七重循环再除个压位的常数。


[ftiasch wrote on 2017-08-19T09:11:30]

---

04KMP感觉有问题
比如这组样例
1
baabaa
caabaa

KMP算出来21，但是手算怎么算都是23。。。

[fhy_tan wrote on 2017-08-19T09:22:16]

---

@fhy_tan#5246 就是。。你跑完一遍算出次数后是要沿着 fail 上去累计的。

[sd_invol wrote on 2017-08-19T09:30:18]

---

@sd_invol#5247 
当然有沿着fail累加，但是KMP的fail的步子比较大，会计数计少，我那组样例就是针对KMP出的。。。

[fhy_tan wrote on 2017-08-19T09:39:12]

---

Umm.. 不是很懂，至少我的代码对你的例子结果是对的。

https://gist.github.com/Sd-Invol/c031483714eefbba5ce4b6f07be35b8d

[sd_invol wrote on 2017-08-19T09:42:21]

---

可以给个1009的代码嘛？。。。。想对拍一下。。感谢!

[zhuynan wrote on 2017-08-19T09:53:07]

---

@sd_invol#5249 确实正解,表示比赛时被数据放过(:

[Qinghui wrote on 2017-08-19T10:00:29]

---

@zhuynan#5250 
```
#include <cstdio>
#include <cmath>
#include <algorithm>

const double pi = acos(-1.0);

int main() {
#ifdef LOCAL_JUDGE
    freopen("09.in", "r", stdin);
#endif
  int T;
  scanf("%d", &T);
  for (int cas = 1; cas <= T; ++cas) {
    int R1, R2, N;
    scanf("%d%d%d", &R1, &R2, &N);
    if (R1 < R2) std::swap(R1, R2);
    double k1 = -1.0 / R1, k2 = 1.0 / R2, k3 = 1.0 / (R1 - R2);
    double ret = (R1 - R2) * (R1 - R2);
    --N;
    double k4 = k1 + k2 + k3;
    for (int i = 0; i < N; i += 2) {
      double r = (1.0 / k4) * (1.0 / k4);
      if (r < 1e-15) {
        // printf("%d\n", i);
        break;
      }
      ret += r;
      if (i + 1 < N) ret += r;
      k3 = 2 * (k1 + k2 + k4) - k3;
      std::swap(k3, k4);
    }
    printf("%.5f\n", ret * pi + 1e-9);
  }
  return 0;
}
```

[ftiasch wrote on 2017-08-19T10:53:30]

---

@ftiasch#5252  谢谢~

[zhuynan wrote on 2017-08-19T11:27:44]

---

@sd_invol#5249 
嗷。。。谢谢，懂了，我沿着fail累计的姿势不对，原来是这样计数T_T

[fhy_tan wrote on 2017-08-19T11:35:24]

---

1006的状态转移方程不是很理解。对于dp(i,0)=dp(i−1,0)+dp(i−1,1)+1，不知道是如何解决相同的串重复计数的问题。
比如说1010，会出现0在dp(2,0)中算了一次，dp(4,0)中又算了一次的情况吗？
也许我完全理解错了。。。。。

[xushu wrote on 2017-08-19T11:44:51]

---

@xushu#5258 呃。。。我本来想写成

$(dp(i - 1, 0)) + (dp(i - 1, 0) + dp(i - 1, 1) + 1) - (dp(i - 1, 0))$ 的，但是又觉得太罗嗦了。

可以看成这样 3 个部分：

(1) 是原来就有的 $0$ 结尾的；
(2) 是原来所有串（再加一个空串），加第 $i$ 位的 $0$，这样就得到了在第 $i$ 位出现的串；
(3) 第三部分是算重的，你这么想，一个串如果用了 $(i - 1)$ 位的 $1$ 能造出来，我用个 $i$ 位的 $1$ 不是更好嘛！所以原来的都又被算了一次，就减掉了。

[ftiasch wrote on 2017-08-19T12:02:02]

---

@ftiasch#5259 谢谢叉姐！现在理解了。对于重复出现的01串，只统计当前阶段下最后一次出现的情况以避免重复计数。

[xushu wrote on 2017-08-19T12:27:12]

---

@xushu#5258 
另外一个简单的解释是，
对于前 i-1 个字符中以 0 结尾的子序列，加上 s[i] 这个 0 之后得到结尾连续 0 的个数 >=2 的子序列，
对于前 i-1 个字符中以 1 结尾的子序列，加上 s[i] 这个 0 之后得到结尾连续 0 的个数 ==1 的子序列，再补上单独一个 0，
容易分析这样是不重不漏的。

[quailty wrote on 2017-08-19T15:16:07]

---

@quailty#5264 多谢qls指点，Orz。╰(*°▽°*)╯

[xushu wrote on 2017-08-19T15:21:33]

---

1011的题解可以再说得详细点吗>_<
枚举的外层三个循环是n,m,x吗？然后转化的那个问题也没有看懂——这两个大小矩阵指的是什么，难道是读入的两个矩阵吗？

[jiangshibiao wrote on 2017-08-20T08:08:08]

---

@jiangshibiao#5268 可以再好好看一下最内层的两个求和在干什么

[sd_invol wrote on 2017-08-20T09:24:22]

---

@ftiasch#5245 
叉姐，1009那个笛卡尔定理是  $(k_2+k_3+k_4-k_1)^2 = ( k_2^2+k_3^2+k_4^2+k_1^2 )$吗？
然后对于$k_4$的解，用韦达定理，$x_1+x_2 = 2(k_2+k_3-k_1)$,对吗？
然后你给的代码把$k_1$已经看成负数了，看不懂为啥第4个圆是$k_1+k_2+k_3$,然后接下来半径怎么通过$2(k_1+k_2+k_4)-k_3$推出……QAQ

[Azson wrote on 2017-08-20T09:56:52]

---

@Azson#5270 一开始上下是对称的，所以$x_1=x_2$，于是第四个圆就是$k_1+k_2+k_3$了，接下来就根据韦达定理一直往后推就好了。

[zimpha wrote on 2017-08-20T10:28:22]

---

@zimpha#5271 不是除了前3个其他都是对称的吗？韦达定理得出的是x1+x2=2(k2+k3+k1)吗？这样的话后面的算法不都是ki = k1+k2+k（i-1）……？

[Azson wrote on 2017-08-20T11:49:33]

---

@Azson#5272 你可能没有发现程序里面的i += 2，上下是一起算的，实际上算的半径是第2, 4, 6, 8, ...那些。

[zimpha wrote on 2017-08-20T11:59:47]

---

@zimpha#5273 
哦，那个我知道，因为对称，只要在n里面都加了进去，我意思还是求下一个K(i),突然我好像看懂了后面的X1 != x2,而其中一个就是上一个的K值……谢谢！

[Azson wrote on 2017-08-20T12:18:11]

---

@ftiasch#5245 叉姐，1002题解里面的那个广义Hall引理是怎样叙述的呀？？？

[YaoBIG wrote on 2017-08-24T03:33:51]

---

@YaoBIG#5278 wiki 搜 tutte theorem. 

[ftiasch wrote on 2017-08-24T03:54:29]

---

@ftiasch#5279 谢谢叉姐！不过对于证明好像还是没有什么思路啊T T

[YaoBIG wrote on 2017-08-24T10:22:38]

---

@YaoBIG#5280 提供一个 [proof sketch](https://drive.google.com/file/d/0B_ObIuMDImMFT29VS2pXd2JUSGM/view?usp=sharing)

[quailty wrote on 2017-08-24T12:03:45]

---

@quailty#5281 谢谢dalao！

[YaoBIG wrote on 2017-08-24T13:36:51]

---

叉姐，请问1010求多项式exp的时候FFT精度问题怎么解决啊？

[zsq1120141935 wrote on 2017-10-05T14:13:43]

---

@ftiasch#5279  叉姐，请问1010求多项式exp的时候FFT精度问题怎么解决啊？

[zsq1120141935 wrote on 2017-10-05T14:21:35]

---

@zsq1120141935#5429 没精度问题啊？

[ftiasch wrote on 2017-10-06T05:38:47]

---

@ftiasch#5430 模数很大的话直接做FFT会损精度吧？我在做第一部分分治FFT求f(n)的时候把数拆成高位低位两部分去做卷积，结果是精确的，但是如果要做多项式取对数取指数的话，中间有一些对做完DFT后的序列的运算，如果还是拆成高低位感觉很复杂，求教T_T

[zsq1120141935 wrote on 2017-10-06T09:29:08]

---

@zsq1120141935#5431 垃圾[代码](https://gist.github.com/zimpha/e54eaf9228d1ddc677e8a8391613a58d)，仅供参考

[zimpha wrote on 2017-10-07T07:11:37]

---

@zimpha#5432 谢谢dalao

[zsq1120141935 wrote on 2017-10-07T07:48:27]

---

