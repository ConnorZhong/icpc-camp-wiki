# Shenyang 2015 H Chessboard

题目链接:[LINK ](http://acm.hdu.edu.cn/showproblem.php?pid=5516). 没啥思路, $O(N\^{3})$, 倒着推, 可以搞么? 求教.

[yuzhou627 wrote on 2015-10-31T12:25:17]

---

咱维护一个 $c\[i]\[j]$ 表示 $(i, j)$ 上面现在有多少个棋子，初始的时候 $c\[i]\[j] = 1$。

真空情况下，每次移动就是把 $c\[i]\[j]$ 平移一下，那么不用真的移动，只要记一个偏移量就好了。考虑障碍，其实就是会导致棋子的合并，那么每次只要考虑 $2000$ 个（障碍 + 某个边界），把对应的格子合并就好了。

[ftiasch wrote on 2015-10-31T13:42:41]

---

搬运

>维护每次操作后，棋盘上能到达(x,y)的所有起点的集合。对于每次操作，大部分点都会向相应的操作移动，只有少部分点保持不动（边界上的点和障碍周围的点），保持不动的那些点就和其他点发生了合并集合的操作。由于障碍和边界上的点就2000个，所以每次操作都可以暴力合并集合。

[sd_invol wrote on 2015-10-31T13:45:32]

---

懂啦, 谢谢!

[yuzhou627 wrote on 2015-10-31T14:21:07]

---

H: [难度6]

初始，每个可以开始走的位置自己是一个集合，即每个“起始位置”自己属于一个集合，我们要求出每个“起始位置”的“结束位置”。之后一个指令一个指令，依次考虑。假设当前考虑的指令是R，就是向右走。

考虑某一个障碍物(x,y)，那么指令R之前，能够走到位置为(x,y-1)和(x,y-2)的“起始位置”集合会合并。因为指令R进行之后，(x,y-2)->(x,y-1),(x,y-1)->(x,y-1)，就是说从此以后这两个集合一定会到达一样的“结束位置”。如果指令R前，所有的指令在一起的效果是起始位置增加(totx,toty)，那么指令R前，到达(x,y-1)的“起始位置”集合，用名称pair(x-totx,y-1-toty)来表示，指令R前，到达(x,y-2)的“起始位置”集合，用名称pair(x-totx,y-2-toty)来表示。

考虑指令R后的指令序列时，若还没碰到新的障碍物，减去新的totx,toty得到的“起始位置”集合依然是正确的。而碰到障碍物的情况都是会特殊处理，保证减去totx,toty能够得到正确的“起始位置”集合。

时刻保持着，当前名称pair(x'-totx,y'-toty)的起始位置集合能够在当前时刻到达(x',y')。

不过考虑每个障碍物时，只涉及到了pair(x0-totx,y0-toty)和pair(x1-totx,y1-toty)，而不会有两个障碍物考虑的(x0,y0)或(x1,y1)中能有相同的，即不会有冲突。复杂度可以做到O(N×N)。

最后每个起始位置，算了一下Father。但是实际上fa[]构成一棵树，很容易O(N×N)做到求出每个起始位置的Father。

[AHdoc wrote on 2015-11-01T09:43:43]

---

那要怎么去记录走到（i，j）点的集合？只记录偏移量的话在指令操作偏移量下，还要加上这个点遇到障碍产生的偏移量

[beihai2013 wrote on 2015-11-03T01:30:00]

---

@beihai2013#2390 推荐使用并查集……

[ftiasch wrote on 2015-11-03T01:42:18]

---

@Varona#2392 貌似我问了一个很low的问题……谢叉姐~

[beihai2013 wrote on 2015-11-03T02:17:08]

---

@Sd_Invol#2330 保持不动的点也可能不发生合并集合的操作，那这个时候对于这个集合偏移量就发生变化了，这样通过偏移量来找到达（x，y）的集合要怎么去实现？

[beihai2013 wrote on 2015-11-04T07:26:32]

---

@beihai2013#2426 保持不动的点最多只有 2k 个，暴力维护一下就行

[ftiasch wrote on 2015-11-04T07:28:41]

---

@Varona#2427 意思是一个点如果遇到障碍，要么发生合并集合的操作，要么就原地不动？那假设当前这个点是不动的，下一次更新的时候不是要把这个不动的信息传递给它下一个走到的点……感觉很难维护的样子

[beihai2013 wrote on 2015-11-04T07:32:57]

---

@beihai2013#2428 我似乎不是这个意思。。

我个人觉得。。发生合并的两个点，至少有一个是不动的。所以说。。每轮你只要 for 一遍所有障碍（原来的障碍 + 一个边界），看看它对应的方向上是不是有一个点。。如果有的话，再看看那个方向旁边有没有一个点挤过来。。这样就好了，不用记任何东西。

[ftiasch wrote on 2015-11-04T07:37:12]

---

@Varona#2429 额……之前不是说用记录一个偏移量的方式找这个障碍对应方向上的点吗，这样就不用维护所有集合，所以我就想当一个点不动且没有发生合并时会对偏移量做一个修正……所以最后的意思是每个集合暴力走一遍，然后遇到障碍的合并一下？

[beihai2013 wrote on 2015-11-04T07:41:20]

---

@beihai2013#2430 我感觉你没有完全理解我的意思（只是感觉）。。不动的当然要修正啊。。有啥问题么。。

[ftiasch wrote on 2015-11-04T07:45:32]

---

@Varona#2431 ……确实没理解的感觉，我表达能力也有问题，再容我想一想……恩恩，不动的时候是要修正……问题就是修正了以后，下一次怎么把修正的值传下去？因为是有一个总体的修正值，然后对于每个集合本身对这个总体的修正值又有一个修正。 比如    
OO*
        OOO
先有一个R操作，(1,1)和(1,2)合并。再来一个R操作，没有发生任何合并，但是(1,1)这个集合对于总体的偏移量产生了一个修正值。那么下次假设操作为D，(2,2)这个点集合应该为(1,1)，而(1,2)这个点已经没有达到它的集合了。这时候怎么把这个对总体偏移量的修正值传下去咧~

[beihai2013 wrote on 2015-11-04T07:49:58]

---

@beihai2013#2432 

对于每个点（或者你说的集合。。。总之就是一些并到一起的点）记录一个 $(x, y)$ 表示它自认为的坐标。。然后有一个全局的 $(dx, dy)$ 表示整体的偏移量。。那么一个点**实际**的坐标应该是 $(x + dx, y + dy)$ 。比如说整体右移的话，那么就要把 dy++，但是有一个点会不动。。那么就把它自己的 y--，这样就做到了。。大家移动一格。。但是有人不动的效果。

然后比如说你现在要看 $(a, b)$ 这个格子有没有点。。那么实际上就是应该去有没有点自己的坐标是 $(a-dx, b - dy)$。

[ftiasch wrote on 2015-11-04T07:55:48]

---

 @Varona#2433 666秒懂……谢谢叉姐~

[beihai2013 wrote on 2015-11-04T07:58:26]

---

