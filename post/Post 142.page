# NEERC 2012 Moscow Subregional D Darkwing Duck

题意：给出字符串 $s_1s_2\dots s_n$，$q$ 次询问 $(l_i, r_i)$ 查询字符串 $s\_{l\_i} s\_{l\_i + 1} \dots s\_{r\_i}$ 中字典序最大的子串。特别地，如果 $u$ 是 $v$ 的前缀，那么 $u < v$。$(n, q \leq 5 \times 10\^5)$

[题目链接](http://codeforces.com/gym/100685/problem/D)



三年了，一直不会做，求解……

[ftiasch wrote on 2015-10-04T14:22:04]

---

以下做法是我口胡的：
字典序最大的子串，答案肯定是某个后缀。
考虑使用线段树来维护区间内的答案，每个节点记录该区间内字典序最大的后缀是哪个串的哪个后缀。
线段树区间合并的时候，需要快速比较两个后缀的字典序，可以把$n$个串从左到右拼接起来以后，建立出后缀平衡树，后缀平衡树可以在$O(n\log n)$的时间内构造完毕，并能在$O(1)$的时间内比较两个后缀的字典序大小。
于是通过后缀平衡树的$O(1)$询问来进行线段树的区间合并，线段树部分的复杂度为$O(q\log n)$。
这个做法的空间复杂度为$O(n)$，且是在线的。

[Claris wrote on 2015-10-04T15:16:45]

---

@Claris#1444 容我斗胆问一句……您是不是看错题了？

[ftiasch wrote on 2015-10-04T15:21:27]

---

我是题解的搬运工...先附上新鲜AC的[代码](http://paste.ubuntu.com/12689160/), 我比较懒, 直接写了hash, 没用后缀xxxz之类的高级货.

按照右端点从小到大离线处理所有询问. 假设我们现在处理到了端点$r$, 令$ans_i$是询问$[i,r]$的答案, 容易发现$ans_i$显然是一段段相等的数, 并且是单调递增的, 于是我们可以开一个set维护$ans_i$的值, 对于某个$[l,r]$的答案直接在set里面lower_bound下$l$就好了.

考虑当$r \rightarrow r+1$时, 这个set的变化. 借用叉姐的说法, 对于两个后缀$s[i..n] < s[j..n](i < j)$, 令他们的lcp为$l$, 那么在$r$到$j+l$为止, $s[i..r] > s[j..r]$, 我们不妨称$i$伴随$j$, 同时当$r=j+l$的时候, 显然$i$要从这个set里面删掉, 由于一些后缀伴随着$i$, 那么当$i$删掉的时候, 那些伴随$i$的, 以及伴随伴随$i$的, 都要递归地删掉. 于是当$r \rightarrow r+1$时, 具体变化是这样的, 把$i < r+1, s[i..n]<s[r+1..n]$的那些$i$标记一个删除时刻, 同时记$i$伴随$r+1$. 事实上只需要开个单调递增的栈来维护这些后缀, 那么$s[r+1..n]$只需要和栈尾那些小于它的后缀比较就好了, 比较完直接出栈, 因为现在得到的时刻是$i$最早被删除的时刻, 其他都不是特别重要. 搞完这些后, 把那些删除时刻是$r+1$的删掉, 然后处理右端点等于$r+1$的询问就好了. 复杂度大抵就是$O((n+Q) \log n)$.

[zimpha wrote on 2015-10-05T12:21:36]

---

@zimpha#1488 代码鲜嫩可口，好吃！

[ftiasch wrote on 2015-10-05T12:37:09]

---

这题的idea好像看到过。强行在线维护后缀数组喽？

[fancycoder wrote on 2015-10-06T14:47:43]

---

