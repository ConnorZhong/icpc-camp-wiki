# 萌新求助。。有懂FFT的大神吗。。。

事情是这样的。。我对FFT不是很熟，这两天由于一些原因好好学习了一下写这个，发现了一些情况。。
有一份用实数FFT计算整系数多项式在模p（其实不论素数还是合数都可以）意义下的乘积的代码，用的double，在我的13寸mbp上乘两个10w次多项式用时110ms，乘400w次的多项式用时4.5s，后者拍了几百组还没拍出错。本机没有测试double下更长的乘法，因为xcode的linker罢工了。
在另一台机器（E5-2650 v3 @ 2.30GHz）上10w次用时60ms，另外试了试开long double做更长的乘法，目前试到26800w还没有出错，懒得继续等了，看上去int以内都不会有问题。
以上的模数都是1000000007。
代码在这里https://github.com/fotile96/Z_m-PolyMult 。这个现象真的太奇怪惹！

[fotile96 wrote on 2016-04-28T11:13:59]

---

其实我只是来送板子的，虽然确实还有不少不清楚的问题。
这个实现就是普通的FFT乘法加了两个Trick，一个是选定一个m，对于0..p-1内的整数，把它们写成am+b，取m=p^0.5 左右的话，可以通过四次中间过程系数不超过np的乘法算出答案。另外一个办法是，通常我们丢给DFT算的序列都是实数，现在可以凑一凑，用复数序列的一次卷积完成我们希望的事，具体见代码。注意到其实m未必一定要取整数（取整数时选取比较好的m的程序见magic_number_gen.cpp），于是有两个问题：有没有让m不取整数值，精度表现也比较好的方法；当m取整数时，忽略一切浮点运算误差，有没有比较好的卷积结果的绝对值上界？（np^1.5 是很容易的，能不能分析的更好？）这个trick是叉姐告诉我的，另外杜教说毛爷爷今年答辩搞的好像就是这个。

另一个Trick是前几天想到的。如果a,b是两个n维的的实数向量，且他们的每个分量独立且均匀地sample自0..p-1，如果我们把它们存成0..p-1的话，每个分量的期望大约是p/2，方差是np^4/9 ，于是卷积结果每一项的期望大约是np^2/4 ，方差是np^4/9 。这个大Theta(np^2 )的期望和我们的常识是相符的。但是注意到现在的标准差是大Theta(n^0.5 p^2 )的。如果我们把它们存成-p/2..p/2（放弃太形式化的说法了，毕竟我们是“在R上找Z_p的一个模型”）再卷积的话，卷积前每个分量的期望变成0，方差是p^2 /24，于是卷积结果的每个分量仍然是0期望，标准差是n^0.5 p^2 /24（和之前的渐进相同，常数有改善）。并且现在每个结果是大量独立同分布的变量之和，根据适当的Central Limit Theorem的某种变体，我们可以期望他们落在数倍标准差以外的概率极小（你也可以用带标准差的Chernoff Bound之类的玩意，结果确实是令人满意的），再取个n项的union bound可以看到整个序列的绝对值都不太大的概率非常接近1。于是我们卷积这两个shift-to-zero-mean的向量，结果的绝对值是期望意义下O(n^0.5 p^2 )的（而且常数因子很优秀）
但是实际碰到的序列，元素间未必有很好的独立性，怎么办呢？注意到上面的这个方法其实只要求其中一个向量的每个分量是独立随机sample出来的，于是我们有这样的方法：需要卷积a和b，其中a和b并没有什么随机性的保证，我们可以随机sample一个长度相同的c，那么a+c的每两个元素也是独立的，并且每个元素的分布与c相同。于是我们可以用前述的方法计算(a+c)\*b和c\*b，然后减一减就可以了。注意到那个c和他的Fourier变换可以算一次然后存起来一直用，这个Trick比起一般的FFT多项式乘法只多了一步IDFT。

[fotile96 wrote on 2016-04-28T11:28:06]

---

