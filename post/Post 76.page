# 2015 上海赛区网络赛 A Puzzled Elena

求教QAQ

[QAQ wrote on 2015-09-26T09:05:17]

---

题意是给一颗树，1是树根，每个点有一个点权，对于每个节点，求它的子树中和它的点权互质的节点的个数

[QAQ wrote on 2015-09-26T09:08:34]

---

通过启发式合并的手法，我们可以对每个点 $v$ 的子树求出一个 std::map<int, int> $\mathrm{count}(d)$，表示某个数字 $d$ 的倍数有多少个。

之后就是 $\sum_{d | v} \mu(d) \mathrm{count}(d)$ 啊……



[ftiasch wrote on 2015-09-26T09:10:19]

---

QAQ叉姐能讲一下启发式合并的细节吗

[QAQ wrote on 2015-09-26T09:13:34]

---

@sorry_QAQ#639 直接并啊……你现在手上有两个std::map，for 一遍小的，全部插到大的里面去。

[ftiasch wrote on 2015-09-26T09:17:14]

---

@sorry_QAQ#639 QAQ弱知道了，是我分析复杂度的时候想太多了，窝以为是n*n，但是根本不会达到这个复杂度
想明白了，谢叉姐

[QAQ wrote on 2015-09-26T09:19:56]

---

请问这个复杂度大概是多少？我的$n\times 63\times log$的tle了

[takio wrote on 2015-09-26T09:50:58]

---

有大神提供一下题解么？ 想学习一下这个姿势


[burglar wrote on 2015-09-26T09:59:10]

---

我是一边DFS直接做的，$cnt_i$记录当前访问过的点中权值是I的倍数的点有多少个，访问节点的子树前计算一下，访问子树后计算一下，差就是结果。

[alpc_wcq wrote on 2015-09-26T09:59:41]

---

@ftiasch#640 如果树退化成一条链而且质数都不一样。。时间复杂度也够吗。。

[caoyi0905 wrote on 2015-09-26T10:00:00]

---

@caoyi0905#645 感觉会T啊

[alpc_wcq wrote on 2015-09-26T10:03:08]

---

窝写了一发也T了，QAQ。不知道是stl卡常了还是自己的姿势太弱

[QAQ wrote on 2015-09-26T10:18:21]

---

@alpc_wcq#644 机智啊。。。比赛的时候想了好久都没想到。。

[burglar wrote on 2015-09-26T10:20:01]

---

@ftiasch#640 QAQ用map T掉了，叉姐有什么stl之外的启发式合并吗

[QAQ wrote on 2015-09-26T10:29:56]

---

@alpc_wcq#644 等一下 感觉好像有点不对吧。。如果不是i的倍数也可以和I不互质啊。。还是我理解错你的意思了？。。能详细一点说下应该怎么做么？

[burglar wrote on 2015-09-26T10:32:40]

---

其实不用启发式合并 直接dfs一遍就没有log了

[TankEngineer wrote on 2015-09-26T10:35:48]

---

@alpc_wcq#647 巨巨 我明白了。。。。。是反演

[burglar wrote on 2015-09-26T10:41:08]

---

@Burglar#664 Orz

[alpc_wcq wrote on 2015-09-26T11:28:06]

---

@ftiasch#638 好像真会T 还是用dfs序姿势更稳

[lostRating wrote on 2015-09-26T11:44:51]

---

@edly#674 那怪我咯？

[ftiasch wrote on 2015-09-26T11:45:57]

---

@ftiasch#675 明明有我这么老实的背锅侠

[lostRating wrote on 2015-09-26T11:49:12]

---

@alpc_wcq#644 请问怎么记忆dfs子树之前的cnt呢，窝只能想到o(n)的方法

[QAQ wrote on 2015-09-26T13:38:44]

---

@sorry_QAQ#701 只需记录这个点的约数中莫比乌斯函数不为0的cnt就行

[dtyfc wrote on 2015-09-26T13:54:02]

---

@dtyfc#702 然后放在vector中，而且可以证明是log的，窝懂惹，万分感谢
 [IMG]http://static.icpc-camp.org/flarum-emotion/benny/14302.png[/IMG]

[QAQ wrote on 2015-09-26T14:02:00]

---

WA两天之后发现了一个神奇的WA点。。。。。。一个结点的子树结点包括这个结点本身

[QAQ wrote on 2015-09-28T14:55:24]

---

@sorry_QAQ#891 (希望能帮助到和我一样迷のwa的少年)

[QAQ wrote on 2015-09-28T15:23:26]

---

@sorry_QAQ#893 网络赛的时候因为这个调了1小时。。。

[splinter wrote on 2015-09-28T15:28:42]

---

@splinter#894 这个当时我们在clarification里问过，很快得到了肯定的答复。

[sd_invol wrote on 2015-09-28T15:39:31]

---

@sorry_QAQ#891  今天队友在讨论组里大喊“我写的这么对，怎么会wa“，过了一会说”原来子树包括他自己啊“233

[winoros wrote on 2015-09-28T17:53:21]

---

我来提供个解法，可以吗，由于题目节点权值不超过10万，所以最多只含有6个不同的素因数，2 * 3 * 5 * 7 * 11 * 13 > 100000，那么，我们可以采用容斥原理的方法，要算一个节点的子树（包含自身，这个显然吧）有多少个节点和它自己互素。容斥的方法是：总节点数－与它有1个公素因数的节点个数＋与它有2个公素因数的节点个数－与它有3个公素因数的节点个数....。

只需要开一个全局数组a，表示ai表示含有该素数节点出现了多少次，每次从一个节点离开的时候，用容斥去统计，并且更新a数组即可。但这有一个问题，怎么保证容斥统计的是子树的呢？这样做即可，在进入该节点的时候，记录下每个素因数出现的次数，离开该节点的时候再记录一下，两者之差就是子树含有该素因数节点的个数啦。

[peterpan wrote on 2015-09-28T18:17:49]

---

@Sd_Invol#896 幸好那天不是中秋节。。

[alpc_wcq wrote on 2015-09-29T06:43:21]

---

@peterpan#908 我有些不太明白，就是保证容斥统计的是子树，进入该节点时记录每个素因数出现的次数，离开的时候再记录一下，这样不会超时吗

[korun wrote on 2015-09-30T02:04:58]

---

@korun#1014 每个因数只会进入一次，出去一次。总复杂度还是 $O(n \log n)$ 。

[ftiasch wrote on 2015-09-30T02:05:48]

---

@korun#1014 不是记录哦。是直接算那个答案

[yangyue wrote on 2015-09-30T02:06:39]

---

@ftiasch#1015 明白了 谢叉姐

[korun wrote on 2015-09-30T02:22:45]

---

