# JAG Summer 2012 Day 4 J Usoperanto

【trick&&吐槽】
1，一开始想用优先队列，用极有可能爆炸的复杂度来做这道题。
后来才发现基于一个贪心原则，可以使得问题大大简化。
2，才知道BNUOJ的g++，有栈限制，爆栈后我改成了bfs
3，粗略看下，答案会爆int，要用long long

【题意】
给你n（[1,1e6]）个单词，编号从0到n-1，
每个单词有两个属性（l,u），
l代表单词的长度，
u==-1代表这个单词不是其他任何单词的前缀，否则代表这个单词是u号单词的前缀，
然后每个前缀单词和它修饰单词之间字符数，记做这个前缀单词的成本。
我们希望安排这n个单词的顺序，使得总成本尽可能低

【类型】
贪心+拓扑

【分析】
我们从没有修饰能力的单词开始处理问题
以这个单词为根，由修饰词->被修饰词的关系，这题形成一个树结构。
我们考虑先放下被修饰词，然后在其前面顺序插入修饰词。

在过程中肯定满足：
插入其实一定只在头位置插入。
即，如果现在要放置一个单词，一定会先连续把修饰这个单词的子树全部放置完毕。
即，放置的两棵子树一定不会重叠。

证明：
首先要明确，每个点的成本，只会存在它和它的父节点之间。
我们可以想象现在只是放置了根节点（就是不修饰任何单词的单词）
然后开始放置它的所有子节点（就是修饰它的单词）。

根节点的子节点有x，y，x有子孙xson，y有子孙yson
我们发现先在当前决策，先放置x单词更优
决策最优被定义为，这个单词节点为根的子树的单词的长度和在当前最小
即|x|+|xson|<=|y|+|yson|

那么有决策
(1)x->y->xson->yson
(2)x->y->yson->xson
(3)x->xson->y->yson
成本分别是
(1)|x|+|y|+|xson|
(2)|x|+|y|+|yson|
(3)|x|+|xson|
显然先放完x的子树最优，类比归纳写一写也发现是这样。

平白一点，怎么证明呢？

放y先于放x的话，x会承受|y|的成本，y不会承受|x|的成本。
现在相当于，y（以及其他所有未放节点）也已经承受了|x|的成本，x造成的成本已经最劣、最大化了。
然后xson替代了x，也还会继续承受|y|（和接下来其他子树上）的成本。
这种决策，所承受的成本，与其他不放x，先放别的单词的情况，没有什么差别。
同时额外，xson和x的距离被拉大了。xson也开始承受更多成本。
一看就不是最优。肯定不能这么放。
于是。有：如果放一个节点的话，也会一并放置完这个节点为根的子树。


有了这个原则。现在的问题就变成了。
先x子树还是先y子树好呢？
我们发现成本成了∑ li , i为x子树和∑ lj , j为y子树的大小比较。贪小的即可。
于是可以从叶节点开始，利用类似于拓扑的方式bfs，然后就可以AC啦。

话说 实际50ms左右的代码。时限给了8000ms是忽悠大家的吗xDDD~

[snowy_smile wrote on 2015-10-02T06:26:40]

---

以为会有成环的情况……

[skyxuan wrote on 2015-10-02T06:48:45]

---

@snowy_smile#1261 是从哪里看粗来没有环的情况啊0.0

[keepit wrote on 2015-10-02T07:00:35]

---

@keepit#1274 
修饰单词一定放在被修饰单词之前啊。
有环无解啊。

[snowy_smile wrote on 2015-10-02T07:10:32]

---

"一开始想用优先队列，用极有可能爆炸的复杂度来做这道题。"  

@snowy_smile#1261 

[luras_oil wrote on 2015-10-02T07:12:34]

---

对于爆栈问题，写一个手工栈就可以过啦。
优先队列&队列做也是可以的。

[honeycat wrote on 2015-10-02T07:34:09]

---

@HoneyCat#1282 也可以从叶子到根处理，因为给定的是有根树

[zyeric wrote on 2015-10-02T10:38:42]

---

