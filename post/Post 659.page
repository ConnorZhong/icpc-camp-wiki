# Topcoder SRM 688 Hard

题意: 给一个括号序列s，要求你把这个序列划分成恰好两个括号子序列a, b, 使得在a, b都是合法括号序列的情况下cost(a) + cost(b)尽量小。

cost(s)计算方法如下：对于每一个match的括号对，我们定义它的深度为在这个括号内部，括号嵌套最深的层数。比如对于"(()(()))"，最外层的括号的层数为3。对于每一个括号对，对cost(s)的贡献为d^2 ，其中d为它的层数。

限制为|s| < 150。

我使用了一种简单的贪心方法过了此题（从左到右for这个括号序列，贪心分配当前括号给s1 还是s2）。我看到很多人也用了DP或者其他类似的方法。但这些方法都无一例外使用了一个性质：原本在s中match的括号对一定会被分配到同一个子序列。

我想了很久感觉不是那么好证明啊？有没有大佬给点思路！

[Miceren wrote on 2017-01-31T08:24:54]

---

