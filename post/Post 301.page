# Shanghai 2015 C Color

给定一棵节点数为N的树，有两种不同的操作：1、将以u点为根节点的子树的所有节点都染色为C；2、查询以u点为根节点的子树有多少种不同颜色的节点。共有M个修改/查询。
N,M,C<500000;

[ephxyscj wrote on 2015-11-24T07:35:37]

---

以前有一道题，只有单点修改，那么可以先求出欧拉序，然后维护一个$pre$数组，$pre [ i ]$表示和点$i$颜色相同的上一个点的下标，查询就变成了问一段区间内$pre$数组中有多少个数小于某个数，可以用树套树来维护。
对于这道题我有个想法：一段区间的修改你可以看作是改了第一个位置的颜色，然后后面的位置变成“同上”色，这样询问一个区间$[L, R]$的时候先查询这个区间第一个元素$L$，如果是“同上”就算一种不同的颜色；然后忽略所有“同上”查询$[L+1,R]$，这部分就和上面一样了。这个可以用线段树套平衡树来维护。
然后补充一点，就是当修改了一段区间$[L, R]$之后，如果$R+1$那个位置是“同上”的话，就改成它当前的颜色。

[mstczuo wrote on 2015-11-24T07:49:20]

---

@mstczuo#2824 这里是有换根的。。。会有询问的子树被拆成了两个区间的并的情况，我觉得这样树套树是不能做的吧。。

[splinter wrote on 2015-11-24T08:26:24]

---

贴一发出题人@hutu的题解 
如果是只更新某一个单节点，那么将树用dfs序转化为一个线形序列之后，问题则转化为，对于一

个序列单点更新，查询区间不同数的个数，这是一个经典问题。经典方法是用树套树维护每一个

数的前驱per[x]，然后查询满足l <= x <= r, pre[x] < l的个数即可。复杂度是n*logn*logn

所以第一步的目标是：将子树更新转化为单点更新。

对于每一个以u为根节点的更新操作，我们可以转化为，更新根节点u的颜色，然后清空子树中除

根节点u外的所有颜色，将其设为null。那么对于每一个点，它真正的颜色是向上找到第一个颜色

不为null的祖先的颜色。这样问题就成功转化为单点更新，子树查询。

对于这题，根据树的特性，复杂度可以降到nlogn。

我们将所有同一颜色的节点放在一个set里，根据dfs序排序。每一个节点x，假设在set中它的前驱

为y，x与y的lca是z，那么我们设定x只对x -> z这条路径上的点贡献答案1。这样用线段树，即可维护每

一个子树的答案。

[elfness wrote on 2015-11-24T08:33:27]

---

@splinter#2825 好像@ephxyscj#2823 没有说有换根的情况

[mstczuo wrote on 2015-11-24T08:35:38]

---

@elfness#2826 线段树+set 复杂度为什么不是$O(n\log\^2n)$?

[mstczuo wrote on 2015-11-24T09:28:23]

---

@mstczuo#2829 每次的操作是，通过set拿出来要弄的路径，然后用欧拉路径更新区间查找点，这两个操作不是嵌套的而是一先一后的，复杂度是$O(\lg n + \lg n)$.

[Ruins wrote on 2015-11-24T09:41:12]

---

@mstczuo#2829  看题解-->更新x节点颜色，我们需要先在set中找到x的前驱y，找到前驱y之后再找x与y的最近公共祖先z，然后才在线段树中更新，在set中增删改查之类的。。这些操作都只是先后关系，不需要嵌套，所以是一个log。

[QPHutu wrote on 2015-11-24T09:50:11]

---

@QPHutu#2831 orz 太神了这做法 我之前还是没跳出区间维护这个思维定式。
所以比赛的时候是只有n logn 才能过吗？

[mstczuo wrote on 2015-11-24T10:06:34]

---

@mstczuo#2832 标程跑了1.5s，对跑有一个树套树的$O(n \log ^2 n)$的做法，跑了4.8s左右。。常数不太大应该可以过的吧。。（不知道上交怎么写的。。

[Ruins wrote on 2015-11-24T10:07:55]

---

@Ruins#2833 

> 神秘人  09:40:53
> 对每个活着的modify u
> 神秘人  09:40:56
> 只存u
> 神秘人  09:41:24
> 就是，对于一个query u
> 神秘人  09:41:37
> 它的ans，分为两种
> 神秘人  09:42:04
> 1. c整个颜色在u的子树内有一个活着的modify
> 神秘人  09:42:20
> 1. c这个颜色在u的子树内没有一个活着的modify
> 神秘人  09:42:31
> 对于第一种
> 神秘人  09:42:50
> 我们对每个颜色，活着的modify u，维护u到根路径的并
> 神秘人  09:42:59
> 如果query在并上，ans++
> V  09:43:12
> 我懂了
> V  09:43:20
> 你做得比我简单好多


[ftiasch wrote on 2015-11-24T13:10:30]

---

@Varona#2840 看起来感觉跟标程是一样的。

[QPHutu wrote on 2015-11-24T13:19:10]

---

@Varona#2840 活着的，好评www

[Ruins wrote on 2015-11-25T02:54:58]

---

