# 2016 浙江省省赛 简要题解

### A. Apples and Ideas
A,C=C,A; B=D=B+D;

### B. More Health Points
考虑链上的版本(其实就是[Bear and Bowling 4](http://codeforces.com/contest/660/problem/F))，给出$n$个数$a_1,a_2,...,a_n$，求出$\sum\limits_{i=l}^{r}{(i-l+1)a_i}$的最大值。令$s_i=\sum\limits_{j=1}^{i}a_j, p_i=\sum\limits_{j=1}^{i}ja_j$，那么就是求$p_r-p_{l-1}-l(s_r-s_{l-1})$的最大值。如果固定$r$，把式子变换一下就是找到一个$l$最大化$p_r-ls_r-p_{l-1}+ls_{l-1}$，维护一个凸壳就可以搞了。推广到树上把链上用到的单调队列可持久一下就好了，复杂度$O(n\log n)$。

也可以树分治。考虑每次分治中心$g$，一条合法的在原来有根树上的路径是这么组成的：$g$往下标号一路递减的路径+$g$往下标号一路递增的路径。类似地，推一下合并需要的式子，会发现也是可以用凸壳维护的，复杂度$O(n\log^2n)$。

### C. Defuse the Bomb
按照题目意思模拟。

### D. The Lucky Week
可以观察到1753年1月1日是周一，然后我们知道大概再过2800年就会重复。于是预处理出1753.01.01后面2800年的所有lucky week。之后根据循环节算一下就好了。

### E. Modulo Query
可以观察到一个区间对一个数取模后的结果也可以用区间来表示，并且这些区间的左端点都是0。于是直接用一个map存每次取模之后的区间和这个区间出现次数，要取模的时候，找出所有右端点大于等于当前模数的所有区间，暴力算一下结果即可。对于查询，二分下位置，求个后缀和就好了。下面分析下复杂度为什么是对的。

众所周知：一个数对一堆数取模，最多会有$\log$次值的改变。对于这题每对一个新数取模，最多只会增加一个区间。考虑当前区间是$[0,v_i]$，要对$x$取模，那么对于$v_i < x$的区间没有变化，对于$v_i \ge x$的那些区间会变成$[0,v_i \text{ mod } x]$，并且可能会新增区间$[0,x-1]$。这个过程其实相当于每个$a_i$对后面所有数依次取模，那么总共会有$O(n \log n)$次值的改变，每次改变需要在map上修改一下，总复杂度是$O(n\log^2n)$的。

### F. Kpop Music Party
首先把可以合并的区间合并掉，那么剩下来的区间互不相交。考虑到最左端点是一定会参加party的，于是只要考虑每个区间的右端点是否要参加party就好了，这部分可以用$O(2^n)$的复杂度枚举，剩下来直接贪心就好了。

### G. Substring Counting

所有合法的子串除了左右两部分都包含了完整的一些runs（全0的case需要特殊处理下），这些合法的子串具体可以分为3种情况：左右两端都是0，左右两端一个0一个1，左右两端都是1。

1. 两端都是0：假设左右0的个数分别是$a$和$b$，中间0的个数是$x$，那么要满足$x < m, a+b+x \ge m$。抠出满足这些条件的所有字段，把中间部分相同的归为一类（为了不重复计数）。对于同一类，问题转化为给出若干$(a_i,b_i)$和一个整数$x$，问有多少$(s,t)$满足存在$(a_i,b_i)$使得$1 \le s \le a_i, 1 \le t \le b_i, s + t +  x=m$。然后对于没对$(a_i,b_i)$我们通过上面条件确定$s$的范围，之后一个区间并算下有多少可行的$s$就好了。

2. 左端是1右端是0：枚举1所属的那个段，然后往右扩展直到有$m$个0为止。同样可以归个类，对于同一个类，计算左侧可以有的1的最大值，这个就是对答案的贡献。左端是0右端是1的情况只要把串reverse一下就好了。

3. 两端都是1：假设左右1的个数分别是$a$和$b$，我们要找出中间0的个数是$m$的那些端，类似地，把中间相同的归个类。对于同一类，问题转化为给出若干$(a_i,b_i)$，问有多少$(s,t)$满足存在$(a_i,b_i)$使得$1 \le s \le a_i, 1 \le t \le b_i$。按照$a_i$排个序，令$c_i=\max(b_i,b_{i+1})$，然后这个类对答案的贡献就是$\sum c_i(a_i-a_{i-1})$。

还有$m=0$等一些边界case，特判一下就好了。

### H. Himalayas
考虑相邻两个数的大小关系只有三种情况，并且每次修改操作的$b$都是大于0的，那么除了端点部分，大小关系一定会从$ > \to = \to <$。总的变化次数一定是$O(n+m)$的。于是每次的修改操作，只要暴力找出这些改变的位置，计算下这些位置对答案的影响就好了。

令$d_i=h_i-h_{i-1}$，用一棵线段树维护$d_i < 0$(对应了 > 关系)的位置，用一个set之类的维护$d_i=0$的位置，$d_i > 0$的位置不需要维护。那么每次修改操作只有那些$d_i + b >= 0$，$d_i=0$并且在区间内的位置以及区间端点会对答案有影响。前者用线段树维护最值（这个线段树大概还需要支持单点修改，区间加一个数等等操作）即可，后者直接在set上lower_bound即可。找出这些位置之后，随便统计一些就好了。

### I. People Counting

拿那个人的形状去匹配每一个位置就好了，注意可以人跑到照片外面去，似乎样例就有这种case。

### J. Rush on the Cube

这题有毒。分为两种情况，起点终点是否在同一个立方体内处理。在同一个立方体内的时候，分三种情况讨论，或者直接模拟退火求最短在不同立方体内时，一定是分别走到顶点然后再走。枚举走到哪个顶点，一共64种情况。顶点间走的时候，可以A*或者模拟退火求最短路，或者贪心，面对角线优先，然后体对角线，然后边，有些要讨论的细节，可以暴力枚举走到附近点，然后贪心。

### K. Highway Project

先求出最短路图，就是那些$dis_u+w(u,v)=dis_v$的边$(u,v)$都拿出来，剩下来就是给出一个有向无环图，要求找个最小树形图，你可以选择套$O((n+m)\log n)$的模板，也可以直接贪心，对于每个点选代价最小的入边。

### L. Very Happy Great BG

对输入的数求个和，包括$n$。

[这里](https://gist.github.com/zimpha/090a823e598652290b7d00a50c7d6934)有所有的验题代码(J是标程）。

[zimpha wrote on 2016-04-23T13:30:30]

---

> 你可以选择套 $O((n+m)\log n)$ 的模板，也可以直接贪心，对于每个点选代价最小的入边

hhhh

[ftiasch wrote on 2016-04-23T14:07:40]

---

K直接一遍最短路记一下边吧…

[Vec wrote on 2016-04-23T14:35:27]

---

