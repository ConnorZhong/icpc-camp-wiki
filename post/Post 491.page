# ONTAK 2016 意识流题解

推完了ontak2016，简单分享一下自己的做法。 （题目链接 https://sio2.mimuw.edu.pl/c/wiekuisty_ontak2016/p/ )

dan
每个颜色随机一个2^64 内的hash值，然后只要检查sum就行（路径长度也不需要判）。点分。

dum
式子直接拆开来。线段树维护。

mer
边有特殊性质（正反走费用恰好相反），所以没有正环等价于存在一组距离标号dis[]使得每条边都成立weight(u,v)=dis[v]-dis[u]。

固定一个点dis=0，然后就变成一个方阵，操作是给一行/一列整体加减或者给一个格子加减，询问方阵里是否全是0。差分一下就很方便了。

blu
先把NO的格子全去掉，只剩下可能含有的格子。然后是个差分约束的模型，要算最少含有几个的话只要一遍dp最长路就行了。要判某个格子是否必须包含，正反各dp一遍，f[i]是0到i的最长路，g[i]是i到n的，然后检查f[i]+g[i-1]就好。

coo
三维有两个log的经典做法（常数要小）。四维时因为有特殊条件，可以转化成4个三维问题。四个数组分别是a,b,c的话，(ans(a,b,c)+ans(a,b,d)-ans(a,b,-c)-ans(a,b,-d))/2就是答案。

tre
a[i]的父亲是a[1..i-1]中最小的比a[i]大的或者是最大的比a[i]小的，只要对a的逆排列数组搞一搞单调队列就可以预处理出来了。

bar
比较有意思的题。首先能证明F和B的次序是无关的，只要关心做了几次F和几次B。二分之后，只要能O(n)求出做k次F变换后的结果就行了。画一下之后能发现规律

````
549281376
 452813769
  425137689
   241356789
    213456789
     123456789
      123456789
       123456789
        123456789
         123456789
549281376
 55999999
  4558888
   445557
    24445
     2234
      123
       12
        1
````

上面的图是每次F操作后的结果，右半个三角的内容是固定的，只要看左半边。看下面的图，每一列是其左边的所有数字降序排序。上图的左半边就是下图，但是每一列要对最上面的数字取min。

那么要求第k行的内容，就是每次删一个数，问剩下的数中第k大。直接扫就行了。

gem
按费用从小到大贪心，能取就取。判断是否能取用线段树（区间减，区间询问最小值）维护。

mad
直接倍增。

cri
比较难弄的题。

k=2的时候两种策略:1带着一个人去，1回。或者1，2去，1回，两个人去，2回。直接dp

k=3的时候4种策略：

①1带着两个人去，1回

②1,2带着一个人去，1回，三个人去，2回

③1,2不带人去，1回，三个人去，2回

④1,2,3去，1回，三个人去，2回，三个人去，3回。

（其实不会证明为啥这些策略就够了）

然后问题在于②号操作是1+3混合起来的，所以不能直接dp。（因为1肯定是从左边取，3是从右边取）

所以枚举②号操作用了x次，那么左边取x个，右边取3x个，中间这段用剩下三种策略，是可以dp的。这样就是O(n^2 )了。

为了优化，注意到中间段肯定包含序列总长度四分之一位置这个点，那么从这个点往两边dp，然后合并起来就行了。O(n)。

quo
直接倒着推就行了。

squ
每个图形记一下上下左右四个侧面的轮廓，用deque维护。也要记一下这个图形的x,y位移。

启发式合并即可，所以是O(nlogn)。

klo
直接O(kn^2 )的dp就行了。

man
分治+树状数组 O(nlog^2 n)

slo
按串长l分类。l小的时候O(l^2 )枚举坏格，算出每个串挖掉坏格后的hash值再取出现最多的。l大的时候，串的个数n=L/l小，用O(n^2 )枚举每一对串求出它们之间不匹配的位置i,j，并给这一对串连边（多于2个不匹配则不连边），（用后缀数组lcp可以O(1)求）。然后把同类型的边拿出来求一下连通块。（只有一个位置不匹配的边要特殊处理）。这样大约是O(L^{4/3} logL)

gcd
固定区间起点的话有log段不同的gcd值，二分找出来就行了。求区间gcd用ST表求就是O(log(A))，这样就是nlog(n)log^2 (A)。卡一卡可以省掉一个求gcd的log：二分判断的时候不要求gcd，直接判整除就行。这样是nlog(A)(logn+log(A))。

obr
最优解时带形区域的一边上应该有两个点，枚举这两个点，然后挑法线方向上第k个点更新答案。 优化这个过程，扫一圈，同时用数组维护法线方向上点的顺序，扫的过程中会发生O(n^2 )次相邻元素交换。这样总复杂度是O(n^2 logn)，瓶颈在于把n^2 条线按极角排序。

prz
对每个关键点作起点跑dijkstra。然后把关键点拿出来dp，求出u到v经过s个关键点的最短路。然后再给它们连上边，以每个关键点作为起点，用dijkstra跑出到图中每个点且经过s个关键点的最短路。这样每次询问就可以O(关键点个数)了。

las
每个块选重心作为接点。然后最大的块的接点连向其他块的接点。

mod
设最小答案是k，对k的每个质因子分开来算它在答案中是几次幂。当前质因子是p的时候，把两个排列都求S次方，其中S包含了所有与p互质的质数作为因子，于是S次方后的排列应该只剩下长度为p的幂次的轮换了。然后再枚举p的幂次检查一下就好。分析一下复杂度大概是nlogn的。

pod
二分，然后正着推一遍反着推一遍，挖掉一个看看反着走的是否已经到正着走的左边了。

[jcvb wrote on 2016-07-20T09:06:10]

---

