# Codeforces Round 344E Product Sum

给定长度为n（n<=20 000）的数组a[]，你可以选择一个区间[l,r]，将[l,r]里面的数循环左移一下或者右移一下，求‘1×a[1]+2×a[2]+...n×a[n]最大值。

[w20810 wrote on 2016-03-17T12:47:25]

---

循环左移和右移是做法一样的, 不妨只考虑循环右移. 答案的该变量为$(l-r)a_r+(a_l+a_{l+1}+...+a_{r-1})$, 搞个前缀和, 那么该变量化简一下得到$(S_{r-1}-ra_r)+(la_r-S_{l-1})$, 考虑枚举$r$, 只需要求最大的$la_r-S_{l-1}$即可, 然后这个东西就是一大堆斜率为$l$, 截距为$-S_{l-1}$的直线, 用[Convex Hull Trick](http://codeforces.com/blog/entry/11339)(就是通称的斜率优化)搞搞就好了.

[zimpha wrote on 2016-03-17T13:27:15]

---

@zimpha#3357 枚举r的时候，如何保证找到的l<=r呢?

[w20810 wrote on 2016-03-18T06:50:14]

---

@w20810#3365 你$r$从小到大枚举, 然后维护那个凸壳不就好了.

[zimpha wrote on 2016-03-18T07:07:09]

---

@w20810#3365 从小到大枚举r，维护l=1,2,3,...,r这些直线的凸壳

[quailty wrote on 2016-03-18T07:12:03]

---

@zimpha#3367 但是线不是要被排序先吗？ 如果拍完序不是打乱了l的次序？

[w20810 wrote on 2016-03-18T07:12:37]

---

@w20810#3370 第i条直线的斜率就是i，新加进来的直线的斜率总是大于原有的直线的斜率

[quailty wrote on 2016-03-18T07:16:14]

---

@quailty#3371  。。。我忘了这个条件....谢Q神，，，

[w20810 wrote on 2016-03-18T07:19:12]

---

另外一个想法是，仍然枚举r，维护(1,-s[0]),(2,-s[1]),...,(r,-s[r-1])这些点的上凸壳，然后在凸壳上三分

[quailty wrote on 2016-03-18T07:26:28]

---

证明的话大概就是，对于一个不在凸壳上的点Q，找出左边和右边在凸壳上的点P,R，如果QR斜率>=-a[r]，这样R比Q优，否则PQ斜率<=QR斜率<-a[r]，这样P比Q优，总之Q不优

[quailty wrote on 2016-03-18T07:29:04]

---

