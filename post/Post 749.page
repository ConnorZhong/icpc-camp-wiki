# 51nod 1529 排列与编码

题目链接：[51nod 1529](https://www.51nod.com/onlineJudge/questionCode.html?problemId=1529)
题目大意：
对于给定的可重集，可以将其中的元素进行排序，得到许多不同的排列，定义可重集中一个排列的排名是字典序小于它的不同排列的个数。
给定某个可重集中的两个排列，设它们的排名分别是 $R_1$ 和 $R_2$，对于该可重集来说一共有 $L$ 个排列，求排名是 $(R_1 + R_2)\text{ mod }L$ 的排列。
限制条件：可重集大小不超过 $50000$，可重集中的元素是不超过 $10^9$ 的正整数，时限 6 秒，空间 512 MB。

[skywalkert wrote on 2017-10-04T16:37:39]

---

初步分析：

设可重集大小是 $n$，计算一个排列的排名可以直接改写康托展开，得到一个算法依次统计排列的每一位对排名产生的贡献，其中需要借助数据结构计算每个位置之后与其相等、小于其值的位置数量，这部分的复杂度是 $O(n \log n)$。但由于大数运算的问题，每一个位置产生的贡献可能是长度 $O(n)$ 的数字，直接计算的复杂度会达到 $O(n^2)$，考虑到贡献可以拆分到该位置之前、该位置、该位置之后三部分相乘，利用分治技巧可以合并许多的运算，复杂度做到 $O(n \log^2 n)$。

计算一个排名对应的排列，也可以直接改写逆康托展开，得到一个算法依次确定每一位的取值，其中需要借助数据结构二分确定每一位的取值，这部分的复杂度是 $O(n \log n)$。但还是由于大数运算的问题，每一个位置确定取值时需要每个位置之前的贡献被取消后剩余的值，如果利用分治技巧继续进行运算合并，则需要计算前面区间产生的影响（减去/加上），在递归区间时完成"该位置之后"这部分贡献的取消（除去/乘以），复杂度做到 $O(n \log^2 n)$。

稍微细节一点来说就是，向下递归时去掉属于区间外部的信息，向上合并时计算出区间内部对排名产生的贡献，感觉是可以实现的？

[skywalkert wrote on 2017-10-04T16:50:54]

---

已解决。

逆康托展开可以分治的原因是后面位置对前面位置不产生影响（或者说影响是定值，可以存下来），具体在计算的时候有些像是遍历了一遍线段树。定值的存储空间比较吃紧，毕竟存的是大数，在基于贡献比较均匀的假设前提下，空间是 $O(n \log n)$ 的。

[skywalkert wrote on 2017-10-04T19:01:39]

---

