# Changchun 2015 Warmup C

给你一个n个数的序列a，每个数的范围是1<=v<=100000,然后给你一个k和m，k代表区间长度，而对于所要求的区间的要求是区间内的任意两个数都是互素的，输出满足条件区间的个数，然后有m(1<=m<=100000)个操作，每一次操作有两个输入，a和b,1<=a<=n,1<=b<=100000,代表着把第a个元素的值改为b，问每一次操作后，满足区间的个数是多少。
 Input:
6 3 4 （n,m,k）
7 2 3 4 5 6
4 3
5 9
4 10
6 11
Output:
2
3
3
3
2

[woshi_sb wrote on 2015-10-17T11:12:58]

---

我擦，弄错了，样例输入顺序是n,k,m,不是n,m,k

[woshi_sb wrote on 2015-10-17T11:14:45]

---

我是bitset乱搞的，现场没拍完，所以不保证正确性QAQ
线段树的每个节点，都塞一个bitset
bitset<10000>的第i位，保存该处理区间是否存在第i个素数
题目中的修改操作，每次就二分找离这个数最近的不满足题意的点，左右各找一点，那么这些点之间的区间都是符合题意的
然后就瞎搞就行了

[qscqesze wrote on 2015-10-17T14:47:00]

---

一个非常非常非常暴力的方法：（以下假设$n,m,v$同阶）
如果知道每个数字的右边第一个与它不互质的数字是谁即可快速限制这个区间的情况，假设你能单次询问$O(log\^2n)$快速维护这个$next_i$，那么你就可以用线段树单次询问$O(log\^2n)$维护合法的区间个数。
线段树第$i$个位置维护满足$[0\le j<k][next_\{i+j\}<i+k]$的个数，只用计算区间最小值、最小值的个数，最小值为$0$的就是合法的起始位置。
如何快速维护$next_i$呢？假设知道第$i$个数的每个质因子在它右边第一次出现的位置，就可以在$O(logn)$个数字里选一个最小的作为$next_i$，用平衡树维护一下就好啦，每修改一个$next_i$会更新线段树里一段的数，每次询问也就修改$O(logn)$个数的后继。
以上口胡欢迎hack。

[skywalkert wrote on 2015-10-20T06:19:42]

---

