# CCPC 2016 Online 1009 This world need more Zhu



题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=5840
题意：给一颗100000级的树，每个点上都有一个权值v[i]，有100000级的询问，对于每个询问u,v,k,首先将点u到点v的最短路径上的所有点按顺序编号，u的编号为1，求树链上所有点的新编号cnt满足cnt%k==0的点的权值的最大值。

感觉莫队和树链剖分都不是很好做，想问下这题如何解？

[burglar wrote on 2016-08-14T13:14:33]

---

首先对于每个询问我们可以拆开成为两个询问，一个是查询(u,lca(u,v))链上,deep[i]%k=a的最大值，一个是查询(v,lca(u,v))链上，deep[i]%k=b的最大值，就都变成了从deep值大的位置跑到deep值小的位置了。

然后根据K的大小来做这道题，block是自己设定的一个值，一般为sqrt(n)。

假设K>=block，这一部分直接暴力去做就好了，把所有询问都离线下来，按照dfs顺序，拿一个栈维护一下从根到这个点经过了哪些点，这个点减去k，就表示这个点往上跳了k步，直到跳到这个询问记录的lca位置。

这个的复杂度是n + qsqrt(n)

假设K<block，把询问按照k分类。
对于每一种k，我们考虑树链剖分，把树链剖分hash下来的坐标，我们按照deep%k值分类，相同的值放在一起。那么我们相当于把这棵树拆成了k棵树，每棵树里面储存的节点deep值%k的值都相同。

然后题目的询问，其实就变成了很普通的查询链上最大值了。

这个复杂度是nsqrt(n)+qlognlogn

当然这道题还有很多种做法的样子，我只是抛砖引玉的讲了其中一种方法。

[qscqesze wrote on 2016-08-14T15:41:36]

---

补充一个做法：K < Block  的部分可以用类似求LCA的做法，用并查集维护答案，可以做到 n sqrt(n) .


[mstczuo wrote on 2016-08-15T07:01:34]

---

