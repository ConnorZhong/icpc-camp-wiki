# 简单的序列问题

一个长度为 $n$ 的无重复序列 $A$，求一个字典序最小的子段 $A[l \ldots r]$，使得它加入至多 $k$ 个元素并升序排序后，为连续的一段（值域连续）。

$n \leq 2\times 10^5$

[rainDrop wrote on 2016-02-23T09:49:38]

---

有没有题目来源？

[ftiasch wrote on 2016-02-23T10:43:38]

---

一个很暴力的做法, 也许复杂度是$O(n \log^2 n)$

首先, 对于每个$i$, 只要找到最小的满足条件的$j$就好了, 考虑用分治来做.

对于分治区间$[l,r]$, 令$t=\frac{l+r}{2}$, 定义$M_i$和$m_i$为:

$M[i] = \begin{cases} \max(a_i, \ldots a_t) & \text{ if }i \le t \\ \max(a_{t+1}, \ldots a_i) & \text{ if }i > t\end{cases}$

$m[i] = \begin{cases} \min(a_i, \ldots a_t) & \text{ if }i \le t \\ \min(a_{t+1}, \ldots a_i) & \text{ if }i > t\end{cases}$

那么一个合法的区间要满足$\max\{M_i,M_j\}-\min\{m_i,m_j\} \le k+j-i, i \le t < j$, 对于一个$i$, 找到最小的$j_1$满足$M_{j_1} > M_j$, 最小的$j_2$满足$m_{j_2} < m_j$. 由于$M$和$m$的单调性, 这些都可以$O(1)$求出来.

那么对于$j$, 有下面三种情况(不妨假设$j_1 \le j_2$, 反之也是一样的):

1. $j < j_1$, 那么$j$要满足$M_i-m_i \le k + j - i$, 这个可以$O(1)$找出最小的$j$
2. $ j_1 \le j < j_2$, 那么$j$要满足$M_j - m_i \le k + j - i$, 大概用个Treap维护$M_j-j$就可以$O(\log n)$求出最小的$j$
3. $ j_2 \le j$, 那么$j$要满足$M_j - m_j \le k + j - i$, 类似的用Treap维护$M_j-m_j-j$就好了

[zimpha wrote on 2016-02-23T11:33:00]

---

@zimpha#3181 最近学到了一个$O(n\log n)$的做法, 记录一下.

一个区间$[l,r]$合法, 当且仅当: $[l,r]$内没有相同的数, 并且$\max([l,r])-\min([l,r])-(r-l) \le k$

考虑从大到小枚举$l$, 如果我们知道了$a_x=\max([l,x])-\min([l,x])-(x-l)$, 那么剩下的操作就是要在一段区间(这个区间根据$[l,r]$没用相同数确定)内找到最右边的,不超过$k$的数的位置. 这个只要用线段树维护一个区间最小值, 然后在线段树上走来走去就好了.

考虑在$l$变化的时候, 如何维护$a$. 用两个单调栈分别维护$[l,x]$内的最大值和最小值以及他们的位置. 最大值栈中, 栈顶到栈底数递增, 最小值栈反之. 当$l$变小的时候, 把新加的数压入栈中, 并维护单调性, 这样就可以维护出$\max([l,x])$和$\min([l,x])$. 考虑到min和max的变化都是连续区间的改变, 这样在维护栈的时候可以同时维护$a$的大小. 维护栈复杂度是$O(n)$的, 于是只要$O(n\log n)$就可以做这个题了.

[zimpha wrote on 2016-04-13T05:17:56]

---

