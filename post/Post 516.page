# HDOJ 5814 Find the Period

第7场多校的1006，题解里说用到的一个基本子串字典（Basic Factor Dictionary）好像就是Vfleaking大大所提到过的波兰表http://vfleaking.blog.163.com/blog/static/174807634201321981915529/

还有就是，题解中：
      “为了找到子串S[L..R]中最长的一个真前缀同时也是S[L..R]的后缀，我们用“倍缩”的方法. 先对于可能的最大的k，查询从S[L..L+ 2^k-1]的基本子串在S[L..R]出现的位置，这个可以在上述的字典中二分查找，设查询到的位置集合为A. 类似地，我们也查询S[R-2^k+1..R]在S[L..R]出现的位置，设查询到的位置集合为B. 如果A和B中分别存在值a和b，使得a-L和R-b相等，则上述要查找的真前缀存在. 另外，当2^k不小于S[L..R]长度的一半时，A中的值和B中的值都是等差数列，所以不用担心A和B中有多个值导致算法复杂度增加. 接下来我们继续在S[L..R]中是否有长度在2^k-1和2^k之间的符合上述要求的前缀”   
       这一段写的有点乱，有些看不懂，谁能够好好的解释一下？


[woshi_sb wrote on 2016-08-12T07:43:05]

---

「Efficient Data Structures for the Factor Periodicity Problem」 <-- 看这个论文就好

[ftiasch wrote on 2016-08-12T10:57:53]

---

@ftiasch#4048  我现在的一个疑问这个为什么 “2^k 不小于S[L..R]长度的一半时，A中的值和B中的值都是等差数列，所以不用担心A和B中有多个值导致算法复杂度增加“ 成立？ 比如长度为2^k 的字符串aaaaaa.......... ,在长度为 2^(k+1) 的字符串aaaaaaa.......aaaaag中出现的次数就很多，并且不存在前缀和后缀相同的情况。 

[woshi_sb wrote on 2016-08-12T12:00:24]

---

@woshi_sb#4051 这个在我发的论文里面也有（但是没有证明），就是如果串 a 的长度不小于串 b 的一半，那么 a 在 b 中出现的下标是个等差数列。

这个可以反证证一下。

[ftiasch wrote on 2016-08-12T15:26:25]

---

