# NEERC 2013 Eastern Subregional J The secret module

[题目链接](http://acm.timus.ru/problem.aspx?space=1&num=1999)
给出一个有限状态自动机，n个状态标号1~n，适用于允许前导0的非空数字串，从1号节点开始匹配。
设其能接受的数字串集合为S，使S里每个数字加上k，得到一个新的数字串集合S'。
找一个有限状态自动机的接受集合为S'，保证有解时存在状态数不超过25600的解，无解输出Impossible。
$n\le100,1\le k\le 8$。

[skywalkert wrote on 2015-11-15T08:49:48]

---

@skywalkert#2607  25600 / 100 = 2^8 ，拆成k次+1做，每次节点数翻倍
本质就是+1进位影响的后缀是连续的一段9
考虑每次+1，将节点s拆成(s,0)和(s,1)，若原来s读x跳t，则(s,0)读x跳(t,0)，(s,0)读x+1跳(t,1)。当x = 9时，(s,1)读0跳(t,1)
(s,0)不再是terminal，原来s是terminal那么(s,1)也是terminal
特殊情况如 999 + 1 = 1000，考虑添加个(1,0)读1跳(1,1)

[lostRating wrote on 2015-11-17T09:22:07]

---

@edly#2661 这题怎么写 checker 啊？

[ftiasch wrote on 2015-11-17T12:45:50]

---

@Varona#2670 f [ i ][ j ] 吧？

[lostRating wrote on 2015-11-17T12:47:44]

---

@lostRating#2661 这样做的结果是产生一个非确定性有限状态自动机 (NFA)，但题目所求是确定性有限状态自动机 (DFA)，这里 post 主没有写清楚，而直接将所述的 NFA 转化为 DFA 可能使节点数指数级增长（但实际上是平方级）。

偷窥标程的做法，发现标程没有接受 +k 后长度变化的情况，即对于 999...x 这样的数字串，如果它能被接受且 0999...x 不能被接受且 $x+k>9$，那么这个数字串 +k 后不会被新的 DFA 接受。（不确定是否存在这样的测试数据，但这样的输入是很好构造出来的）

除去这个特殊情况，可以用 2n+1 个节点的 NFA 直接表示 +k 的情况，不用拆成 k 次 +1，前 2n 个节点类似耀爷的做法（跳 terminal 有些不同），多出的一个点作为唯一的接受节点（这也是因为 +k 和 +1 不同）。

因为除去了特殊情况，这个 NFA 转 DFA 可以使用枚举等价子集的形式，这些子集有一些性质，只会包含至多 3 个 NFA 的节点，且它们分别来自前 n 个节点、中间 n 个节点、最后一个节点，因此这样的子集数量是不超过 $2(n+1)^2$ 的（20402<=25600），直接枚举这些子集的转移，看能到达哪个子集即可，时间复杂度 $O(n^2)$。

加上特殊情况则会使到达中间 n 个节点的情况指数级变化了，虽然我没看出来这个题哪里有说不允许这样，但是估计这题的期望做法就是上述 $2(n+1)^2$ 的构造了。

[skywalkert wrote on 2017-10-01T18:49:20]

---

