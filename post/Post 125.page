# JAG Summer 2012 Day 4 G Presentation

QwQ求解。。。
发现过的那队是交的表orz。。。

[winoros wrote on 2015-10-02T06:19:54]

---

@winoros#1256 你会发现，任何时候这个现有的树，肯定跟最终答案中某棵子树是同构的。（废话，不然这棵树怎么被贴出来的

那么就可以愉快地打牌了。我们设 $f(v)$ 表示现在有的是长得跟 $v$ 这棵子树一样的。转移看上去就是枚举一下，在上一步（贴之前）根那块的形态，但是这明显没法枚举。所以翻过来，我们再枚举 $v$ 的一个子树 $u$，表示这一次是要贴出来 $u$ 这样的子树。

这打牌复杂度看似非常大。但是首先要注意到，这个子树大小永远是 $n$ 的一个约数，所以很多子树本身就是不可能的。稍微再记忆化一下就能过了 …… 

这是 @bjin 当年写的[代码](http://git.icpc-camp.org/ftiasch/mithril/blob/master/2012-09-17/G.cpp)。

[ftiasch wrote on 2015-10-02T06:24:21]

---

@ftiasch#1257 啊 大致明白意思了，窝去消化一下QwQ



[winoros wrote on 2015-10-02T06:29:26]

---

假设总的树大小为 $N$ 的话，若最后一次用大小为 $X$ 的树去贴整棵树。那么 $X - 1 \mid N - 1$。枚举 $N - 1$ 的因子 $d$ ，考虑树形 DP 出大小为 $d$ 的子树。记录 hash 值和 size 子树大小。如果 $\mathrm{size} > d$，那么不可行，如果 $\mathrm{size} = d$ ，判定 hash 值是否唯一，并缩成一个叶子。可以发现对于 $d$ 可行的子树树的形态唯一。之后只要做一遍最短路就可以了。

[Y_UME wrote on 2015-10-04T15:00:49]

---

