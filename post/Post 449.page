# Topcoder SRM 650 Div 1 Level 3 LegendOfAdlez

有一棵$n(\leq 50)$个顶点的树，从$0$到$n-1$标号，保证$n-1$号点的度数为$1$，边上有门，有些门是上锁的，需要用一把钥匙来打开，现在每个点除了$n-1$号点都可以放不超过一把钥匙，每把钥匙都可以打开当前能走到的任意一道门，但是只能用一次，现在有一个人从$0$号点出发，求有多少种摆放钥匙的方案，使得不论这个人如何乱开门，最终都能走到$n-1$号点，而不会在中途因为没有钥匙打不开门而无法到达$n-1$号点。

[quailty wrote on 2016-06-03T17:05:30]

---

push~

[shiina_mashiro wrote on 2016-06-06T10:56:26]

---

 感谢lisy师兄和小胖师兄，

如果$0$号点和$n-1$号点之间的路径上没有锁，那么答案是$2^{n-1}$，否则考虑缩点，使得每条边上都有锁，

关注到这样一个事实，如果存在一个包含$0$号点且不包含$n-1$号点的连通子图使得捡到的钥匙数不大于需要开锁的次数，那么就走不到$n-1$号点了，

于是砍掉以$n-1$为根的子树，最后答案乘上$2^{size[n-1]-1}$，

然后$dp[i][j]$表示考虑以$i$号点为根的子树，有多少种摆放钥匙的方案，使得对于所有包含$i$号点的连通子图中，捡到的钥匙数减去需要开锁的次数的最小值为$j$（相当于考虑最坏情况），

转移时选择会导致钥匙亏损的子树向下走即可，但是无论是否走下去均要统计方案数。

[quailty wrote on 2016-06-08T06:36:26]

---

