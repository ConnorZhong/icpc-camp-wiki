# A New One and an Old One

Codeforces 上刚刚结束的 8VC Venture Cup 2016 比赛中的 E 题 Orchestra [链接](http://codeforces.com/contest/627/problem/E) 题意是

>给出 $r \times c$ 的矩形中有 $n$ 个黑点，统计包含至少 $k$ 个黑点的子矩形的数量。
>$r, c, n \leq 3000, k \leq 10$


在讨论中 @Sd_Invol 提到了 Codeforces Round #213 的 E 题 Empty Rectangles [链接](http://codeforces.com/contest/364/problem/E)。它的题意是

>给出 $r \times c$ 的矩形中，统计包含至少 $k$ 个黑点的子矩形的数量。
>$r, c, n \leq 2500, k \leq 6$ 时间限制 12 秒

两个题目的共同点是 $k$ 很小，不同的地方在于后一道题黑点的数量可能很多。

---

# 剧透

如果之前有解决子矩形问题的经验，我们知道一种常规的做法是枚举子矩形的上、下边界，把二维的问题转化为一维的问题（没有经验的同学，你做过最大权子矩形 [链接](http://poj.org/problem?id=1050) 吗？）。

但是，如果我们在这里枚举了子矩形的下边界 $lo$ 和 上边界 $hi$，至此我们已经花去了 $O(r^2)$ 的时间，我们很难在低于 $O(n)$ 的时间内计算出两个边界之间的答案。为此，我们需要考虑相邻两个上边界 $hi$ 和 $(hi + 1)$ 之间的关系。

为了相邻两个边界之间的关系更清楚，我们来仔细看一下，到底需要计算什么东西。如果设 $s(i)$ 表示矩形 $[lo, hi] \times (-\infty, i]$ 内的黑点数量，那么很明显，我们就是要统计满足 $0 \leq i < j \leq c$ 而且 $s(j) - s(i) \geq k$ 的 $(i, j)$ 数量。

那么从上边界从 $hi$ 变动到 $(hi + 1)$ 的时候，这个数量为什么会产生变化呢？这是因为对于新出现的黑点 $(x, hi + 1)$ 来说，它会使得 $s(x), s(x + 1), s(x + 2), \ldots$ 相比原来增加了 $1$。这可能导致一对 $i < x \leq j$ 的 $(i, j)$，从原来 $s(j) - s(i) = k - 1$ 变成了 $s(j) - s(i) = k$。所以，我们想着能不能快速地算出这个增量。

绕了这么久，终于有一个跟 $k$ 直接相关的东西了。因为 $k$ 很小，我们可以看出 $s(j) - k + 1 = s(i) \leq s(x)$ 所以 $s(j) \leq s(x) + k - 1$，同理 $s(x) \leq s(j) = s(i) + k - 1$ 所以 $s(x) - k + 1 \leq s(i)$。也就是说 $s(i), s(j)$ 的取值都限制在了很小的值域内。

为了避免值域很小，定义域却很大的问题，我们尝试一下维护 $s(\cdot)$ 的每个值，容易发现，每个黑点其实对应了一个函数值的跳跃点。所以只要拿一个数据结构维护一下，每次把 $s(x)$ 两遍各 $(k + 1)$ 的段拿出来，就可以算出增量了。

所以这究竟是什么数据结构呢？看似需要解决的问题是 (a) 插入一个数 (b) 查询某个数的前驱、后继。如果直接使用 std::set 甚至 vEB 树，只能得到 $O(\log n)$ 和 $O(\log\log n)$ 的复杂度。但是这就涉及一个常用技巧（见备注），如果我们把所有数提前插入好，把插入变成删除，那么只要花费 $O(1)$ 就能完成操作了。

至此，我们就解决了问题。复杂度是 $O(rc + rnk)$。

至于后一道题，其实稍加转换，就可以用上面的算法解决，你能想到吗？

---

备注：对于不熟悉这个技巧的同学，推荐思考下面这道题。
>给出 $n$ 个数 $a_1, a_2, \ldots, a_n$，$O(n^2)$ 求出所有 $\frac{n(n+1)}{2}$ 个区间中的中位数。



[ftiasch wrote on 2016-03-01T12:20:24]

---

不错哦

[xiaojudou wrote on 2016-03-01T13:35:06]

---

interesting

我想不到。

[sd_invol wrote on 2016-03-02T05:18:44]

---

@Sd_Invol#3200 但是本船读了几个提交，发现各种花式暴力……

[ftiasch wrote on 2016-03-02T06:40:31]

---

那个$O(n^2)$求中位数的技巧是事先全部插好用链表之类的串起来, 然后根据删掉的数和当前中位数的大小移动中位数的指针?

[zimpha wrote on 2016-03-02T09:09:41]

---

@zimpha#3202 对。

[ftiasch wrote on 2016-03-02T10:55:09]

---

@zimpha#3202 您能具体来说一下吗？ 谢谢！

[SCaffrey wrote on 2016-03-02T12:02:42]

---

@SCaffrey#3204 

固定枚举的区间的左端点$l$，然后把$[l,n]$内区间的数字排好序链表串起来。考虑右端点$r$从右往左移动过程要逐渐删去链表中的数字，顺便看删去的数与当前中位数的大小关系来维护中位数的位置。


[sd_invol wrote on 2016-03-02T12:49:34]

---

@Sd_Invol#3205 每次都排序的话还是$O(n^2\log n)$的, 应该一开始就排好序, 把每个数都插入
当处理完一个区间左端点之后, 把$[l,n]$都插回进去, 然后删掉$l+1$, 这样复杂度才是$O(n^2)$的吧

[zimpha wrote on 2016-03-03T07:34:29]

---

@zimpha#3214 是的 ![image](http://static.icpc-camp.org/flarum-emotion/blue-cat.jpg)

[sd_invol wrote on 2016-03-03T09:56:59]

---

@zimpha#3214 

这么写对船来说太麻烦啦。本船喜欢先排序，每次计算 $[l, *)$ 的时候，for 一遍这个序造出链表。

[ftiasch wrote on 2016-03-03T11:56:46]

---

