# Codeforces Round #371 题解

# A. Sonya and Queries

把每个数字转化为 $18$ 位的二进制串，表示它能被这个二进制串匹配，开一个 $2^{18}$ 的数组存每种二进制串有几个就行了。

# B. Searching Rectangles

首先，假设存在一条横线分开两个矩形。我们可以二分横线的位置 $x$，找到最小的满足 $(1, 1) - (x, n)$ 中包含至少 $1$ 个矩形的 $x$. 如果 $(x + 1, n) - (n, n)$ 中也至少包含 $1$ 个矩形，说明横线 $x$ 确实分开了两个矩形。否则，还需要找一条竖线 $y$ 分开两个矩形。

分开之后，每个矩形可以做 $4$ 次二分确定上下左右边界。

我觉得我的实现还不错，可以看一下。:)

# C. Sonya and Problem Without​ a Legend

经典贪心。首先把 $a_i$ 改成 $a_i - i$，这样就变成了单调不下降的版本。然后每次往后面加一个数，如果不满足单调不下降，那么就把最后两段合并，一起变成他们的中位数。原题的话可以用可并堆，这样是 $O(n \log n)$ 的，但是这题直接用 std::nth_element 算中位数就行啦。

# D. Animals and Puzzle

首先计算 $\mathrm{dp}(i, j)$ 表示以 $(i, j)$ 为左上角的最大正方形边长。
每次询问时二分答案 $l$，那么就是要问某个矩形内是否有 dp 值不小于 $l$，这个只要二维 ST 表就行了。

# E. Sonya Partymaker

有点细节的 dp。假设 $n$ 和 $1$ 之间的间隙是最大的，设为 $M$.  显然最终答案 $\leq M$.

二分答案 $a$（第三次出现了？），因为 $a < M$，所以 $1, n$ 之间的空隙一定需要左右格子覆盖。
一个有用的结论是，$1$ 和 $2$ 其中之一需要向左覆盖。否则的话，比如说是 $3$ 向左覆盖，那么 $1$ 其实对答案没有影响，可以让它也向左覆盖。

所以，我们如果枚举 $1, 2$ 谁向左覆盖后，可以用 $f(i)$ 表示前 $i$ 个点一共盖住多少。有三种情况可以转移：

1. $i$ 向右覆盖，那么要求 $f(i - 1) \geq a_i - 1$，可以用 $a_i + a$ 更新答案；
2. $i$ 向左，要求 $f(i - 1) \geq a_i - a - 1$，用 $a_i$ 更新答案；
3. $i$ 向左，但是 $(i - 1)$ 向右，这种要求 $f(i - 2) \geq a_i - a - 1$，同时用 $a_{i - 1} + a$ 更新答案。

---

我的代码 https://code.icpc-camp.org/ftiasch/acm-icpc/src/master/codeforces/713-codeforces-round-371

[ftiasch wrote on 2016-09-15T08:52:57]

---

