# The 18th Zhejiang University Programming Contest B Liblume

题目链接：http://acm.zju.edu.cn/onlinejudge/showContestProblem.do?problemId=5733
题意应该是给个n\*m的小写字母组成的矩阵，你可以交换任意两行任意次，然后选出一个面积最大的子矩阵使得这个矩阵的所有行和所有列都回文；n * m <= 2e5；目前想到的只有n>m可以O(m\*m\*n)，而且这个复杂度还不知道能不能过。。以及顺便问一下有么有这场比赛的题解呢？

[takio wrote on 2018-04-14T17:25:31]

---

<del>应该就是这个复杂度。</del>

[ftiasch wrote on 2018-04-18T08:59:18]

---

但是我还没有想到n<m的情况应该怎么做。。

[takio wrote on 2018-04-20T07:01:46]

---

尝试召唤一只@zimpha 

[takio wrote on 2018-04-20T07:13:41]

---

@takio#5632 这个复杂度当然不对啊，标程是$O(nm \log n)$的，努力努力可以$O(nm)$的，我下班后来仔细写一写啊。

[zimpha wrote on 2018-04-20T10:49:56]

---

@zimpha#5633 不如先考虑所求子矩阵每一行长度都是奇数（偶数同理），那么枚举这些行的回文中心是在第$c$列，然后用manacher可以知道第$i$行以第$c$列为回文中心的回文半径$r_i$。

假设你知道所求子矩阵有多少列，那么只要把这些半径为$r_i$的回文串，按照列长截断，然后把相同的组成一对，就得到了一个回文子矩阵。

你观察下就知道你需要枚举的列长只有$O(n)$种（行数）。你先把这些回文串排序，同时求出相邻两个串的lcp。之后，从大到小枚举列长，只会发生两种事件：1. 一个回文串加了进来，2. 相邻两组回文串合并成一组相同的回文串。这个仔细想想就知道可以用后缀数组优化成$O(n \log n)$，于是总的复杂度就是$O(nm \log n)$了啊。

然后注意到上面的复杂度里面的log一部分来自于排序回文串，另一部分来自排序事件点（后缀数组和lcp都可以线性，无视之）。如果一开始只建回文树，然后一遍dfs就能把回文串排序，相邻两个串的lcp其实就是树上的lca的深度，然后lca显然是可以$O(n) \sim O(1)$的啦。另外考虑事件点排序，你可以把所有$m$列对应的事件点一起用基数排序，这样也就把log去掉了，总之就搞成了$O(nm)$。


[zimpha wrote on 2018-04-20T11:52:12]

---

感谢！大概都弄懂了（zimpha依然是那么高产

[takio wrote on 2018-04-21T15:36:40]

---

