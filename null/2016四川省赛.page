A. Nearest Neighbor Search\[hx\]
================================

简单的写法是对三个坐标分别处理，即看 $x_0$ 是否在 $[x_1,x_2]$ 内。

B. Odd Discount(补)
===================

设 $a[n]$ 表示 $n$
在二进制下是否有奇数个1，$mask_i$表示第i个优惠转化成二进制下的状态。
考虑将平方拆开，那么我们需要计算
$$\sum_{i=1}^{n}c_i \sum_{j=1}^{n}c_j \sum_{k=0}^{2^n-1}(a[k\ \&\ mask_i]\ \&\ a[k\ \&\ mask_j])$$
实际上有 $$
\sum_{k=0}^{2^n-1}(a[k\ \&\ mask_i]\ \&\ a[k\ \&\ mask_j])=(mask_i=mask_j\ ?\ 2^{n-1}:2^{n-2})
$$ 于是就能很容易的算出答案了。

C. Eight Queens
===============

D. Longest Common Subsequence(补)
=================================

令$f[i][j]$表示b的第i段，匹配到a的第j位的LCS，那么考虑从i-1推到i，枚举第i段总共匹配了k个，从小到大枚举j，那么$f[i][j]=f[i-1][p]+k$,满足a\[p..j\]中有k个能匹配b的第i段，在此情况下p尽量大，随着j的增大，p是非降的，滑窗一下即可。

E. Coins
========

按照硬币情况为0,1,2+分类讨论

F. Floyd-Warshall\[lyj\]
========================

其实就是一颗树上有不超过100条非树边,每条非树边对应两个点,总共最多有200个被非树边连接的点,对于询问u,v只需要考虑u,v只经过数边或几条非树边即可,第一种情况直接lca,第二种情况预处理出所有的非树边连接的点到所有点的距离,然后枚举u,v经过的非树边的点是哪个即可,两种情况取最小值

G. Road History\[hx\]
=====================

如果一个连通块里有奇数环，那么这个连通块的任意两个点之间都有 odd drive
，否则这个连通块能够黑白染色，只有黑的和白的之间能够配对，用并查集维护一个连通块是否含有奇环，块内黑色点和白色点的个数，以及对答案的贡献。

H. Around the World\[hx\]
=========================

一个点和父亲所连边的 $c_i$
即这个点到达的次数，首先算出这个点向儿子边走的方案数，即首先将它向每个儿子连的边两两配对代表走过去和走回来，然后对每个边对任意排列，最后分配每次到达它时向儿子走多少次。设每个点到达次数为
$a_i$ ,它的儿子集合为 $son_i$，那么有 $$
ans = \prod_{i=1}^{n} \frac{(2a_i)!}{a_i!}\times \binom{a_i-1+\sum_{j\in son_i}a_j}{a_i-1}\times (\sum_{j\in son_i}a_j)!
$$

I. Longest Increasing Subsequence\[hx\]
=======================================

用最小表示法枚举最后五个数的大小关系，再随便DP一下。

J. Matrix Transformation\[lyj\]
===============================

每个点记录一下右指针和下指针,像链表那样维护即可
