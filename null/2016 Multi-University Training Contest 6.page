1001 A Boring Question\[lyj\]
=============================

打表找规律

1002 A Simple Chess\[lyj\]
==========================

dp+lucas

1003 A Simple Nim\[lyj\]
========================

打sg表找规律

1004 Magic Number
=================

1005 Master Zhu
===============

1006 Stabilization(补)
======================

可以发现对于相邻的两个元素a,b，若a&lt;=b，对不稳定性的贡献就是b-a，则当X影响到了a,b不同的位中的最高位时，答案才会变成(a\^X)-(b\^X)，否则就是(b\^X)-(a\^X)<br>
由于每个数字最多只有20位,可以考虑按相邻数字的位数进行分类,然后枚举X的值<br>
设cnt\[i\]\[j\]表示所有相邻的数a,b(不妨设a&lt;=b)不同的位中最高位是第i位,b的第j位-a的第j位的值的和<br>
如果直接枚举X再算答案,复杂度是2\^20\*400,会超时,所以求答案的时候要利用dfs枚举X,然后在枚举的时候计算当前X对应的答案<br>
dfs的具体过程就是,设当前正在枚举X的第o位,不妨设为d\[o\],然后计算cnt\[o\]\[i\]对这种方案的答案的贡献,计算就是若d\[o\]\^d\[i\]=1,则sum-=
cnt\[o\]\[i\],否则sum+= cnt\[o\]\[i\]<br>
因为若d\[o\]=1,则对于不同的最高位为o的那一对来说符号会改变,而d\[i\]=1,则第i位的答案的符号也会改变<br>
所以<br> $d[o]xord[i]=1$表示cnt\[o\]\[i\]的贡献为负<br>
$d[o]xord[i]=0$表示cnt\[o\]\[i\]的贡献为正

1007 This world need more Zhu(补)
=================================

这题把询问分两类处理<br>
第一类是询问子树的出现了a次的数的和与出现了b次的数的和的gcd,直接把dfs序弄出来,用区间的莫队即可<br>
第二类是询问树的一条链上的出现了a次的数的和与出现了b次的数的和的gcd,用树上莫队即可<br>
树上莫队就是维护的一条链的lca的影响是不被考虑的,最后算询问的答案的时候再考虑lca的影响<br>
树上莫队将一个点移到另一个点时,不需要真的模拟这个点移到另一个点的过程,只需要开个vis数组记录哪些点是访问过的<br>
然后先爬深度大的那个点,爬到深度相同时再一起往上爬,直到爬到同一个点为止<br>
访问过的点就消去它的影响,再把它标记为未访问,未访问过的点就增加它的影响,再把它标记为访问<br>
其实区间的莫队在转移时也可以像树上的莫队那么搞,把它当作一条链,同样开个vis数组,然后把1到n的点当成深度为1到n的点<br>
转移也是像xor那样转移,处理询问时再单独加上最左边的点的影响<br>
要把点重标号来维护每个数字出现的次数

1008 To My Girlfriend(补)
=========================

f\[i\]\[j\]\[k\]\[z\]表示前i个物品,已选代价为j,必选的有k个,必不选的有z个的方案

1009 Up Sky,Mr.Zhu
==================

1010 Windows 10(补)
===================

如果p大于q，直观的想法是每次尽量减，直到减到q，或者在某次多减一点，再加回来，dfs即可，需要注意的是停顿可以用加来代替。

1011 Zhu’s Math Problem
=======================

总结反思
========

没有浪哥啦！怎么种庄稼！
