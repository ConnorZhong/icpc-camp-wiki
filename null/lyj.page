[awesome](3.jpg)
================

cf722E
======

题意:是给一个n\*m的网格,有个人要从(1,1)走到(n,m),只能往下或往右走,一开始他的能量为s,网格上有k个障碍,每到达一个障碍能量都会变成当前能量/2向上取整,他每到一个格子向下和向右走的概率为1/2,问他到达(n,m)时的期望能量为多少<br>
题解:<br> 由于每到一个障碍格子能量都会减半<br>
所以经过20次以上的障碍物能量就一定是1<br>
所以我们可以枚举经过障碍物的数量v<br>
再看恰好经过v个障碍物的路径有多少即可<br>
先考虑若一个障碍物都不经过的路径怎么算<br>
令path(a,b)表示坐标点a到坐标点b的任意路径数<br>
若a.x&gt;b.x||a.y&gt;b.y那么就是0<br> 否则令x=b.x-a.x,y=b.y-a.y<br>
方案数为(x+y)!/x!/y!<br> 因为从a到b要向下走x次向右走y次<br>
所以先把x+y中方案全排列一下<br> 又因为同一方向的方案不需要考虑顺序<br>
所以要除以x!和y!<br> 令O为起始点(1,1)<br>
把所有障碍物按x+y从小到大排序<br>
只有x+y小的障碍格才有可能到达x+y大的障碍格<br>
f\[i\]表示到达第i个障碍格且不经过别的障碍格的路径数<br>
f\[i\]=path(O,P\[i\])-sigma{f\[j\]\*path(P\[j\],P\[i\]),(j&lt;i)}<br>
要得到到终点的路径数就只需要假设终点有个障碍点就可以算出来了<br>
再来考虑恰好经过v个障碍点的情况<br>
令G(i,v)表示到达第i个障碍点前的路径上还经过了v个障碍点<br>
G(i,v)=path(O,P\[i\])-sigma{G(j,v)\*path(P\[j\],P\[i\]),(1&lt;=j&lt;i)}<br>
-sigma{G(i,j),(0&lt;=j&lt;v)}<br>
就是起始点到P\[i\]的所有路径减去其它障碍点总数大于v的所有路径<br>
和其它障碍点总数小于v的路径<br>
用总路径数减去到终点的经过障碍物点&lt;=20的路径数就是<br>
其它的能量为1的总路径数了<br> 注意要预处理阶乘的逆元<br>

cf724E
======

题意:最多10000个城市标号1到n,每个城市两个属性s,p表示这个城市生产了p个产品,能够被卖s个产品,对于城市i,j若i&lt;j,则i可以将最多c个物品给j,每对点最多一次转移,问最多能够卖掉多少产品<br>
题解:没想到网络流找最小割最后可以转换成dp找最小割<br>
若直接用网络流来做<br> 新建s,t<br>
s向每个点i连容量为pi的弧,表示每个点有pi个产品<br>
每个点向t连容量为si的弧,表示每个点最多被卖si个产品<br>
对每个点对(i,j),i&lt;j<br>
连容量为c的弧表示i城市可以将c的产品转移到j城市<br>
直接跑网络流显然会tle<br> 因为最大流等于最小割<br>
不妨考虑一下最小割等于什么<br> 假设最后最小割把点集分成两个部分A和B<br>
那么最小割的容量等于<br> ∑si + ∑pi + ∑c<br> i∈A i∈B i∈A,j∈B,i!=j<br>
这玩意其实是可以用dp求的<br>
设f\[i\]\[j\]表示前i个点,A集合中除了s还选了j个点的最小割容量<br>
考虑第i个点属于A集合还是B集合有转移方程<br>
f\[i\]\[j\]=min{f\[i-1\]\[j-1\]+si,f\[i-1\]\[j\]+pi+j\*c}<br>
最后的答案就是f\[n\]\[i\]中的最小值了<br>
所以不要一想到网络流过不了就不深入地思考网络流了

cf724G
======

我：浪哥，我不会搞G啊！<br> 浪哥：这种计数题你会做就怪了<br>
我：\_(:з」∠)\_<br>
题意：给一个无向图,不含重边和自环,定义有趣的三元组(u,v,s)满足u&lt;v,且有一条u到v的路径,路径上的边权异或和为s,求所有的有趣三元组中的s的和<br>
题解：
不妨先假设图是联通的,如果不联通,对每个联通块单独计算答案再相加即可<br>
对于一个连通块<br> 假设我们固定了u,v来统计答案<br>
先随便找一条u到v的简单路,设为p0<br> 然后考虑其它u到v的路径p1<br>
若p1是简单路,可以看成p0p1形成的环再xorp0的值<br>
也就是一个环的xor值再xorp0的值<br> 若路径上有环<br>
可以看成从u开始到环上一个点绕一圈再回到u再走到v<br>
其实就是p0的值xor环上的值<br>
所以问题变成了u到v的简单路再拼一些环的总的不同的xor值的和<br>
并不需要找出所有环<br> 先构一颗树,然后枚举虚边弄出这些环的xor值即可<br>
其它环的xor值都可以由这些环的xor值xor得到<br>
考虑这些环能够组成的不同的xor值有哪些<br>
只需要把每个值看成一个60位的向量<br> 每一位为0或者1<br>
两个数的xor就可以看成是两个数对应向量在模2意义下的相加<br>
然后看这些向量能组合出哪些不同的向量<br>
只需要找到这个空间中的一组基即可<br> 找基的时候可以用高斯消元<br>
找到一组基后空间中的所有向量都可以用这些基表示<br>
每个基向量前的系数是0或者1<br> 所以总的向量个数为2\^r<br>
然后来考虑怎么算答案<br> 考虑每一位<br> 设p0的xor值的第i位是b<br>
考虑所有的基向量<br> 一:<br> 若它们中有一个第i位为1<br>
那么2\^i对答案的贡献为2\^(r-1)次<br>
因为单独把这个第i为为1的向量拿出来,不妨设这个向量为v<br>
剩下的向量有2\^(r-1)种组合<br> 组合的结果不是0就是1<br>
若是0的话,选v,每种情况贡献为2\^i,不选v则为0<br>
若是1的话,选v,每种情况贡献为0,不选v则为2\^i<br>
两种情况相加总共有2\^(r-1)个2\^i的贡献<br> 二:<br>
若所有基向量第i位为0<br> 那么贡献为b\*2\^r\*2\^i<br>
算一个连通块总的答案只需要随便从一个点u开始dfs<br>
记录一下u到各个点的xor值<br>
设oneNum\[i\]表示这些值中第i位为1的有多少个<br>
设zeroNum\[i\]表示这些值中第i位为0的有多少个<br> 那么枚举每一位i<br>
若所有基向量中第i位为1的至少一个<br> 贡献为2\^i\*2\^(r-1)\*C(n,2)
若所有基向量中第i位为1的没有一个<br>
贡献为2\^i\*2\^r\*oneNum\[i\]\*zeroNum\[i\]<br>
总复杂度O(mlog(1e18))<br>

cf718A
======

题意：给一个长度不超过2e5的十进制无符号小数,最多可以对它取整t次,使得最后的数字最大<br>
题解：显然若小数点后没有&gt;=5的数就不需要四舍五入，否则找到最左边的那个&gt;=5的数的位置,不妨设为j，显然j变一次和先边j右边的数再变j的效果是一样的，所以只需要四舍五入到j-1位再把j即j右边的数变成0，然后考虑进位，一直这么搞,直到没有次数了或已经四舍五入到整数了

cf718C
======

题意：给一个序列ai,支持两种操作,1:把区间\[l,r\]的每个数增加x,2:求区间每个数x的f(x)的和,f(x)为第x个fibonacci数的值

题解：竟然没想到用线段树每个点维护一个矩阵,too young too naive......<br>
线段树每个点维护一个矩阵和一个向量,向量表示该点的子树的fibo数的和

BZOJ1878
========

题意：n个数字a\[i\]和m个询问,每次询问给出区间\[l,r\]问\[l,r\]中有多少个不同的数

题解：nex\[i\]表示与a\[i\]相同的离i最近的且&gt;i的位置j，先把从左到右第一次出现的数字所在位置在树状数组中更新为1，然后把询问按左端点排序，然后边更新边查询即可

cf685E
======

题意：给出n(&lt;=1e3)个点和m(&lt;=2e5)条边,边按给出顺序标号1到m，q(&lt;=2e5)个询问(l,r,s,t)表示l时刻开始从s到t的最小时刻是否小于等于r,每个时刻只能走编号大于等于当前时刻的边，走过某条边后当前时刻变为边的标号

题解：把询问按l从小到大排序，dp\[i\]\[j\]表示i到j的最小时刻是多少,然后从大到小枚举边j,更新dp\[\]\[\],然后把l=j的询问处理了

cf685D
======

题意：给出n(&lt;=1e5)个点和边长k(&lt;=300)，对于每个x(1 to
n)求有多少个k\*k的矩阵恰好覆盖了x个点

题解：每个矩阵都由它右上角的点唯一确定，对于一个点(x,y)更新{(a,b)|x&lt;=a&lt;=x+k-1,y&lt;=b&lt;=y+k-1}即可。将x离散化，对于每个点(x,y)将(x,y)看成插入将(x,y+K)看成删除，然后按y从小到大扫，再枚举x到x+K-1边更新边统计答案即可

百度地图的实时路况（计蒜客）
============================

题意：设d(u,v,w)表示u到w不经过v的最短路长度，若不存在则等于-1，求sigma{d(u,v,w)}(u,v,w:1
to n && u!=v && v!=w && n&lt;=300)

题解：floyd竟然还能分治，浪哥太强了！k的那一层习惯上是枚举1到n，但是实际上枚举每个点的顺序并不是唯一的。每次把当前的点集拆成两半(l~mid,mid+1~r),拿左边那一半的点用floyd算法更新数组，再递归处理右边那一半的点。然后再还原数组后用右边那一半的点更新数组，递归处理左边那一半的点。当l==r的时候数组里存的就是没有经过点l的全源最短路，总复杂度O(n\^3logn)

hdu5716
=======

题意：给一个长度为1&lt;=m&lt;=2e6的包含各种字符的串S和1&lt;=n&lt;=500个包含1到62个字符的集合,求S中有多少个子串满足子串的每一位i对应的字符在集合si中

题解：a\[i\]\[j\]表示字符i是否在集合j中,c\[j\]表示从当前所扫的位置i往前数第j个位置开始的子串是否可行,然后用bitset维护a\[\]和c

hdu5715
=======

题意：给一个长度n&lt;=10000的序列，把序列分成连续的m&lt;=10份，其中每份长度&lt;=L(1&lt;=L&lt;=N)，求使得每组异或和的最小值最大的方案中的最小值

题解：二分答案，f\[i\]\[j\]表示前j个数能否分成i份，用trie树维护

hdu5713
=======

题意：给出一个n&lt;=14,m&lt;=n\*(n+1)/2的无重边的无向图和一个k，求有多少种删边方案(可以不删)使得图恰有k个连通块。

题解：dp\[i\]\[k\]表示点的状态i，连通块个数k，cnt\[i\]表示状态i的总边数，f\[i\]表示i的导出子图中有多少种删边方案使i代表的点联通，g\[i\]表示i的导出子图中有多少种删边方案使i代表的点不联通。设j为i的真子集，j不为空，且j包含i中标号最小的点
f\[i\]=2\^cnt\[i\]-g\[i\] g\[i\]=sum(f\[j\]\*2\^cnt\[i-j\])
dp\[i\]\[k\]=sum(dp\[i-j\]\[k-1\]\*f\[j\])

cf671D
======

题意：给出一颗树和一些往根延伸的路径，每条路径一个正整数权值，选出一个路径的集合，使得能够包含所有的边且总权值最小

题解：dp\[i\]表示i的子树的边以及i到fa\[i\]的边全部覆盖的最小代价，用线段树按树的欧拉遍历序维护dp值

hdu5714
=======

题意：某个可以用树状数组维护的题

题解：用树状数组维护
