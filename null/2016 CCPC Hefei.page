1001 传递\[hx\]
===============

如果某个点a所连的点b连向了a所连的点c，那么不可能，可以 $O(n^2)$
DFS，或者 bitset 爆搞。

1002 凯旋三兵
=============

1003 朋友\[hx\]
===============

参考一排 n
个硬币，每次可以翻转一个正着的硬币，并且把它之前的硬币都翻转，胜负只和第一个硬币的初始状态有关。因此，对于这题胜负只和根所连的边里
1 的数量有关。

1004 平行四边形(补)
===================

首先可以旋转坐标轴，使得其中一条直线变成 x
轴，然后就会发现只需要对每个点算出一个值，取最大值和最小值之差即可。不过这样如果用
double
会很慢，如果用float精度会很差。因此我们不能先旋转坐标轴，而是直接用原坐标推出一个公式。

1005 扫雷\[lyj\]
================

浪哥教我状压dp f\[i\]\[j\]表示前i列前4个格子状态为j的方案,然后转移就行了

1006 跳蚤国王的游戏
===================

1007 小R与手机(补)
==================

浪哥教我lct<br> 一直以为搞acm这玩意再也用不到了<br>
具体来说就是每个点最多一条出边<br> 对于一个连通块,大小为n<br>
里面若是n-1条边那就是一个数<br> 否则就是一个树加一条环边<br>
用lct来维护这个东西<br> 强行把环上的某个点设为根<br>
那么它连出去的那条边单独记录一下即可设为t<br>
同时还要对环上的点打标记<br> 对于修改操作把f\[u\]变成v<br> 若u在环上<br>
若u是根就把u-&gt;t到u路径上的标记清除,再把u,v相连<br>
否则就清除u所在树的根的t到u所在树的根的标记<br> 再cutu与它父亲的边<br>
再link根与根的t<br> 再link(u,v)<br> 若u不在环上<br> 若u是根,就link
u,v<br> 否则cut u与其父亲的边再link u,v<br>
这里的父亲不是lct里的父亲,而是原来的树中对应的父亲<br>
link的时候要分u,v是否在一个联通块里讨论<br> 不在就直接连<br> 否则<br>
u肯定是这棵树的根<br> 要把u到v之间的路径给标记了<br>
然后让u-&gt;t变成v<br> cut时不能用makeRoot<br> 否则根就变了<br>
判输出就看这个点对应的树根是否在环中<br> 在环中输出-1<br>
否则输出这个根所对应的标号<br>

1008 异或密码\[hx\]
===================

由于 n 和数都比较小，所有可以暴力预处理。

1009 最大的位或\[lyj\]
======================

把l,r的二进制从低到高补到相同位(不足补0),从高到低找到第一个不同的数字,从此之后的数字都是1

1010 最大公约数
===============
