1001 Another Meaning\[lyj\]
===========================

设f\[i\]表示前i个字符的方案数,用kmp维护一下

1002 After a Sleepless Night(补)
================================

首先可以确定根，肯定是值全为n的一条链的两端，到底是谁并不影响其他点，所以我们让根为标号小的那个点能使字典序尽量小。<br \>
定好根后，每个点原来的的权值要么就是输入的值，要么比输入的值要小，除去那些定了的值，对剩下的点，从大到小枚举每个没被定的值，尽量把它赋给标号大的点，这里用大根堆维护一下即可。

1003 Bouds\[hx\]
================

$O(n^{2}2^n)$的做法很显然，注意下常数就能过。$O(n2^n)$的做法需要用到高维前缀和。

1004 Filling
============

1005 Lucky7\[lyj\]
==================

CRT+容斥

1006 Substring\[hx\]
====================

用后缀自动机很容易写，后缀数组也可以。

1007 Treasure(补)
=================

先求出树的dfs序,对于一组钥匙和宝箱,设钥匙在A点,宝箱在B点,起点为s,终点为t,若s和t确定了,那么就确定了唯一的一种方案<br>
设C=lca(A,B)<br> 1.若A!=C&&B!=C<br>
那么拿到这个宝箱只需要满足s在A的子树,t在B的子树即可,用dfs序表示的话就是一段连续的区间乘以一段连续的区间,如果设钥匙对应的点的区间在y轴上,宝箱对应的点的区间在x轴上,那么满足条件的点对相当于一个矩阵的样子<br>
2.若A=C&&B!=C<br>
那么设u是A的儿子且u是B的祖先或u=B,那么满足条件的点对对应于两个矩阵<br>
3.若A!=C&&B=C类似<br> 4.若A=C&&B=C<br>
如果直接用矩阵表示的话可以达到O(n\^2)级别<br>
若反过来考虑,只考虑不能取到钥匙的区间的话,对于所有类似于A=C且B=C的询问的话,对应的总区间数顶多是O(n)级别的<br>
所以我们可以先在答案中加上这个w,再对应出几个-w的矩阵<br>
现在问题变成了平面上有O(n)个矩阵,每个矩阵都会使覆盖的点加上一个特定的值,求权值最小的点<br>
用扫描线+线段树进行区间修改,单点查询最小值即可

1008 Turn Game
==============

1009 String problem\[hx\]
=========================

考虑到第一次使用一个数字x需要的代价为$b_x$，之后每次需要$a_x$，一个很显然的做法是枚举每个数用不用，然后就是一个经典的最小割模型，但这样显然会TLE。实际上，对每个数x建立一个点，它的消耗为$b_x-a_x$，然后如果某个收益需要用到这个数字x，就向它连边，这样就只需要跑一次网络流了。

1010 The All-purpose Zero\[hx\]
===============================

用二分栈做最长上升子序列，遇到0相当于栈中$sta_i$的值+1赋给$sta_{i+1}$，不必真的去暴力赋，只需要记录下当前零出现的个数即可。

1011 Where Amazing Happens\[lyj\]
=================================

sb题

1012 Bubble Sort\[hx\]
======================

显然一个数字会被每个在它后面的比它小的数字向右交换一次，原位置右移交换次数就是它最右边的位置，最左边的位置是它初始位置和目标位置的较小值。
