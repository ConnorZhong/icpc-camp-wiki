302A\[hx\]
----------

$f[i][j][k]$表示前$i$个人写了$j$行总共$k$个bug的方案数,$f[i][j][k]$可以转移到$f[i+1][j][k]和f[i][j+1][k+a[i]]$

302B\[lyj\]
-----------

设a\[i\]\[j\]表示i到j的最短路长度为多少，用bfs预处理，然后判断有没有解。最后保留的路径要么是两条分开的，要么是中间一段共用，两头分开的。要是第一种情况的话就是保留两条最短路即可，第二种情况的话枚举共用的那一段的两个端点，然后更新答案即可

302C\[hx\]
----------

状压DP,$f[i][S]$表示做到第$i$个字符已经搞定的字符串的集合为$S$的方案数.

考虑要在第$i$个字符搞定某个字符串,那么要么改变它的第$i$个字符,要么把所有和它在第$i$个字符相同的字符串的第$i$个字符改变,既然要改变,就肯定可以把这些字符串也搞定.

302D\[lyj\]
-----------

树形dp,设f\[i\]表示以i为根的子树合法的方案数。对于每个点i，若它到儿子v的边修复,就有f\[v\]种，不修就只有一种方案，所以f\[i\]=∏{f\[v\]+1}。令a\[i\]表示以i为首都的答案，若一开始以1为根，显然a\[1\]=f\[1\]，然后再从根开始递推子树节点的a\[i\]即可，由于cf的数据特别坑，所以要特殊处理子树方案+1恰为10\^9+7的情况

302E
----

305A\[hx\]
----------

先找出两个高度变化的循环节,然后扩展欧几里得,再算一算搞到合法

305B\[hx\]
----------

从小到大排序,依次插入,更新答案

305C\[hx\]
----------

每加入或删除一个数,枚举它的约数,容斥搞一搞

305D\[lyj\]
-----------

把x,y坐标看成点,点(x,y)看成连接x和y的边就是二分图了(x==y看作不同的点)，然后每次从一个有边的点开始dfs,蓝红交替地染，每确定一条边的答案就把这条边删掉。若开始dfs的点还有边，也交替地染，直到所有边的答案确定为止

305E\[hx\]
----------

1.做法和CF666E一样,而且更简单,先构出后缀自动机,对后缀自动机上的每个点建一个线段树维护每个字符串在这个点的Right集合大小,遍历parent树线段树合并即可.

2.把所有串串起来,中间用不同的特殊的字符,其实直接当整数做就行了<br>
num\[i\]表示第i个字符开头的串对应于原来的第num\[i\]个串的子串<br>
把sa,rank,height,rmq都弄出来<br>
对于询问\[L,R,K\],就是问K对应的串对应的rank中的位置<br>
设a为最左的位置,b为最右的位置<br>
且rmq\[a,rank\[K\]\]&gt;=length\[K\],rmq\[rank\[K\],b\]&gt;=length\[K\]
那么询问就相当于,区间\[a,b\]上有多少num\[i\]在\[l,r\]中<br>
再对rank开颗主席树,就行了 离线也可以
