共11题，完成3题<br \>

1001 Abandoned country\[lyj\]
=============================

求出最小生成树后再dfs一遍算出所有路径的总长度再除以n\*(n-1)/2

1002 Chess\[hx\]
================

考虑到只有$2^20$种状态，那么暴力枚举每种状态算出SG值即可。

1003 Game(补)
=============

注意到每行每列并且每个2\*2的格子里都最多只有一个守卫，那么每两个点之间，最多只会被一个守卫影响到它的最短路长度，这个影响为长度+2.<br \>
首先假设没有影响，算出所有点对之间的最短路，这个可以横纵坐标分开算。然后计算所有的影响，枚举每一行，如果这一行有守卫，那么守卫左右两侧的点之间肯定是会被守卫影响的，然后考虑守卫左侧的点到前面i-1行的哪些点会被影响，以及守卫右侧的点到前面i-1行的哪些点会被影响，这个画下图就能知道。然后枚举每一列，方法同上。很显然每对点之间如果有影响，只会被两次枚举中的一次计算到。

1004 GCD\[hx\]
==============

对于每个左端点，枚举所有右端点，其不同的GCD值只有$\log$个，可以找出每次GCD值发生变化的右端点，设它们为“有用的”。<br \>
从右到左枚举每个左端点，假如l+1有用的右端点已经找出，则l有用的右端点只有可能是“l”和“l+1有用的右端点”，然后去掉其中不是有用的即可，然后可以用map预处理每个GCD对应的区间个数。
对于每个询问，就能$O(\log)$计算出GCD值，然后map直接得到答案。

1005 Necklace(补)
=================

枚举阴的圆排列，两个阴的之间的空隙作为二分图左部，阳的作为右部，如果一个阳的放在一个空隙里不会变阴，连一条边，做二分图匹配即可。

1006 PowMod(补)
===============

先看第一问，由于欧拉函数是不完全积性函数，找到n中一个质因子p，可以将式子转化成：
$$
f(n,m)=\sum_{i=1}^{m}\varphi(i*n)=\varphi(p)\times (\sum_{i=1}^{m}\varphi(i*\frac{n}{p})-\sum_{p|i}^{m}\varphi(i*\frac{n}{p}))+p\times \sum_{p|i}^{m}\varphi(i*\frac{n}{p})=(p-1)\times\sum_{i=1}^{m}\varphi(i*\frac{n}{p})+\sum_{i=1}^{\frac{m}{p}}\varphi(i*n)=f(\frac{n}{p},m)+f(n,\frac{m}{p})
$$
这样递归下去就能得到k的值。而计算$k^k^k^k^{\dots}$需要用到这个结论：$a^b\equiv a^{b\;mod\;\varphi(p)+\varphi(p)}(mod p)$，递归的计算一下就行，显然递归层数只有$O(\log)$

1007 Rigid Frameworks(补)
=========================

根据物理学原理（是吗？），只需要计算出左边n个点右边m个点的连通二分图个数即可。
$$
f[n][m]=g[n][m]-\sum_{i=1}^{n}\sum_{j=0}^{m} f[i][j]\times g[n-i][m-j]\times C_{n-1}^{i-1}\times C_m^j,g[n][m]=3^{nm}
$$ f\[n\]\[m\]即答案。

1008 Shell Necklace(补)
=======================

考虑$f[i]$为前i个的答案，则有DP方程$f[i]=\sum_{j=1}^{i}a[j]\times f[i-j]$，然后由于模数很小，分治FFT，在FFT的时候取整就行了。

1009 Solid Dominoes Tilings(补)
===============================

这题是轮廓线dp+容斥,设g\[i\]\[j\]表示i\*j的网格由1\*2或2\*1的骨牌铺满的方案数,用最经典轮廓线dp解决即可<br>
然后考虑如何计算solid的方案数:利用容斥<br> 对于一个m\*n的网格<br>
solid方案数=<br> 没有一条列切割线和行切割线方案数<br>
-所有列切割线为i没有行切割线的方案数<br>
+所有列切割线为i,j(i!=j)没有行切割线的方案数<br>
-所有列切割线为i,j,k(i,j,k互不相等)没有行切割线的方案数<br> ...<br>
也就是枚举列切割线的状态(哪些选,哪些不选)<br>
然后若选了偶数条,最后的贡献就加到答案里<br> 否则从答案里减去<br>
对于每种给定的列切割线状态,要计算没有行切割线的方案数<br>
设dp\[i\]表示给定列切割线状态下，行数为i且没有行切割线的方案数<br>
h\[i\]表示给定列切割线状态下，行数为i的任意方案数<br>
h\[i\]=连乘{g\[i\]\[t\]}(t是每相邻两条列切割线之间的距离(算上两条边界))<br>
dp\[i\]= h\[i\]-sigma{dp\[j\]\*h\[i-j\]}(j&lt;i)<br>
最后用dp\[m\]更新答案即可

1010 Subway(补)
===============

找到每棵树的重心，最多两个，然后枚举作为根，对每棵子树hash，分别匹配。

1011 tetrahedron(补)
====================

利用球心与每个面上的一点的向量在各自法向量上投影相等列方程高斯消元
