11.4
====

-   和 qqq 对刚了TC SRM680，报了一箭之仇

11.3
====

-   补了几道TC
-   和 qqq 对刚了TC SRM681，只做了Easy和Medium，被怼了Easy和Hard的 qqq
    暴踩。

11.2
====

-   补了TC SRM697的Easy
-   做了TC SRM682，Easy瞎写挂了，只过了一个450的水Medium

11.1
====

-   补了几个TC题
-   补了16沈阳的H和I，J题写完了还没调完
-   开了TC SRM684，做了 Easy 电脑就没电了

10.31
=====

-   开了TC SRM696，发现一个题都不会
-   cf \#378 div2 fst\*2

10.30
=====

-   训了去年的北京区域赛，从此我得出结论：签到题和最后一题一定不能让鬼君敲。
    -   一开始鬼君写G，我发现A水，然后看J，一直没看懂。
    -   然后鬼君wa四发G，我让他滚蛋，准备写完J自己写。
    -   根据读错的题意wa了J，然后继续懵逼题意，最后lisa在网上查了题意才过。
    -   过了GA之后，C题卡了蛮久才想到
    -   然后lisa读错I，以为偶数长度不需要转，我就着错误的题意想了个挺麻烦的构造，浪费了一个小时。还好在此期间他们想出了D，然后迅速过掉了。
    -   发现K题水，赶紧敲，在hiho上交过。
    -   lisa又想了个构造，还比较好写，赶紧敲了，最后十分钟AC。
-   写了沈阳的四个水题

10.29
=====

-   [TC srm698](http://chitanda.moe/2016/06/08/Topcoder/) Easy
-   这次300就不会做了QAQ

10.28
=====

啥事没干

10.27
=====

-   [TC srm698](http://chitanda.moe/2016/06/08/Topcoder/) Easy, Medium
-   <del>
    为什么有了一种TC500不难的错觉
    </del>

10.26
=====

-   和鬼君训了下场[gym](/2016-2017 ACM-ICPC, NEERC, Moscow Subregional Contest)，宿舍里好暖好静
    -   刚开始没多久宿舍断网了，只好先写题屯着
    -   前面四个题比较简单，后面的题都比较难or难写
    -   过了E之后，我开始划水，让鬼君自己搞F，他又被一个坑坑了好久才过
    -   最后半小时和他讲了H的做法，结果他居然连敲都没敲完

10.25
=====

-   发现 CF Canada Cup 的 C 和 D 犯了两个 sb 错误
-   做了下14鞍山的B，真是各种坑

10.24
=====

-   和鬼君两个人训了场[gym](/2016-2017 CF S03E06 CF Trainings Season 3 Episode 6)，自习室好冷好吵
    -   前期比较平稳，没有卡题
    -   鬼君无药可救，写了差不多两个小时因为各种原因wa了几发D，赛后两分钟才交过
    -   J题有了个想法，可惜没有时间去实践了（都怪鬼君
-   [TC srm699](http://chitanda.moe/2016/06/08/Topcoder/) Easy, Medium

10.23
=====

-   [TC srm700](http://chitanda.moe/2016/06/08/Topcoder/) Easy, Medium

10.22
=====

-   cf Canada Cup，血崩，回紫，待补

10.19-21
========

划水

10.18
=====

沉迷学习，无法自拔

10.17
=====

-   坐火车回北京
-   发现大连罚时算错了，实际应该rank3
-   补了一觉，爽多了
-   BB了下cf div2的DEF，感觉很稳

10.16
=====

-   发现有emacs了，感谢裁判
-   发挥不错，AK了
-   反思：最后三十分钟在想不出C的情况下弃疗了，非常不应该，要向lisa学习，直到最后十分钟都不放弃，然后想出来十分钟码完，最后几秒提交成功。

10.15
=====

-   icpc大连练习赛
-   发现没有emacs，非常急躁
-   去和裁判抱怨了一下，求了下情

10.14
=====

-   补了[鞍山](\2014anshan)的CDEIK
-   坐火车去大连

10.13
=====

-   [hdu5070](http://acm.hdu.edu.cn/showproblem.php?pid=5070)（2014鞍山A）
    -   通过在[async提问](https://async.icpc-camp.org/d/591-anshan-2014-a-twelve-months)得到了问题的简化模型
    -   通过偷窥昂神的AC代码get了具体解法，感觉get到了状压DP的新姿势（还一不小心用昂神的账号交了一发，希望他不会发现
    -   具体的，设 $res[S]$ 为翻完了集合S中的堆的答案。刚开始只考虑在
        $S$ 集合中的，令 $cnt[i]$ 为各堆剩下的牌数，$cal$ 等于 $S$
        中的堆以及堆 $1$ 剩下的牌数，如果 $cal=0$，那么 $res[S]=1$
        ，否则 $res[S]=\frac{cnt[1]}{cal}$（即将这 $cal$
        张牌任意排列，最后一张为 $1$ 的概率）。然后从 $2$ 到 $n$
        枚举每堆 $i$，再从小到大枚举 $S$，如果 $S$ 中不包含 $i$ ，那么
        $res[S]$ 要减去 $res[S\cup \{i\}]$，即减去在集合 $S$
        中的都被翻完了的情况下第 $i$
        堆也翻完了的概率。（妙处就在于先枚举 $i$）
    -   以上做法实际是做了个高维前缀和。如果不是这样，我们也可以通过容斥以
        $3^{n-1}$ 的复杂度求出答案。

10.12
=====

啥也没干

10.11
=====

-   做了下之前昂神说的一个最小费用可行流的[题](http://vjudge.net/contest/48040#problem/V)，被-0.00坑了好久。最小费用可行流的做法是：先强行让负费用的边满流。设原边是u-&gt;v，容量为f，费用为-cost，那么费用流连的边为(v,u,f,cost)，并且从源点S向v连(S,v,f,0)，从u向汇点连(u,T,f,0)，然后跑最小费用最大流。

10.10
=====

好像啥也没干

10.9
====

-   补了东北四省赛的09，get了线段树二分的新姿势
-   补了昨天cf的e，学到了最小割的新姿势

10.8
====

-   cf拿小号打了打，在q的帮助下过掉了G题

10.7
====

忘记这天干了啥

10.6
====

-   训了东北四省赛的重现，难得没被qqq踩
-   补了下训练的07，才发现这种DP我以前写过。本来想补09，写到一半弃疗了。
-   沉迷fgo，不可自拔

10.5
====

-   补了昨天的d，发现其实并不算难，DP水平亟待提升
-   补了ccpc长春的egik，为题目的简单再一次感到心痛。

10.4
====

-   补了cf gym的2016-2017 CT S03E02的C，心力憔悴
-   训练叉老师的四川省赛，又被q巨踩，晚上补了b

10.3
====

-   cf \#375 div2
    -   E 题意：n个点m条边，给每条边定向，使得入度等于出度的点最多。
        题解：每次找一个度数为奇数的点走，直到走到另一个度数为奇数的点，最后再走一遍欧拉回路
    -   F
        题意：n个点m条边，给定点s和t，找一个生成树使得s的度数不超过ds，t度数不超过dt。
        题解：先把除s和t外的所有点做一遍生成树，然后对于每个块，要么只和s相连，那么s必定连向它，要么只和t相连，那么t必定连向它，要么和两个都相连，二选一即可。最后如果存在和s，t都相连的块，找一个让它和s，t都连边，否则再看是否有s直接和t相连的边。

10.2
====

-   沉迷祭祖，不可自拔

10.1
====

-   BestCoder Round \#88
    -   C
        题解：f\[i\]\[j\]表示以i为根必定包含i的异或值为j的个数，转移用FWT优化。
-   CF Intel Code Challenge Elimination Round
    -   D
        题意：n个互不相同的正数，每次可以将一个数除2，最终使得所有数都不同，最小化最大值。题解：可以二分答案，也可以贪心乱搞，每次找一个最大的还能变小的不断除2直到可行。

9.30
====

-   补掉2016 ACM/ICPC Asia Regional Beijing Online的B题
-   补掉2016 ACM/ICPC Asia Regional Beijing Online的D题
-   cf \#374 div2
    -   D
        题意：给定n个数，每次操作可以给其中一个加或减x，用k次操作使得最后所有数的积最小。
        题解：如果初始有偶数个负数，那么先让绝对值最小的正负号转换，然后每次取绝对值最小的加（减）x使得它绝对值变大，用个堆维护即可。

