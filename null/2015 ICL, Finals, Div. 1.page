A. Survival Route
=================

B. Dispersed parentheses\[hx\]
==============================

用不超过k的个数减去不超过k-1的个数即恰为k的个数，DP即可，复杂度$O(nk)$

C. Chocolate triangles
======================

D. LWDB(补)
===========

点分治，每次修改，向上找每个子树的重心更新，对每个重心维护一个关于距离的单调队列；每次查询，也向上找每个子树的重心，二分出更新查询点的那次修改，答案为最后的那次更新。这么久没写居然一次写过了，开心。

E. Pea-City\[lyj\]
==================

旋转卡壳

F. Beautiful sums(补)
=====================

一个结论：找到最小的恰有n个因数的奇数即可。然后随便搜一下就行。

G. Nano alarm-clocks\[lyj\]
===========================

枚举每个钟,计算其它钟到达这个状态的时间

H. Lunch\[hx\]
==============

如果s和f相邻，那么如果s和f有至少一个是端点，答案为1，否则为-1.<br \>
如果不相邻，设s&lt;f，那么如果s不是端点，需要先从s往左边搞完，然后跳到s+1，f的逆过程同理。
然后就相当于要从x跳到y，其中x为s或者s+1，取决于s是不是端点，y同理。
那么可以采用先往后跳两格，往回跳一格，再往后跳两格的策略，使得跳一格的次数最少。

I. Accounting Numeral System\[hx\]
==================================

每次贪心的选尽可能大的x值，这个可以二分得到。

J. Ceizenpok’s formula(补)
==========================

爆longlong了都没看出来,lucas扩展版,可以计算在mod p\^t下的组合数
算出来后用crt合并

K. Dividing an orange
=====================

L. The Pool for Lucky Ones\[hx\]
================================

用cnt\[x\]记录人数为x的泳道个数，考虑一次移动只会使最大值不变或者+-1，模拟每种移动即可。
