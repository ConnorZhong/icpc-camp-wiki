A - Three Serversp\[hx\]
========================

设f\[i\]\[j\]\[k\]为前i个分配完，第一个分配了j时间，第二个分配了k时间是否可行，显然j和k都不超过4000，然后用bitset优化。由于空间问题，必须用滚动数组，为了输出方案，可以DP四次，每次输出最后一百个的分配方案。

B - Game on Bipartite Graph(补)
===============================

首先先手必胜的条件是，选择一个右边的点集，它们连向左边点v的边数之和为奇数，其他为偶数。因为这样无论右边怎么走，我们都能有下一步走法。按照这个来求方案即可。

C - Black and White Board
=========================

D - Catenary
============

E - Evacuation Plan
===================

F - Empty Vessels(补)
=====================

无解就是A&gt;最大的a或者A不是所有a的gcd的倍数,若A是最大的a,那么直接把最大的a填满,否则从0开始bfs,每次用最大的a来存,看能到达哪些数字,记录一下转移,然后输出方案

G - Maximum Product\[hx\]
=========================

从高位往低位，每次要么选择上界的数字，要么选上界减1的数字（如果可以）并且之后所有位都为9.

H - Biathlon 2.0\[lyj\]
=======================

凸包二分

I - Archaeological Research\[hx\]
=================================

从第1位往后做，每次选择最小的能选的数字，设x第一次出现在输入的第i行，那么x位的数字肯定和i+1到x-1位的数字不同。设每个数字y最后出现的位置为p\[y\]，用线段树维护区间min。要填第x位的数字，就要查询最小的p值小于等于i的数字y，在线段树上二分即可。

J - Sockets\[hx\]
=================

二分答案后贪心，插排肯定是从大到小放，用电器肯定是从小到大放。

K - Toll Roads(补)
==================

枚举链的一端作为根，然后DFS枚举另一个端点，简单的树形DP。
