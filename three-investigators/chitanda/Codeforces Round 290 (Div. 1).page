## Codeforces Round #290 (Div. 1)

### C. Fox And Dinner

> $n(3\le n\le 200)$ 个点，每个点有个权值 $ai(2\le a_i \le 10^4)$，若两个点的权值和为质数，则他们之间有边，问能否用不相交的环覆盖所有的点。

由于大于 $2$ 的质数都是奇数，所以两个点连边必然是一奇一偶，因此原图是个二分图，每个点在一个环上，只需每个点匹配两个点即可，用网络流解决。

### D. Fox And Travelling

> $n(1\le n\le 100)$ 个点的无向图，每次可以删除一个度数不大于 $1$ 的点，并删去与它相连的边，不同的删除顺序和点算作不同的删除方案，问删 $0$ 到 $n$ 个点各自的方案数。

实际上，能被删的点肯定不在环上，能被删的点构成一个森林，若能对没棵树算出删不同点的方案数，就能算出答案。

一棵树最多可能有一个点与一个环相连，那么这个点必须最后删除，以它作为根进行树 DP 就可以了。

若没有点与环相连，枚举一个不能删的点，进行树 DP，将对应删除点数的 DP 值累加。那么考虑，若这棵树有 $m$ 个点，被删了 $k(k\le m)$ 个点，没被删的有 $m-k$ 个点，所以每个删除方案被计算了 $m-k$ 次。而对于删完所有点的方案，枚举最后一个删的点即可。

### E. Fox And Polygon 

> 给出两个正多边形的三角剖分，每次可以从第一个三角剖分中删去一条边，并添加一条边使得它仍然是一个三角剖分，构造一个方案从第一个三角剖分变成第二个三角剖分。

可以发现，这种操作是可逆的，因此我们只需考虑将一个三角剖分变成一个最简的三角剖分，即 $n-3$ 条边都是从 $1$ 连出去的边的三角剖分。

按顺序枚举这个三角剖分从 $1$ 连出去的边（包括边界边），若两条相邻边连接的两个点不相邻，那么它们之间肯定有一条边（否则就不是三角剖分了），将这条边删去，必然会添加一条连接 $1$ 和一个别的点的边，不断做这个过程，直到找不到这样的相邻边。这样最多会进行 $n-3$ 次操作，先将初始三角剖分变成最简三角剖分，再将最简三角剖分变成目标三角剖分，最多有 $2n-6$ 次操作