# Contest Info

date: 2017.10.29 09:00-14:00

practice link: **onsite**

# Solutions

## A. XOR

solved by skywalkert, upsolved by none

---

skywalkert's solution

把 $\mathrm{or}$ 看成 $\mathrm{xor}$ 了许久才发现……

对于 $K$ 已经存在 $1$ 的位无法修改，主要尝试最小化其他位。

对于每个右端点 $R$ 预处理相应的基向量要在左端点 $L$ 小于等于某个定值的时候才能出现，这样可以做到从高到低扫一遍 $R - 1$ 的基向量得到。

然后枚举可用基向量贪心让高位是 $0$ 即可。

## B. Lovers

solved by chitanda, upsolved by none

## C. Naomi with Array

unsolved

## D. Islands

unsolved

## E. Naomi with Graph

solved by chitanda, upsolved by none

---

braveTester's solution

最小割。

设源点为 $S$，汇点为 $T$。

对于原图中每个点 $u$，设其在原图中与 $1$ 的距离为 $\text{dist}[u]$。在新图中，$u$ 被拆为 $u_0, u_1, \dots, u_{\text{dist}[u]}$。$u_i$ 向 $u_{i + 1}$ 连一条容量为 $(A[u] - (i + 1))^2$ 的边，$u_{\text{dist}[u]}$ 向 $T$ 连一条容量为无穷的边。如果 $u$ 不是 $1$，则 $S$ 向 $u_0$ 连一条无穷的边，否则连一条容量为 $(A[1] - 0)^2$ 的边。

对于原图中的每条无向边 $(u, v)$，在新图中连若干条形如 $(u_i, v_{i - 1})$ 和 $(v_i, u_{i - 1})$ 的容量为无穷的有向边。

新图上的一个割对应了一个满足三角不等式的图，流量为该种方案的代价，因此在新图上跑个最大流即可。

## F. God of Gamblers

solved by skywalkert, upsolved by none

---

skywalkert's solution

队友尝试打表失败，大家一致决定交个 $\dfrac{n}{n + m}$ 上去，谁曾想 AC 了呢？

## G. Sum of xor sum

solved by skywalkert, upsolved by none

---

skywalkert's solution

预处理前缀异或值，问题转化为区间里选两个点异或的所有可能之和。

按位处理，对于每个位计算出区间里有多少个 $0$ 和 $1$ 即可确定这一位对答案的贡献。

答案明明不大……为什么答案要对 $(10^9 + 7)$ 取模呢？

## H. Arrangement for Contests

solved by chitanda, upsolved by none

## I. Acedia

upsolved by skywalkert

---

braveTester's solution

源自 THU 的天才卡题少女队的解法。

固定一个 $k$，令 $\text{ans}_r[l]$ 为在这个 $k$ 下区间为 $[l, r]$ 时的答案，考虑如何从 $\text{ans}_r[\cdot]$ 转移到 $\text{ans}_{r + 1}[\cdot]$。

当固定 $r$，$l$ 从右向左扩展时，可以想见，每个 $x$ 必然是从无效变为有效，再变成无效。这个过程可能有缺失，但是顺序是固定的。设 $\text{valid}_r[x]$ 为 $x$ 在 $[\cdot, r]$ 中有效的左端点区间，也即，$x$ 在 $[l, r]$ 中有效，当且仅当 $l \in \text{valid}_r[x]$。

由于只多了一个元素 $x = a[r + 1]$，对于 $y \not \in [x - k, x + 1]$，其有效区间不受影响，即 $\text{valid}_{r + 1}[y] = \text{valid}_r[y]$。而为了确定 $y \in [x - k, x + 1]$ 的 $\text{valid}_{r + 1}$，需要知道 $[x - k - 1, x + k + 1]$ 的最贴近 $r + 1$ 的出现位置。知道了这些位置，按照从右至左的顺序模拟一遍，就可以知道需要改变的 $\text{valid}_{r + 1}$ 的具体值。

如果用线段树维护 $\text{ans}_{r}[\cdot]$，则得出了 $\text{valid}_{r + 1}[\cdot]$ 后，将有变化的部分的 $\text{valid}_r[\cdot]$ 对 $\text{ans}_r$ 的影响消除，再加上对应的 $\text{valid}_{r + 1}[\cdot]$ 的影响，则可以得到 $\text{ans}_{r + 1}$。

最右出现位置可以在扫描过程中 $O(1)$ 维护，模拟的时候一次复杂度大概是 $O(k \log k + k^2)$，因此对于一个 $k$，复杂度为 $O(n k^2 + nk \log n)$。

最后复杂度为 $O(n k^3 + nk^2 \log n)$。

---

skywalkert's solution

注意，上面的方法很难通过原数据（$1 \leq n, m \leq 10^6, 0 \leq a_i \leq 2 \cdot 10^9$）。

考虑离线枚举右端点 $R$，对每个左端点 $L$ 维护每组长度为 $k$ 的极大线段数量 $f_R(k, L)$。

定义 $S_R(L)$ 表示区间 $[L, R]$ 的极大线段集合，考虑 $S_{R - 1}(L)$ 与 $S_R(L)$ 有什么不同。当 $S_{R - 1}(L)$ 中不含有 $a_R$ 时，$S_R(L)$ 与其的差别来自右端点为 $a_R - 1$ 的极大线段 $\mathrm{leftSegment}$ 和左端点为 $a_R + 1$ 的极大线段 $\mathrm{rightSegment}$。

再考虑 $S_{R - 1}(L)$ 和 $S_{R - 1}(L - 1)$ 中的 $\mathrm{leftSegment}$ 和 $\mathrm{rightSegment}$ 有什么不同，随着 $L$ 不断向左移动，这两个极大线段只会不断地增长，因此可以根据这些变化对 $L$ 进行分组，使得同一组的 $L$ 对应 $S_R(L)$ 与 $S_{R - 1}(L)$ 之间相同的变化。这样的变化数量是不超过 $10 + 10$ 次的。

尝试利用树状数组维护 $f_R(k, L)$，对于上述分组中连续的 $L$ 产生的变化可以直接在树状数组上产生影响。具体来说，初始有 $L = R, \mathrm{leftSegment} = \mathrm{rightSegment} = \emptyset$，每次在 $a_R$ 出现在 $S_{R - 1}(L')$、$\mathrm{leftSegment}$ 变长、$\mathrm{rightSegment}$ 变长这三种情况里选一个最右的左端点 $L'$，则左端点位于 $(L', L]$ 的情况有着相同的变化，将变化产生后再更新 $\mathrm{leftSegment}$ 和 $\mathrm{rightSegment}$ 即可。

时间复杂度为 $\mathcal{O}((20 n + 10 m) \log n)$。

需要注意的是，“查找某个值在之前的最近一次出现位置”这样的操作次数是可能达到 $\mathcal{O}(20 n)$ 的，如果使用 `map` 或 `unordered_map` 维护则会出现超时（被卡常）等问题。实际上不难注意到每次查询的值是分别关于 $a_R$ 递增和递减的，若使用离散化数组替换 `map` 或 `unordered_map`，则在完成对 $a_R$ 的定位后，可以 $\mathcal{O}(1)$ 定位相邻的值。

## J. LOL

solved by skywalkert, upsolved by none

----

skywalkert's solution

带限制的对象实际上只有本方的 `PICK` 对象，考虑容斥计算它们至少有 $k$ 个相同的方案，dfs 可能的相等情况，利用 bitset 计算即可。

## K. LOVER II

solved by skywalkert, upsolved by none

---

skywalkert's solution

将 $a_i$ 排升序，记排升序后为 $a'_i$，若 $a'_i$ 可以和 $b_j$ 配对，则 $a'_k$ $(1 \leq k < i)$ 都可以和 $b_j$ 配对，那么对于一组 $b_j$，如果他们可以成功配对，则说明和 $a'_i$ 能配对的 $b_j$ 至少有 $(n - i + 1)$ 个。

枚举左端点 $L$，可行的右端点 $R$ 需要大于等于某个定值，并且随着 $L$ 递增，这个定值也会递增，因此可以利用两个指针对于每个左端点 $L$ 计算该位置。

判定能否配对则采用线段树维护能与 $a'_i$ 配对的个数减去 $(n - i + 1)$ 的最小值，如果最小值非负则说明配对成功，修改时则是区间加减一。

# Replay and Summary

## Replay

热身赛发现机子居然是 32 位的，用不了 int128！批判了一番之后做好正赛使用高精度的准备。

赛前 `H` 突然想清理下肚子的内存，一个人跑了两层三个厕所差不多等了四个人之后终于蹲上了，并在赛前十分钟左右赶了回来。

倒计时前几分钟可以动机子，于是赶紧把 cb/emacs/vim 的配置弄好，pc 方以及榜单也都开好。

开始后，`L` 从前面读，`T` 从后面读(?)，`H` 从中间挑短的读。

`H` 很快发现 B 是个签到题，并马上上去码了。

`T` 惊喜的发现 G 是一个他出过的题，于是激动过了头 WA 了两发，`H` 准备帮忙一起查错的时候， `T` 突然发现第二页第一行有个取模，于是一边“妈个鸡”一边加个取模过了。

`L` 给 `H` 讲了下 F 的题意，`L` 和 `T` 都猜了个答案但不敢试也没说，`H` 胡乱分析之后脑子一热上去码了个代码，发现过不了样例，下机思考人生。`T` 则在此之间搞出了 K 的做法，并马上换上来写。

`H` 盯着几十个队过 F 的榜并看了看样例，于是也觉得应该猜一个答案，`T` 将猜的答案提交上去马上返回了 Yes。

然后 `L` 给 `H` 喂了个 H，再之后 `T` 很快也写完了 K 但是返回 WA，打印下来后 `L` 和 `H` 一起帮他查错。`H` 看了一遍代码，发现 `T` 犯了一个自己以前经常犯的错误，改对了之后抢到了这题一血。

之后互相交流了一下题意，`H` 觉得 E 能搞并很快想了个假算法，然后 -2。`L` 则和 `T` 分析 J 和 A（此处待补）。

`H` 在和 `L` 再交流了一下之后终于发现自己 E 想错了，只好重新思考。

待补。

`H` 终于想出了 E 的做法，赶紧滚上去写，结果没过样例，和 `T` 轮流上机修修补补之后交上去 -1，打印下来之后发现没清空，改了后终于过了。

（过 J 和 A）待补。

此时只剩一小时，`T` 觉得 D 可以一做，并和 `H` 说了下，`H` 表示交给 `T` 了然后滚去想 C 和 I。`H` 想到了 I 的一个做法但觉得复杂度太大，加上 `T` 在搞 D，于是接着想如何优化复杂度。

最后半个多小时的时候 `H` 觉得没必要再想 I 和 C 了，于是帮 T 想了两个 D 的样例，`T` 在最后二十多分钟左右终于推完 D 开始写，但由于时间不够没能调试出来。

## chitanda

这场打的很差，自己得背一部分锅。

前期在想 F 的时候，没有想清楚就去写，浪费了机时，并且写 H 写得也不是很快。

中期想 E 的时候，在写之前也没有和队友充分交流，没能及时发现是假算法，浪费了大量思考时间和机时。发现是假算法之后，又花了大量时间才推出最小割模型，而这个模型自己写过几次了，没有很快想出来说明自己对做过的题的总结不到位。想出来后又花了很多时间写代码，码力还有待提升。

后期应该选择和 tls 一起推 D 或者赶紧否掉虚无缥缈没人过的 D 一起试 I，但自己又让 tls 推着 D 又自己想别的题，犹犹豫豫之间一个题也没过。
