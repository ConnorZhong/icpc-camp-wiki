# Contest Info

date: 2017.08.10 12:00-17:00

[practice link](http://acm.hdu.edu.cn/contests/contest_show.php?cid=764)

# Solutions

## A. String

solved by skywalkert, upsolved by none

---

skywalkert's solution

将所有串排序，则满足询问前缀的是一段区间串，满足询问后缀的信息可以建立可持久化字典树得到。

为了保证算出的答案不含询问前缀与询问后缀重叠的情况，枚举可能的重叠，查找整个字典中是否存在这样的字符串并删去即可。

时间复杂度 $\mathcal{O}(\sum{|S|} \log n)$ 。

## B. Mindis

solved by braveTester, upsolved by none

---

braveTester's solution

问题即问以给定两点为焦点的椭圆与圆恰好相切时的长轴长。

设焦距为 $c$，两点中点到圆心的距离为 $d$，圆半径为 $r$。

旋转坐标系使得两焦点坐标为 $(-c, 0)$ 和 $(c, 0)$，圆心坐标为 $(0, -d)$。设椭圆 $\displaystyle C: \frac{x^2}{a^2} + \frac{y^2}{b^2} = 1$，其中 $a^2 = b^2 + c^2$。圆 $O: x^2 + (y + d)^2 = r^2$。

设二者切点为 $(x_0, y_0)$，则椭圆 $C$ 在该处的切线 $\displaystyle l_C: \frac{x_0}{a^2} x + \frac{y_0}{b^2} = 1$，法向量为 $\displaystyle \left(\frac{x_0}{a^2}, \frac{y_0}{b^2}\right)$。圆 $O$ 在该处的切线 $l_O: x_0 x + (y_0 - d)(y - d) = r^2$，法向量为 $(x_0, y_0 - d)$。

由于椭圆 $C$ 和圆 $O$ 相切，因此 $l_C$ 和 $l_O$ 是同一条直线，故有 $\displaystyle \left(\frac{x_0}{a^2}, \frac{y_0}{b^2}\right) \times (x_0, y_0 - d) = \frac{x_0 (y_0 - d)}{a^2} - \frac{y_0 x_0}{b^2} = 0$。

当 $x_0 = 0$ 时，对应情况切点为 $(0, r - d)$，单独判断。下设 $x_0 \neq 0$。

所以 $\displaystyle \frac{y_0 - d}{a^2} - \frac{y_0}{a^2 - c^2} = 0$，解得 $\displaystyle a^2 = \frac{c^2 (y_0 + d)}{d}$。

因为 $(x_0, y_0)$ 为切点，故应有 $\displaystyle \frac{x_0^2}{a^2} + \frac{y_0^2}{b^2} = 1$ 和 $\displaystyle x_0^2 + (y_0 + d)^2 = r^2$。

由第二式解得 $x_0^2 = r^2 - (y_0 + d)^2 \ge 0$，将 $x_0^2$ 和 $a^2$ 带入第一式有
$$
\begin{align}
\frac{x_0^2}{a^2} + \frac{y_0^2}{b^2} &= 1\\
(a^2 - c^2)(r^2 - (y_0 + d)^2) + a^2 y_0^2 &= a^2 (a^2 - c^2)\\
\frac{c^2 y_0}{d} (r^2 - (y_0 + d)^2) + \frac{c^2 (y_0 + d)}{d} y_0^2 &= \frac{c^2 (y_0 + d)}{d} \times \frac{c^2 y_0}{d}\\
\frac{c^2 y_0}{d} \left(r^2 - (y_0 + d)^2 + y_0 (y_0 + d) - \frac{c^2 (y_0 + d)}{d}\right) &= 0\\
\frac{c^2 y_0}{d} \left(r^2 - (y_0 + d)\left(d + \frac{c^2}{d}\right)\right) &= 0\\
\frac{c^2 y_0}{d} \left(\frac{dr^2 - (y_0 + d)(d^2 + c^2)}{d}\right) &= 0。
\end{align}
$$

故 $y_0$ 的可能取值为 $0$ 和 $\displaystyle \frac{dr^2 - d(d^2 + c^2)}{d^2 + c^2}$。

当 $x_0 = 0$ 时，所求为 $2\sqrt{c^2 + (r - d)^2}$；当 $y_0 = 0$ 时，所求为 $2\sqrt{r^2 - d^2}$；当 $\displaystyle y_0 = \frac{dr^2 - d(d^2 + c^2)}{d^2 + c^2} \le r$ 时，所求为
$$
\begin{align}
2a &= 2\sqrt{\frac{c^2 (y_0 + d)}{d}}\\
&= 2 \sqrt{\frac{c^2 dr^2}{d (d^2 + c^2)}}\\
&= 2 \sqrt{\frac{c^2 r^2}{d^2 + c^2}}。
\end{align}
$$
如不满足条件，则该解舍去。

将上述三个式子分别求值然后取 $\min$ 即可，复杂度 $O(1)$。

---

braveTester's comment

将椭圆和圆联立，令 $\Delta = 0$，确实可以得出第三种情况的答案，但是如果该解不合法，联立的做法不能说明下一步应该怎么办。用切线的解法全程用的必要条件，说明了最小值一定在这三种情况中取到。

[这里](https://wiki-ascender.icpc-camp.org/2017multi_6#b.-mindis-wbr)是另一种用极坐标求解的方法。

题解的圆反演简直 666 啊！

$P$ 反演之后，其反演点 $P'$ 构成的三角形 $\Delta_{P'OD}$ 和 $\Delta_{POD}$ 相似，其中 $O$ 为圆心，$D$ 为圆上任意一点。所以最小化到两点距离和等价于最小化到两反演点距离和。由于原来两点在圆内，反演之后的两点在圆外，然后同样采用椭圆的思考，很容易发现最优解如果不是反演点之间的直线段，那么一定是二者的中垂线与圆的交点。

原来是两个凹凸性相同的函数在搞事，现在变成了两个凹凸性不同的函数在搞事，于是一下就能看出解了。果然还是要学习一个！

## C. Inversion

solved by chitanda, upsolved by none

---

考虑将 $a$ 从大到小排序，然后对于它原下标的因子，它都不能作为答案。对于每个 $i$，$b_i$ 的值为排序后的 $a$ 中第一个原下标不是 $i$ 的倍数的值。

## D. Similarity

upsolved by chitanda

---

chitanda's solution

在两棵树种分别枚举断哪两条边，然后对两棵树各三个连通块分别求哈希值，如果有一种匹配方法使得三对哈希值两两相同即可以。

用 meet in middle 的思想，可以分别枚举两棵树。算连通块的哈希值的时候可以直接 dfs，复杂度 $O(n)$ （如果用括号序列计算哈希值，需要 $O(n\log n)$ ，会超时）。

实际上有一种较复杂的方法可以在已经预处理的情况下 $O(1)$ 得到三个连通块的哈希值，预处理为用括号序列的方法计算树的哈希值。

## E. WrongStatement

upsolved by chitanda

---

chitanda's solution

可以发现，最终 `@` 到 `.` 的路径必定是唯一的，那么可以枚举这条路径，将这条路径都先放上多米诺骨牌，然后就是一个裸的带禁止位置的多米诺骨牌放置方案数了，用轮廓线 DP 即可解决。

这个方法是基于 $n$ 和 $m$ 都不大，路径数不会太多的，当 $n$ 比较大时，路径数会变得更多，复杂度将很高，而题解的插头 DP 方法在复杂度上的优越性将会显示出来。

## F. Gumballs&Dungeons

upsolved by chitanda

---

chitanda's solution

虽然大部分数值都设的很高，但可以发现，怪物的攻击和血量最高只有 20，因此当自己攻击大于等于 20 时，都是一击必杀，当自己防御大于等于 20 时，都是无敌，因此攻击和防御上限可以设为 20.

可以 $2^7$ 枚举出当哪些怪被干掉时，当前可以吃到的所有 buff。然后考虑到所有的魔法效果都是永久的，那么我们在能够放魔法的时候就放，一定不会更差。

设 $f[mask][i][j]$ 为当前已经干掉的怪的集合为 $mask$ ，攻击力为 $i$ ，防御为 $j$ 时的最大血量。

转移时，枚举下一个能干的怪，算出需要扣的血量，以及干掉它之后能获得的 buff，然后用得到的 mp 放技能，枚举加攻击技能和加防御技能的个数（均不超过 20），剩下的用来加血。

## G. GCDispower

solved by skywalkert, upsolved by none

---

skywalkert's solution

考虑离线右端点（或可持久化）处理询问，从而将询问中的贡献关于右端点差分，新产生的贡献是右端点恰好为 $k$ 的情况。

考虑相应左端点得到的贡献，发现也可以关于左端点差分，使得新产生的贡献是左端点恰好为 $i$ 的情况，然后使用一个数据结构（例如树状数组）将对应左端点前缀区间的贡献产生。注意到这些左端点满足 $p_k | p_i$，所以对于所有的 $p_k$，需要考虑的位置一共有 $\sum_{p_k = 1}^{n}{\sum_{i < k, p_k | p_i}{1}} \sim \mathcal{O}(n \log n)$ 个，产生贡献的复杂度为 $\mathcal{O}(n \log^2 n)$ 。

对于固定的 $i$ 与 $k$，对其产生贡献的 $j$ 满足 $\displaystyle \gcd\left(\frac{p_i}{p_k}, \frac{p_j}{p_k}\right) = 1$ ，在左移 $i$ 的过程中可以依次将 $j$ 的贡献产生，也即将产生的贡献关于左移的左端点差分。具体来说， $\displaystyle p_k \sum_{i < j < k}{\left[\gcd\left(\frac{p_i}{p_k}, \frac{p_j}{p_k}\right) = 1\right]} = p_k \sum_{d | \frac{p_i}{p_k}} \sum_{i < j < k, d | \frac{p_j}{p_k}}{\mu(d)}$ ，那么只需要对于每个可能的 $\displaystyle d\ \left(d \leq \frac{n}{p_k}\right)$ 维护一个计数器，在 $i$ 处统计相应的 $j$ 对计数器产生的加权贡献，再将 $i$ 处作为 $j$ 能对更靠左的左端点产生的贡献累计到计数器中即可。

上述过程中实际枚举了 $p_k$、 $p_k$ 的倍数 $p_i$ 和 $\frac{p_i}{p_k}$ 的无平方因子约数 $d$，不妨令 $p_k = x, d = y, \frac{p_i}{d\ p_k} = z$ ，并且忽略 $y$ 是无平方因子数的条件，可以估算上述枚举的数量约为 $\sum_{x y z \leq n}{1} = \mathcal{O}(\sum_{x \leq n} {\frac{n}{x} \log \frac{n}{x}}) = \mathcal{O}(n \log^2 n)$ 。事实上，可以使该做法达到极限枚举量的 $p = [n, n - 1, \cdots, 1]$ ，但枚举量也没那么大就是了。

在具体实现中不需要预处理 $\mu(d)$ ，而是直接采用容斥的定义对有效的 $d$ 直接进行 dfs 即可。

## H. Kirinriki

solved by chitanda, upsolved by none

---

chitanda's solution

考虑原第一个子串的左端点为 $i$，第二个串的右端点为 $j$ ，然后考虑 $(i,j)$ 和 $(i-1,j+1)$，发现可以划窗来做。

## I. Influence

upsolved by chitanda

---

chitanda's solution

先预处理建立树分治的结构。对树分治每一层根据 dfs 序建立线段树，维护这一层每个点到根的距离，根对点的权值的直接贡献（即直接加到点权里），这个根对点的乘上根到距离的贡献（将这个值乘上根到点的距离加到点权里）。

对于询问，枚举每一层，查询三个值，直接计算。

对于第一种修改，枚举每一层，修改这条边所连的那个子树的点到根的距离，此时维护的第三个值乘上根到距离的值有了变化，需要修改维护的第二个值以消除变化。

对于第二种修改，枚举每一层，将这个点到根的距离乘 $y$ 的值作为直接贡献加到相应点，然后将维护的第三个值加上 $y$，被贡献的点为根以及那些和 $x$ 最靠近根的祖先不同的点，在线段树上为两段区间。

所有的区间修改只需要打静态标记，较为方便。实际上，可以用树状数组替代线段树，效率更高。

## J. Gameia

solved by chitanda, upsolved by none

---

chitanda's solution

首先可以发现，一个点所连的点中最多只能有一个叶子节点，否则 Alice 第一次染这个点，Bob 必败。

从这里出发，可以想到对于一条链，如果是奇数点，那么 Bob 必败，否则 Bob 可以将这条链切成若干个两个点的连通块来保证胜利。

那么对于不是一条链的情况，也是如此，若 Bob 能对这棵树做出完美匹配则必胜，否则必败。

## K. Classes

solved by braveTester, upsolved by none

---

braveTester's solution

画个韦恩图，然后推下必要条件即可。可能漏的条件是（比如我）类似 $|A| \ge |A \cap B| + |A \cap C| - |A \cap B \cap C|$ 的三个条件。

复杂度 $O(1)$。 

## L. Typesetting

upsolved by chitanda

---

$\text{pre}[i]$ 表示前 $i$ 个单词放在没有图片的行，至少需要多少行。$\text{nex}[i]$ 表示后 $i$ 个单词。这两个数组可以 $O(n)$ 得到。

$g[i][j]$ 表示从第 $i$ 个单词开始的 $2^j$ 个单词，一个接一个拼起来的长度（中间有空格）。

$f[i][j]$ 表示从第 $i$ 个单词开始放，放 $j$ 行有图片的行，可以放多少个单词。那么 $f[i][0]$ 可以通过 $g$ 来得到。

对于一个询问，先二分出图片之前的行能放多少个单词，然后利用 $f$ 计算出图片的行可以放多少个单词，再用 $\text{nex}$ 得到还需要多少行即可。

# Replay and Summary

## Replay

T 日常开始不在。H 和 L 翻了翻题，感觉没有很简单的签到题。

之后 H 看到 C 有队伍过了，想了下发现挺简单，就上来切了。

然后 L 和 H 讨论了下 K，感觉挺简单，L 就上来写了，然后 WA 了。期间 H 发现 H 也挺简单的，换上来写。

L 发现了错误，上来改了一下过了 K，之后 H 写完 H 一发 MLE，改了改之后也过了。

然后 T 终于来了。L 和 H 讨论了下 B，L 上去莽二分 TLE 了，然后发现就算不二分也要跑 1.6s，陷入僵局。期间 T 在推 G。

T 推出 G，上去一顿狂码。这期间 L 在想如何优化 B，H 在想 J。T 一发 AC 了 G，强无敌！

然后 H 试了下自己的 J 想法，WA 了，再次陷入僵局。T 开始思考别的题。

H 感觉 J 有点不大会，然后和 T 说了下题意，被 T 一语点醒，马上切掉了。

之后 T 告诉 H I 的树分治做法，但感觉做起来很麻烦，就先扔到一边了。

T 帮 L 优化下 B 的常数，再交还是 TLE，只能放弃二分做法，转向推公式。

H 突然对 A 有了点想法，和 T 讨论了一下让 T 上去敲。

H 看了下 L，发现就是一个简单的倍增，然后 L 也想出了 B 的做法。

之后趁 T 没过 A，L 上去写了下 B。趁 L 没过样例，H 写了下 L。

之后三人开始轮流修改，并在最后十分钟左右纷纷提交。

结果，L 先过了 B，然后 T 过了 A，立下肯定能过 flag 的 H 没能通过 L。

## braveTester

这场节奏其实特别不好...身为读题机的我居然全场只看了 $3$ 个题，并且全场和队伍脱节...

被 B 吸了魂，除了开始切了个签到，还 WA 了一发外，全场都在推 B。还好最后功成身退，否则不堪设想。

比赛中有一些细节不知道...比如 `%Lf` 的问题...还是写的太少了...

## chitanda

J 没有早点和队员一起思考，只顾闷头苦想浪费了很多时间。

L 因为一个 `<` 写成 `<=`，导致题数 `-1`，当时在 queue 的时候信誓旦旦能过，就没有继续肉眼查错，否则还可能在赛中看出错误。

## skywalkert

最近处于白天睡不醒晚上睡不着的状态，需要及时调整 ~~珍爱生命远离修仙~~

因此导致的智力下降问题给本队带来了极大的困扰，例如卡 sb 题，再次注意需要及时调整