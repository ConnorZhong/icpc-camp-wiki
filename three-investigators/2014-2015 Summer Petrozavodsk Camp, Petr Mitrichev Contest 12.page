# Contest Info

date: 2017.06.03 13:00-18:00

[practice link](http://codeforces.com/gym/101385)

[problems](http://codeforces.com/gym/101385/attachments/download/5553/20142015-summer-petrozavodsk-camp-petr-mitrichev-contest-12-en.pdf)

# Solutions

## A. Number of Close Strings

upsolved by chitanda, skywalkert

---

chitanda's solution

一开始写了裸随机，发现答案小随便跪，然后加了个如果有不同的位不超过 $20$ 位时，$2^{20}$ 枚举，当 $m \le 4$ 或 $5$ 时，暴力枚举。其他情况对那些有不同的位随机 $16000000$ 次，但对于答案较大但又不很大的情况无法处理，遂弃。

然后看了别人的代码，是这样求解的：

对于这 $k$ 个串的每个串，会使 $\sum_{i=0}^{m-1}\binom{n}{i}$ 个串不合法，我们要求的是这 $k$ 个不合法集合的并集。

考虑一个不合法串，在 $k$ 个集合中总计出现了 $f$ 次，那么这 $f$ 次总共只对答案贡献 $1$ ，相当于每个贡献 $1/f$ 。

我们随机一个串，再随机从 $\sum_{i=0}^{m-1}\binom{n}{i}$ 个不合法串中等概率选取一个，然后求它的 $f$ 值，随机几百万次求 $1/f$ 的平均值，再将其乘 $k\times \sum_{i=0}^{m-1}\binom{n}{i}$ 就是答案的近似解。

## B. Random Domino Placements

upsolved by skywalkert

---

skywalkert's solution

为了得到稳定分布，需要将所有可能的局面之间通过某些概率相等且**可逆**的转移连通，这样可以使得任意步转移后到达每个局面的概率等于每个局面出现的概率。

可以使用 Markov chain Monte Carlo 方法中的 Random walk Monte Carlo 方法尝试对该随机分布进行稳定采样，为了保证得到的采样在误差允许的范围内，最好在采样前先随机游走一定次数。

一种可行的构建方法是等概率地观察某两个相邻的格子，考虑与其相关的骨牌。

若当前位置恰好被一个骨牌覆盖，则可以将其移除，相应地，为了保证操作的可逆性，则需要对于当前位置无任何骨牌的情况，加入一个骨牌。

此时虽然所有状态已经连通，但有些状态仍然不好采样，可以采取两个方法，一是增加采样之间的随机次数，二是增加新的转移，将一个局面直接转移到其他局面的概率变得更加均匀。

经测试，上述两种方法任选其一都是可行的，下面给出 Petr 加入的第二种转移。

若当前位置被只有一部分被骨牌覆盖，则这个骨牌恰好有一个，将这个骨牌移除并在当前位置加入一个骨牌，相应地，对于新的状态，一步转移回原状态的概率依然是 $\frac{1}{2 n (n - 1)}$，所以满足条件。

否则当前位置被两个互不重叠的骨牌所覆盖，不好直接设计转移，可不做操作，直接转移到自身状态，不影响概率分布。

## C. Two Equal Squares

solved by braveTester, upsolved by none

---

braveTester's solution

枚举两个正方形两两连线能否作为切线。判切线只要判断是否一个正方形带入直线方程均 $\ge 0$ 或 $\le 0$ 即可。

注意唯一输出 `Infinity` 的情况是两个正方形有且仅有一个顶点重合即可。

复杂度 $O(1)$。

## D. Interleave Binary Strings

upsolved by skywalkert

---

skywalkert's solution

DP 套 DP 。考虑一个答案串可以有多少种不同的组成，发现只有至多 $\mathcal{O}(\min(n, m))$ 种组成，不妨将答案串映射到对应的组成上进行计数。

令 $f(i, S)$ 表示长度为 $i$ 且所有可能的组成由 $S$ 表示的串有多少种，其中 $S$ 第 $j + 1$ 位为 $1$ 表示这类串可以用 $a$ 的前 $j$ 位和 $b$ 的前 $i - j$ 位组成。

转移时只需要枚举下一个字符及其来源，如果来自 $a$ 则 $S$ 可能整体提高一位，否则来自 $b$ ，$S$ 也需要满足一些长度关系。

输入保证串是随机的，所以这里就不分析复杂度了，反正也不会分析。

## E. Alternate Jumping

solved by chitanda, upsolved by none

---

chitanda's solution

设 $f[i]$ 为最后一步是 Rita 走，走到 $i$ 时的方案数，$g[i]$ 则表示 Pasha。

那么，$g[i]$ 能对 $[L1_i,R1_i]$ 的 $f$ 产生贡献，$g[i]$ 的值则通过 $[L2_i,R2_i]$ 的 $f$ 值计算得到。

用两个树状数组维护即可，找最小因子需要先预处理质数。

## F. Recognize Power of Two

upsolved by skywalkert

---

skywalkert's solution

假设所求为 $2^k$，除了给定前缀 $P$ 外还剩 $m$ 个十进制位，则有 $P \cdot 10^m \leq 2^k < (P+1) \cdot 10^m$，关于 $10$ 取对数得 $m+ \lg(P) \leq k \cdot \lg(2) < m + \lg(P + 1)$。

注意到 $+m$ 可以看作是模 $1$ 意义下的实数剩余系，为了转化为有理数运算，可以取适当精度进行有理数逼近，例如猜测最优解一定位于 $m \cdot 10^{100} +\text{floor}(\lg(P) \cdot 10^{100}) \leq k \cdot \text{floor}(\lg(2) \cdot 10^{100}) < m \cdot 10^{100} + \text{floor}(\lg(P + 1) \cdot 10^{100})$ 之中，这样可以转化为模 $10^{100}$ 意义下的整数剩余系问题。这个猜测需要基于 $k$ 充分大的前提，因此需要对 $k$ 很小的情况进行特殊判断。

根据 $\lg(P)$ 和 $\lg(P + 1)$ 的整数部分是否相同，可能会得到一到两个区间需要计算最小的 $k$ 满足 $L \leq (k x \bmod 10^{100}) \leq R$，该问题可以类似扩展欧几里得的构造方法构造出绝对值最小的解 $k$。

做法同 [POJ 3530](http://poj.org/problem?id=3530)，其问题为给定 $M,D,L,R$，求最小的非负整数 $x$ 满足 $L \leq (D x \bmod M) \leq R$。注意到存在整数 $y$ 满足 $-R \leq M y - D x \leq -L$，则问题可以化为求解最小的非负整数 $y$ 使得 $(-R \bmod D) \leq (M y \bmod D) \leq (-L \bmod D)$。这是类似的问题，除去无解的情况，若 $[L, R]$ 中存在 $D$ 的倍数，则可以直接得到最小解（即上述 $y = 0$ 的情况），否则递归求解。沿用欧几里得算法的证明可知每次得到的解都会是最小解，时间复杂度可以是 $\mathcal{O}(\log^2 M)$，也可以预处理 $\gcd$ 后做到 $\mathcal{O}(\log M)$。

关于计算 $\lg(P) \cdot 10^{100}$，利用泰勒展开计算的方式无论如何都会涉及到 $\ln x$ 的计算，因此只考虑计算 $\ln x$。而根据 $\ln x$ 在 $x = 1$ 处的泰勒展开式有 $\ln (1 - x) = - \sum_{i \geq 1}{\frac{x^i}{i}}$，其中当 $|x| < 1$ 时上述展开式可以收敛，因此计算 $\ln x$ 时需要改换为计算 $\ln \frac{x}{e^y} + y$，其中 $0 < \frac{x}{e^y} < 2$。为此还需要预处理 $e \cdot 10^{100}$ 的取值，利用泰勒展开式有 $e = \sum_{i \geq 0}\frac{1}{i!}$，全体乘上 $10^{100}$ 转为高精度整数运算即可。

由于数据随机，实际上求 $\ln$ 的迭代轮数不是很大，不过依然可以改换 $10^{100}$ 使其变得更适合所使用的语言进行高精度整数运算。

## G. Power Sum Graphs

solved by chitanda, upsolved by none

---

chitanda's solution

可以将原图看成一个二分图，左边 $n$ 个点的权值为 $s_i$，右边 $n$ 个点的权值为 $t_i$，那么左边第 $i$ 个点能和右边第 $j$ 个点相连当且仅当 $s_i+t_j\ge c$。

首先，完全可以令 $c=0$，且 $s_i$ 的值全为非负，$t_i$ 的值全非正。

先将右边的点按入度大小排序，其权值也必然是非降的，并且能和右边 $i$ 相连的左边的点也必然能和右边 $i+1$ 相连，因此我们只需找出哪些新点和 $i+1$ 相连，依次确定权值即可。

## H. Simplicity is the Ultimate Sophistication

solved by chitanda, upsolved by none

---

chitanda's solution

剩下的 $n-k$ 个点必然是良序的，我们先将它们排序。对于那 $k$ 个点，可以用 $2^k$ 枚举答案选了哪些点，然后我们需要从 $n-k$ 个点中删除最少的点使得剩下的点满足要求。

$k$ 个点中枚举选出的那些点也必然是良序的，设 $n-m$ 个点为左边的点，选出的点为右边的点。

我们用 $f[i][j]$ 表示左边点中的前 $i$ 个点，与右边点中的 $j$ 个点已经合并完毕，并且保证右边 $j$ 之后的点不与左边前 $i$ 个点冲突时最少需要删除的左边的点数。

从 $i$ 转移到 $i+1$ 时，首先可以直接删除这个点来转移。其次，判断出左边 $i+1$ 号点能插入右边点的位置（可能不存在），设为 $p$ 之后，再用 $f[i-1]$ 来更新 $f[i][p]$ 。

## I. Lies, Damned Lies, and Statistics

upsolved by skywalkert

---

skywalkert's solution

枚举序列大小后根据中位数和平均数可以得到标准差最小的序列，如果未达到所需标准差则在维持平均数不变的情况下调整数字使标准差增大，最后二分一下调整的量即可。

注意调整数字可能不只是在中位数两边。

# Replay and Summary

none is available