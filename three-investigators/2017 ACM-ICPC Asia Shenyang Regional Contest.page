# Contest Info

date: 2017.10.22 09:00-14:00

practice link: **onsite**

# Solutions

## A. BBP Formula

upsolved by skywalkert

---

skywalkert's solution

根据题目中给出的式子，可以得到一个看上去需要高精度浮点数的做法，但实际上由于只需要精度误差不超过 $0.0625$，在使用快速幂避免不必要的浮点数运算后直接使用 `double` 暴力计算即可。

## B. Bridge

solved by chitanda, upsolved by none

---

chitanda's solution

考虑用线段树维护，分以下几种情况：

1. 加入一条横向边，设连接的两个点分别是 $x$ 和 $y$，$x$ 在 $y$ 左边
    * 如果另一条对应的横向边没有连通，那么这条边必然是桥
    * 否则，从 $x$ 向左找到第一个竖边，从 $y$ 向右找到第一个竖边，
        + 若有哪边不存在竖边或者如果没有构成环（利用线段树查询区间的横边是否都存在），那么这条边也必然是桥
        + 如果构成了环，那么必然是将这个环上的边都变成了非桥边（两条竖边额外讨论）

2. 加入一条竖边，设两个点分别是 $x$ 和 $y$ ，向左向右分别找到第一个竖边，
    * 若两边都找到并且与新加的边构成环，那么加的这条边没有影响，也不是桥边
    * 若只有一边找到且与新加的边构成环，那么会将这个环上所有边构成非桥边（那条竖边额外讨论）
    * 否则，这条边是桥边

3. 删除一条边，即加边的逆

对于竖边，维护它左右第一个竖边是哪个（利用上述讨论可以顺便维护），然后通过查询它能否与其中一个构成环可以轻易知道它何时是桥，何时不是。

## C. Empty Convex Polygons

solved by skywalkert, upsolved by none

---

skywalkert's solution

枚举一个点 $P$ 作为答案对应的凸包中最左下方的点，只保留该点右侧可能存在于凸包中的点 $Q$，则 $\vec{PQ}$ 对应的极角区间为 $(-\frac{\pi}{2}, \frac{\pi}{2}]$，可以直接排出极角序，沿着极角序 DP 凸包的轮廓。

定义 $f(P, Q_1, Q_2)$ 表示 $P$ 是答案中最左下方的点， $Q_1$ 和 $Q_2$ 是当前凸包轮廓上枚举的最后两个点，在这种情况下是否满足之前的轮廓内部没有点（但轮廓上可以有点），如果可以满足，则记录当前轮廓能扫过的最大面积。

转移时有两种，一种是从 $P$ 开始新的轮廓，一种是为之前的轮廓增加一个新的点 $Q_3$，为了方便转移，可以预处理出任意三个点组成的三角形内部是否有点，以及三角形的三条边上是否有点。

更新答案有三种，一种是直接根据 DP 信息更新，一种是不能 DP 但是自己可以作为一个答案的三角形，一种是在 DP 的轮廓后加一个只能作为结束的三角形。

时间复杂度 $\mathcal{O}(n^4)$。

---

braveTester's comment

如果将边按照极角序 DP，然后枚举凸包基点 $P$，按顺序 DP 出 $f(P, Q)$ 复杂度为 $O(n^3)$。

具体来说，$f(P, Q)$，表示基点为 $P$ 且最后一个点为 $Q$ 时的最大空凸包面积，设当前枚举的有向边为 $e = (Q, Q')$，由于是按照极角序进行 DP 的，因此构成 $f(P, Q)$ 的所有边的极角序小于 $e$，因此加入 $e$ 一定与原来的边构成非严格左转。因此如果可以 $O(1)$ 判断一个三角形内有没有给定点，则可以在 $O(n^3)$ 的时间内得出答案。

接下来只需要知道新加入的这个三角形内有没有点即可。注意到，在共边的情况下，如果一个三角形在另一个三角形内部，则共边的两个角有严格的大小关系。因此可以 $O(n^2)$ 枚举公共边，然后 $O(n)$ 算出每个点与公共边构成的三角形中在共边上的两个角，排序之后扫描一遍即可。因此预处理复杂度 $O(n^3 \log n)$。为了避免精度误差，角的表示可以通过余弦表示。

更好的预处理做法是枚举一个点 $P$，将剩下的点依 $P$ 按照极角序排序，然后枚举另一个点 $Q$，再依顺序枚举极角序比 $PQ$ 大的边 $PR$，这样只要知道已扫描过的边中 $QR$ 同 $PQ$ 的最小夹角即可。复杂度 $O(n^3)$。

按照更好的做法预处理后，总复杂度 $O(n^3)$。

## D. Defense of the Ancients

upsolved by skywalkert

---

skywalkert's solution

两个阵营任意时刻都只会针对对方的一个角色展开攻击，这样可以尽量减少之后受到的伤害。

考虑一段时间内己方阵营的攻击力之和不变，记为 $W$，此时攻击对方角色的顺序为 $p_1, p_2, \cdots, p_n$，则预计己方会受到的伤害总量为

$$\sum_{i = 1}^{n}{\frac{\sum_{j = 1}^{i}{\mathrm{HP}_{p_j}}}{W}\mathrm{AP}_{p_i}}，$$

该攻击顺序需要满足任意交换攻击顺序中任意两个角色的位置都不会使伤害总量变少，可以分析得出 $i < j$ 时有 $\frac{\mathrm{AP}_{p_i}}{\mathrm{HP}_{p_i}} \leq \frac{\mathrm{AP}_{p_j}}{\mathrm{HP}_{p_j}}$，这里比值相等的角色可以按任意顺序排列。

注意到攻击对方的顺序是和己方攻击力之和无关的，因此两个阵营被攻击的顺序都只和自己阵营的属性有关，可以预先得到这样的被攻击顺序。

由于题目要求的精度较高，直接模拟攻击过程中角色死亡的事件可能会造成极大的精度误差，或者导致超时，因此需要继续挖掘攻击过程的特性。

考虑最开始时两个阵营预计会产生的伤害总量所占比例，可以分别写成 $k \frac{S(A)}{S(B)}$ 和 $k \frac{S(B)}{S(A)}$ 的形式，其中 $S(A)$ 只和 $A$ 阵营的属性有关， $S(B)$ 只和 $B$ 阵营的属性有关。可以发现如果一开始某个阵营的攻击比就比另一个阵营的攻击比高，那么之后都会保持这样的优势直到胜利，否则会平局。因此只需要比较 $\frac{S(A)}{S(B)}$ 与 $\frac{S(B)}{S(A)}$ 的大小关系即可。

## E. Five-round Show Hand

upsolved by skywalkert

---

skywalkert's solution

每个玩家的出牌决策只与自己的手牌有关，需要找出最好的五步出牌。

由于存在很多牌型是同优先级的，最好直接根据特性搜索，而不是枚举牌型。

- 同花顺、四带一、三带二：牌型本来就很少，直接搜即可，当然，四带一的单牌是无关紧要的，也可以去除枚举量
- 同花：可能要从 $x$ $(5 \leq x \leq 11)$ 张牌里选出 5 张或 10 张，能选 10 张自然是要选的，将两组同花合起来搜，保证每种花色的同花只搜一次，枚举量可以除掉 $10 \choose 5$
- 顺子：该牌型及之后牌型只和点数有关，将花色信息去除，直接按点数搜
- 三带一、两对、一对、散牌：可以直接按点数贪心，不需要搜索

## F. Heron and His Triangle

solved by skywalkert, upsolved by none

---

skywalkert's solution

由海伦公式可得， $t$ 满足 $3 t^4 - 12 t^2 - 16 S^2 = 0$，也即 $3 (t^2 - 2)^2 - 16 S^2 = 12$，求其特征根和一组最小解即可生成出所有解，满足 $t \leq 10^{30}$ 的解不多，可以预处理出来。

## G. Infinite Fraction Path

solved by skywalkert, upsolved by none

---

skywalkert's solution

从 $i$ 向 $(i^2 + 1) \bmod n$ 连一条边，图的结构呈现为许多的内向树结构。

每个点对应的小数是一段不循环数字串加一段循环数字串，不难发现，如果两个点对应的小数不同，那么比较前 $n$ 的数位一定能区分开它们。

沿用后缀数组的思想，利用两次基数排序可以从长度为 $2^k$ 的字符串大小信息转移到长度为 $2^{k + 1}$ 的字符串大小信息，将 $n$ 个起始位置对应的无穷长度字符串前 $n$ 位排序后选取最大的串输出即可。

## H. Legends of the Three Kingdoms

solved by skywalkert, upsolved by none

---

skywalkert's solution

令 $f(i, a, b, c, d)$ 表示当前该第 $i$ 个角色决策，这四个角色的血量分别为 $a, b, c, d$ 时到达三种终态的概率，其中角色按照主公、反贼、忠臣、内奸的顺序排列，转移如下：

- 如果当前状态为某种终态，那么到达该终态的概率为 $1$，到达其他终态的概率为 $0$
- 否则如果当前决策的角色已经死亡，那么由下一个角色进行决策
- 否则获取当前决策的角色可能的所有决策，按照其阵营决定要使用哪些决策，取那些后继状态概率的平均值

记忆化搜索即可，注意精度误差。

## I. Little Boxes

solved by skywalkert, upsolved by none

---

skywalkert's solution

答案可能达到 $2^{64}$，可以特判，也可以直接用 `__int128_t` 存储，需要手写输出方法。

## J. New Self-describing Sequence

upsolved by skywalkert

---

skywalkert's solution

考虑一个数字 $x$ 往后至少走多少步才会使得 $\mathrm{high} = \left\lfloor\frac{x}{10^k}\right\rfloor$ 发生变化，直接考虑是比较麻烦的，但是注意到 $\mathrm{high}$ 发生变化后 $\mathrm{low} = x \bmod 10^k$ 的值是很小的，不会超过 $9 \cdot (\left\lfloor\log_{10}{x}\right\rfloor + 1)$，可以找出这些关键点，预处理关键点之间的转移，尝试从高位到低位依次确定从 $1$ 往后走 $n - 1$ 步的数字值。

令 $f(\mathrm{len}, \mathrm{pre}, \mathrm{low})$ 表示 $\mathrm{digitSum}(\mathrm{high}) = \mathrm{pre}$ 时最多走多少步可以使得 $\mathrm{pre}$ 不变化，此时新的 $\mathrm{low}$ 是多少，以及之前走到的所有 $\mathrm{low}$ （不含第一个）之和，那么对于 $f(0, \mathrm{pre}, 0)$，步数显然是 $0$，否则可以计算 $f(\mathrm{len} - 1, \mathrm{pre} + \left\lfloor\frac{\mathrm{low}}{10^{\mathrm{len} - 1}}\right\rfloor, \mathrm{low} \bmod 10^{\mathrm{len} - 1})$ 并往后移动一步（不断地使第 $\mathrm{len} - 1$ 位变化）直到不能移动，即可维护所需信息。

时间复杂度 $\mathrm{O}(10 M (9 M)^2 + 10 T M)$，其中 $M$ 是答案的最大位数。

## K. Rabbits

solved by skywalkert, upsolved by none

---

skywalkert's solution

在浪费掉一个最左或最右区间后，所有的区间都是可以枚举的，贪心选择即可。

## L. Tree

solved by chitanda, upsolved by none

---

chitanda's solution

考虑每条边，如果这条边两边的连通块点数都大于等于 $k$，那么相当于两边都能有 $k$ 种颜色，可以加入答案。

## M. Wandering Robots

solved by skywalkert, upsolved by none

---

skywalkert's solution

无向图随机游走问题，计算与起始状态连通的所有点的直接后继个数之和，计算与起始状态连通的所有终态点的直接后继个数之和，答案是两个数字之比。

由于全图连通，而且障碍数较少，可以依次添加这些障碍并计算相应的后继个数，需要支持查询一个点是否是障碍。

# Replay and Summary

## Replay

热身赛题目太水不表，测了下环境，CE 不算罚时，系统栈大概 1~4 M 的样子，可以扩栈。听别的队说，评测机运行速度大概 1 秒 $5 \times 10^8$ 次整数乘法。

开场才开始发题，`T` 先去查了下配置，发现热身赛的配置都在！

`L` 从头开始读，`T` 从尾开始读，`H` 从中间挑短的读。

看题 1 分钟左右，`H` 给 `T` 喂了一道 I，`T` 去码了一个 `int128` 的输出，输入 `long long` 写成 `%d` WA 了一发，错失一血。

然后 `H` 和 `T` 讨论 K，构了一个假算法交了 WA，争论了一会写出了真算法。

`L` 和 `H` 交换了一下 A B C F 的题意，准备把 F 丢给 `T`，`T` 看完 L 把 L 喂给 `H`，滚下机子去推 F。

`H` 码完 L 检查了一下，提交，1A！距离一血只有 5 分钟。

`T` 上机打表找 F 规律，很快找到了规律然后打开了 eclipse 写 Java（？？？），经过队友及时劝阻改回 C++ 写 `int128` 输入，写完 1A。

队内交流进度，交流了下 `T` 说 C 会 $O\left(n^4\right)$，`H` 发现自己 C 的做法会被 hack，然后搁置。

`H` 发现 B 不是很难想于是去想 B，`T` 跟榜思考 G，`L` 继续往后读，`T` 发现后缀数组能做于是上去敲板。

`T` 敲板过程中改来改去没改对，G 首次提交 WA，打印查错，`H` 上去写 B，此时 `L` 已读完所有题目正在怼 A，被 `T` 忽悠帮忙 debug。

`T` 滚下机子给 `L` 讲代码，`L` 挑了一个爆 int 的错误，T 上去莽了一发 WA。

`T` 再次滚下机子，从 `L` 处得到 A H J 的题意，秒了 H，不会 A 非打表做法，觉得 J 以前做过但忘了，发现 `L` 在怼 A，赶紧以跟榜为由骗 `L` 去想 M，然后复习了一遍后缀数组，挑了 G 的一个数组误用。

此时 `H` 在写 B，突然键盘斯巴达（？？？），无限退格删代码，场面一度十分尴尬，幸好技术人员及时赶到，帮忙重启电脑换了设备，之后没有遇到技术问题。

`T` 赶紧滚上去写了 G，终于 AC，然后滚下来换 `H` 写 B，`H` 写着写着发现 B 少一种情况，陷入沉思。（？？？）

`L` 在这段时间里凑出了 M 的规律，和 `T` 讲了一下做法，最后被 `T` 抢走去写了，写了一段时间，1A。

`T` 继续写 H，暴力模拟转移，写得十分冗长，结果没过样例，后来发现是输入顺序搞错了。

`H` 完善做法后上去改 B，`H` 调完交上去 WA，再次打印之后发现了错误，改完之后 AC，结果与一血差了 10 秒左右，好气啊。

`T` 滚上机改了下 H，交了 WA，打印交由 `L` 查错，估了下 E 暴力的复杂度发现不行，改去写 C，`H` 和 `L` 讨论 A D E 的做法。

`T` 写了个假的 C，样例 shuffle 一下就过不去，`H` 来帮忙查错，然后用相同的方法 hack 了 `T` 的做法。（？？？）

`L` 表示 H 代码没什么不对，`T` 返回去魔改 H，`double` 改成 `long double`，WA，去掉 eps，AC（？？？），我和我的小伙伴们都惊呆了。

`H` 和 `T` 重新搞了下 C 的 $O\left(n^4\right)$ 做法，`T` 感觉没啥问题然后上去改，过样例提交，WA，打印交由 `H` 查错，`T` 上机查错，`L` 继续思考 D 和 E。

`H` 读完代码给 `T` 讲了几个 trick，改了下 C 的转移，继续 WA，继续多人查错。`T` 发现有个地方可能没有更新答案，加上之后终于 AC。

三只菜鸡在最后 4 分钟无所事事，开始分析场上过题情况，分析可能的排名，专心吃瓜。

## braveTester

菜鸡本场没有碰键盘，贡献了 M 的做法，帮 tls 查了 1 个 bug，以及帮 tls 验了 H 写的没问题，然后就没有然后了。

菜鸡全靠 tls 和 lls，我的队友最棒啦！

## chitanda

一开始有点不清醒，给了个假算法给 tls， 导致一发罚时。

B 题虽然过了，但自己花了太多时间，并且还写复杂了，因此在别的题上没有什么贡献，也使得 tls 不得不花大量时间在中档题上，没有多余的时间来思考难题。

然后夸夸自己，在 B 题漏情况以及 WA 的时候能冷静下来思考，最后也能冷静的帮 tls 查 C 题的错，这一点相比训练来说有了很大提升。

总之运气不错，hdu 没能正常发挥，而我们写的题都过了。

## skywalkert

这场犯的 sb 错误实在太多，而且都比较致命，所幸题目比较适合我队想出大部分题目，以及我们比较幸运地找到了一些题的 trick。

重点观察的几支队伍排名都在靠前的位置，能打到这个结果挺困难的，当时感觉 hdu 最后一小时可能搞出 D，或者由数据结构大师强行码出 B，排名会很玄，其他队除非超过我们题数否则罚时应该会比我们多所以不做考虑。结果我们 rp 全送到这里了，拿了第二，如果其他强队发挥再正常一点我们就拿不到了。

签到题阶段我们的抗压状态没有做到很好，想题速度和查错能力还有待加强。补题还需要再加快进度，遇到做过的题还是得尽量保证能再次思考出来。

~~这场没有插头 DP 真不科学。~~