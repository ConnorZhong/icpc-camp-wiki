Contest Info
============

date: 2018.04.19 09:52-14:52

[problems](https://icpc.baylor.edu/download/worldfinals/problems/icpc2018.pdf)

Solutions
=========

A. Catch the Plane
------------------

solved by skywalkert, upsolved by none

------------------------------------------------------------------------

skywalkert's solution

取出所有事件点 $(a, s - 1)$,
$(b, t)$，每个事件点有可以决定选一辆车试着上车或者等下一个时间，由于时间是严格递增的，DP
一下就行了。

B. Comma Sprinkler
------------------

solved by skywalkert, upsolved by none

------------------------------------------------------------------------

skywalkert's solution

每个字符串拆两个点分别表示前/后是否要有 comma，取出所有 comma 并根据
space 或 comma 在节点之间连边，从初始状态 bfs 出所有可达状态然后加 comma
即可。

C. Conquer The World
--------------------

upsolved by skywalkert

------------------------------------------------------------------------

skywalkert's solution

军队能不移动就不移动，图中会有一些点多出军队，有一些点缺少军队，根据缺少的数量计算最小费用最大流。

由于图中不存在环，所以退流的情况只会是从一个子树换到另一个子树，可以在它们的
lca 处进行决策。

由于流量不超过
$10^6$，维护子树中每个还没选的多出的军队选择的代价，每个选了但是想踢掉的代价，以及整体分别的增量是多少，强行启发式合并子树信息即可。

时间复杂度 $\mathcal{O}(10^6 \log^2(10^6))$。

D. Gem Island
-------------

upsolved by skywalkert, chitanda

------------------------------------------------------------------------

skywalkert's solution

考虑一个序列 $a_1 \geq a_2 \geq \cdots \geq a_n$
在最终能出现的概率，可以枚举它实际的**可重集**排法，计算每个排法对应的操作序列数量，再乘以每一轮的概率。具体来说，设
$c_j$ 表示 $a_i = j$ 的数量，则该序列出现的概率为
$$\frac{n!}{\prod_{j}{{c_j}!}} \frac{d!}{\prod_{i}{(a_i - 1)!}} \frac{(n - 1)! \prod_{i}{(a_i - 1)!}}{(n - 1 + d)!}$$，化简后可得
$\frac{n!}{\prod_{j}{{c_j}!}} / {n - 1 + d \choose d}$。

注意到分母不变且数值上不超过
${999 \choose 500} < 2^{994}$，期望答案也不超过
$n + d < 2^{10}$，所以分子也不会超过 $2^{1004}$。可以尝试 DP
处理这样的序列，统计概率中的分子与前 $r$ 大元素的加权和。

令 $f(i, j, k)$ 表示权值大于等于 $i$ 的元素恰好有 $j$ 个且总和为 $k$
时的信息，当 $j < r$ 时信息只记录方案数，而当 $j \geq r$
时信息记录所有方案的前 $r$ 大元素之和。直接 DP 的复杂度是
$\mathcal{O}\left(n^2 \sum_{i = 1}^{d + 1}{\frac{n + d}{i}}\right) = \mathcal{O}(n^2 (n + d) \log d)$
的，实际上很多状态无用，这个做法就能很快通过……

------------------------------------------------------------------------

chitanda's solution

实际上，最终每种不同的结果（任意一个 $a_i$
不同为不同的结果）等概率出现。

那么可以转换成枚举 $j$ 和 $k$，求有至少 $j$ 个 $a_i\ge k$
的概率，累加概率就是答案，而概率可以通过方案数除总方案数求得，而总方案数为
$\binom{n+d-1}{n-1}$。

至少 $j$ 个大于等于 $k$ 的方案数可以这么算：从 $n$ 个中选取 $j$
个数，给他们分配 $k-1$ ，然后剩下的 $n+d-j(k-1)$ 个再任意分配给 $n$
个数，并且至少分配 $1$ ，这个方案数是
$\binom{n}{j}\binom{n+d-j(k-1)-1}{n-1}$
，可是这样会算重，因为若实际出现了 $i(i\ge j)$ 次，那么会被计算
$\binom{i}{j}$ 次方案。

我们转化为求恰好出现 $j$ 次的方案数：用上面方法计算的结果，枚举 $i(i>j)$
减去 $\binom{i}{j}$ 乘上恰好出现 $i$ 次的方案数，就能得到恰好出现 $j$
次的方案数，然后就能求出至少 $j$ 次的真实方案数了。

注意到
$\sum_{k=1}^{n}(\frac{n}{k} )^{2}\le \frac{\pi^2}{6}n^2$，所以时间复杂度为
$\mathcal{O}(n^2)$ 乘上高精度。

E. Getting a Jump on Crime
--------------------------

upsolved by chitanda

------------------------------------------------------------------------

chitanda's solution

需要做的是对于两个楼，判断他们是否能跳，那么只需要解出速度，然后判断会不会碰到其他楼即可。

具体的，解速度可以设一个角度 $\theta$
，然后通过二倍角公式和辅助角公式暴力算出最多两个可行角度，易分析得必定选其中水平速度小的那个。

而判断是否碰到其他楼，可以枚举其他的楼，判断四边的四个线段是否和跳跃路径的投影相交，若相交得到交点，然后计算出跳到这个位置时的高度，和楼高比较即可。

F. Go with the Flow
-------------------

solved by chitanda, solved by none

------------------------------------------------------------------------

chitanda's solution

枚举答案，然后抠出每行的空格位置，用两个指针扫一下相邻两行的空格 DP
一下即可

G. Panda Preserve
-----------------

upsolved by chitanda, skywalkert

------------------------------------------------------------------------

chitanda's solution

距离最近输入点最远的多边形内的点只可能是两种，一种是点集的维诺图的顶点，一种是点集的维诺图的边和多边形边的交点。

维诺图的顶点个数只会有 $O(n)$ 个，而维诺图和多边形交点的个数也只有
$O(n)$ 个，暴力检查这些点即可。

[三角剖分](/chitanda/delaunay%e4%b8%89%e8%a7%92%e5%89%96%e5%88%86)

------------------------------------------------------------------------

skywalkert's solution

考虑半径增大过程中未覆盖区域的变化，类似海岸线的效果，可知答案必然在多边形内某些点取到，这些点要么是多边形与
voronoi 边的交点，要么是多边形内的 voronoi 点。

可以分别考虑 voronoi
图中每个区域的情况，每个区域由一个顶点支配，边可以用两两中垂线取半平面交得到，为了避免讨论射线的情况，可以在外围加一圈边界。

对于第一种情况，可以避免射线情况，由 voronoi 图的性质可知多边形与
voronoi 边不会重合，直接计算线段交点即可。

对于第二种情况，用射线法确定点是否在多边形上或内部即可。

时间复杂度 $\mathcal{O}(n^2 \log n)$。

H. Single Cut of Failure
------------------------

solved by chitanda, upsolved by none

------------------------------------------------------------------------

chitanda's solution

显然两个对角线能将所有线切割（由于答案线段的端点不能是顶点，所以需要小小偏移一下），所以我们只需要判断答案是否为
$1$。

这个割线必定切割两个对角线之一，因此我们可以枚举这个对角线，而这个对角线将矩形分成两部分，割线的端点分别在两个部分。对于端点只在其中一部分的线段，得到这一部分割线端点的一个区间限制。而对于端点分别在两个部分的线段，我们枚举第一部分割线端点的位置，也可以得到第二部分割线端点的位置限制，直到遇到一个合法解。

I. Triangles
------------

solved by skywalkert, upsolved by none

------------------------------------------------------------------------

skywalkert's solution

三角形有一条边必然为横边，按另一个顶点在横边的上/下方分情况统计，预处理五个方向能延伸的距离，枚举横边的右端点统计左端点贡献，在扫过左端点和左端点能延伸的最右位置时修改贡献即可，时间复杂度
$\mathcal{O}(r c \log c)$。

重点是 `c++14` 没有 `gets`。

J. Uncrossed Knight’s Tour
--------------------------

unsolved

K. Wireless is the New Fiber
----------------------------

solved by chitanda, upsolved by none

------------------------------------------------------------------------

chitanda's solution

原图怎么连实际上没有什么关系，我们只关心每个点的度数。显然我们需要将总度数和减到
$2(n-1)$，那么每次选择一个度数最大的点将其度数变成 $1$ 肯定最优。

之后构造解就是每次选择一个度数为 $1$
的点，再选一个当前度数最大的点相连，显然这样能构造出一棵树。

Replay and Summary
==================

skywalkert
----------

本次比赛中暴露的问题有：

-   不能很好控制情绪。例如，在看到排名超过往年成绩时精神开始松懈。再例如，对熟悉领域中不会做的题目产生畏难情绪。
-   思考时间与上机时间分配不合理。在尝试解决 B 和 I
    题时，匆忙上机，上机过程中在输入、输出细节处卡壳，浪费机时。思考和编程效率需要提升，尽量做到
    "think twice, code once"。调整心态，做事情时不能一直在梦游。
-   未关注到团队状态，未及时进行调整。团队默契度还可以，但是比赛中不擅长快速调整心态。心态太年轻，很容易忘记比赛策略。不知道怎么解决。

今后也需要注意以上现象，降低可能产生的消极影响。
