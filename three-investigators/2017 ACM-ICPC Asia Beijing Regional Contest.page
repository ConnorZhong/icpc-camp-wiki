# Contest Info

date: 2017.11.21 17:10-22:10

[practice link](https://cn.vjudge.net/contest/200474#overview)

# Solutions

## A. Domains

upsolved by skywalkert

---

skywalkert's solution

添加规则时，首先检查域名和虚拟私网的命名是否正确，在正确的情况下检查该域名与已有域名是否存在冲突。

冲突分为三种：存在域名与该域名完全相同、存在域名去掉通配符后是该域名的后缀、存在域名去掉通配符以该域名去掉通配符后的字符串为后缀。

为了方便去掉通配符进行匹配，可以将逆序域名插入三棵字典树中，则三种冲突分别对应字典树中的路径和子树信息，插入时维护一下即可。注意，对于不同的通配符需要讨论不同的冲突。

查询域名时，不含通配符的情况很简单，含有通配符时存在一种情况是以 `*` 开头的域名能够完全支配查询的域名，除了这种情况以外的其他情况都可能存在以 `#` 开头的域名与之匹配。

## B. K-Dimensional Foil

upsolved by skywalkert

---

skywalkert's solution

假设存在一组解，则通过平移和向量组正交化可以得到一组解使得：

- 第一个向量所有维度的坐标都为 $0$
- 若第 $i$ 个向量的前 $j$ 个维度的坐标可能不为 $0$，其他维度的坐标都为 $0$，则第 $i + 1$ 个向量只有前 $j + 1$ 个维度的坐标可能不为 $0$

因此可以考虑在原有点集上通过已有距离，不断地构造出满足上述性质时每个向量的第 $j$ 维信息，检查是否可能无解。

具体来说，假设已经得到了前 $j$ 维的信息，也即得到了剩下维度的欧几里得距离 $\mathrm{dist'}$。如果存在一个点 $k$ 使得这个点的第 $j + 1$ 维可能不为 $0$ 且它到第一个点的距离为正，那么可以为之构造一个第 $j + 1$ 维坐标 $x_k$，并将其更高维的坐标设置为 $0$，这时对于其他点 $i$ 我们有 $\mathrm{dist'}(0, i) = \mathrm{dist'}(k, i) - x_k^2 + 2 x_k x_i$，从而可以构造出所有的 $x_i$，并检查合法性，以及更新 $\mathrm{dist'}$。

当然随手找一个 $k$ 的话精度是非常爆炸的，虽然枚举精度误差可以通过吧……但是找 $\mathrm{dist'}(0, k)$ 最大的，似乎也很显然？

## C. Graph

solved by chitanda, upsolved by none

---

chitanda's solution

依次对每个点，将连接了它的边放入一个序列，这样最终会有一个长为 $2m$ 的序列，那么一个询问 $[L,R]$ 在这个序列上也有个对应区间，只需考虑这个区间内的边。

考虑莫队的另一种形式，即只有加没有减但有撤销的，对于左端点在一个块内的询问，将其按右端点排序，这样这些询问右端点递增，而左端点的变化不超过块大小，因此对每个询问，先递增右端点，而左端点可以每次加边然后回退到原来状态，用按秩合并的并查集维护即可。

## D. Chinese Checkers

solved by chitanda, upsolved by none

---

chitanda's solution

题目中的坐标在写题的时候很麻烦，因此可以修正下第二个坐标的值，这样就能很容易模拟了。PS:由于两个格子中间最多 11 个格子，因此可以预处理出长为最多 11 的一个二进制串是否回文。

## E. Cats and Fish

solved by chitanda, upsolved by none

---

chitanda's solution

依次枚举被吃的鱼，暴力模拟。

## F. Secret Poems

solved by braveTester, upsolved by none

## G. Liaoning Ship’s Voyage

solved by skywalkert, upsolved by none

---

skywalkert's solution

为了防止各种精度误差，此题使用全整数。

题意上可能有些小问题，但是没有卡题意的数据，数据大概都去卡线段与三角形内部交的情况了。

从起点开始 bfs 可以到达的不是坏天气的检查点即可，关键在于检查是否可以到达。

如果线段与三角形三边有恰好一个交点，且交点不在顶点处，则意味着与三角形内部有交。

剩下的情况为线段可能在三角形内部、线段端点可能在三角形顶点、线段一端在三角形一条边上且线段经过第三个顶点这三种情况，其中前两种情况都可以通过检查线段中点的位置来判定，第三种情况可以枚举出第三个顶点是哪个顶点来判定。

第三种情况较坑……

## H. Puzzle Game

solved by chitanda, upsolved by none

---

chitanda's solution

枚举被修改的元素，通过预处理可以知道不包含它的最大子矩阵和，然后枚举上下界，计算出包含它的最大子矩阵和，复杂度 $O(n^4)$，需要优化常数。

**upd：** 实际上，可以对每个矩阵元素预处理出包含它的最大子矩阵和，设这个值为 $mx[i][j]$ ，方法为：先枚举上下界，然后枚举列，对每列分别算出向左和向右拓展的最大值，这样可以算出包含这一列的最大子矩阵。先枚举上界，再顺序枚举下界算出上述值，然后倒序枚举下界来更新 $mx[i][j]$ 的值。这样就能将总复杂度降到 $O(n^3)$


## I. Colored Nodes

solved by skywalkert, upsolved by none

---

skywalkert's solution

操作每 $N$ 轮一循环，可以预处理出一个循环最终会使哪个点的颜色染到哪个点上，这样的染色过程形成一些外向树（每个点入度为 $1$），每棵外向树是一个环和多棵树组成的结构。

对于一棵外向树，最终能稳定出现的颜色一定是最开始就在环上的颜色，而这些颜色也会依次染上每一棵在该外向树内的树，所以环上的颜色是等概率出现的，因此只需要对这棵树算出具体执行 $N$ 轮操作时的期望颜色数。

那剩下的就是按照时间节点模拟一下，算下贡献了。（存在一些细节）

## J. Pangu and Stones

solved by skywalkert, upsolved by none

---

skywalkert's solution

$f(L, R, k)$ 表示区间 $[L, R]$ 合成 $k$ 堆的代价，枚举子区间划分不同堆的归属，之后确定在 $[L, R]$ 时是否需要合并成一堆即可。

# Replay and Summary

None is available.