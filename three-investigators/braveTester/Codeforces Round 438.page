D. Huge Strings
---------------

设一个字符串的答案为 $k$，则其中须有 $2^k$ 种不同的长度为 $k$ 的串。

初始时，每个字符串最多有 $\max\{100 - k + 1, 0\}$ 种长度为 $k$ 的串。

每合并一次，至多会在接缝处增加 $k$ 种长度为 $k$ 的串。

所以在接缝处造成的不同的长度为 $k$ 的串最多有 $mk$
种，而最初的字符串有的不同的长度为 $k$ 的串最多有
$100 \max\{100 - k + 1, 0\}$ 种，所以有
$2^k \le mk + 100 \max\{100 - k + 1, 0\} \le 100k + 10000$。

可以发现，$k$ 最大为 $13$。

因此对每个字符串，用 $13$ 个长度为 $2^{13} = 8192$ 的 `bitset`
表示对于不同的 $k$ 其长度为 $k$ 的子串分别有谁，然后再记录一下最左/右
$12$ 个字符即可。

复杂度 $O\left(m \times 13 \times (2^{13} / 64 + 1)\right)$。

F. Yet Another Minimization Problem
-----------------------------------

比较神奇的优化技巧...可能我还是太孤陋寡闻了...应该是只要决策具有单调性都可以这么搞。

令 $f[i][j]$ 表示将前 $j$ 个分成 $i$ 段时的最小代价，容易发现，当 $i$
固定时，$f[i][j]$
的最优决策（同样右取最右）是单调不减的。利用这个性质，可以通过分治的方法在
$O(n \log n)$ 的时间解决这道题。

用 `solve(level, l, r, p, q)` 表示 $f[\text{level}][l\dots r]$
的可能决策为 $f[\text{level} - 1][p\dots q]$。然后暴力求解
$\text{mid} = \lfloor(l + r) / 2\rfloor$ 的 $f$，同时得到最优决策位置
$\text{pos}$，由前述性质，继续递归调用
`solve(level, l, mid - 1, p, pos)` 和 `solve(level, mid + 1, r, pos, q)`
即可。这样，在不考虑计算代价时，计算一层的复杂度是 $O(n \log n)$ 的。

但注意到，为了计算代价，需要使用一个 $\text{cnt}$
数组统计最后一段内每个数的个数，这个的转移是跟长度相关的。为了不使计算代价成为复杂度瓶颈，需要好好规划一下，具体做法如下。每次递归时维护
$[p + 1, l]$ 之内的 $\text{cnt}$ 信息，并且保证递归完成后的 $\text{cnt}$
数组还是维护的这个信息即可。由于每次左端点的活动范围是
$[p, q]$，右端点的活动范围是 $[l, r]$，因此每层总计是 $O(n)$
的修改代价，又由于最多只有 $O(\log n)$ 层，因此计算代价的总复杂度是
$O(n \log n)$。

综上，总复杂度为 $O(nk \log n)$。
