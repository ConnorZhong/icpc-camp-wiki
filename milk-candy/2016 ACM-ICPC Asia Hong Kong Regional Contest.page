# Info

Date: 2017.10.16 12:15-17:15

[Link](https://vjudge.net/contest/192060)

# Solutions

## A Colourful Graph

solved by Jove, upsolve by none

---

Jove's solution

构造题。首先我们先观察初始态和目标态的颜色集合，如果目标态中的颜色，初始态中没有，那肯定是$impossible$，反之是可行的。

首先，我们要通过$bfs$预处理出，从每个点出发到其他点路径的前驱，这样方便得到两点间的一条路径。这里的复杂度是$O(n^3)$。

第一步，我们要把当前状态的颜色集合和每种颜色对应个数，调整成和目标状态相同。通过一次操作即可将多余的一种颜色减少一个，缺少的颜色增加一个，找到两种颜色任意各一个点，把两点路径上的点依次交换即可，如$1XXX2$转换为$XXX22$。这一步，最多一共需要$n$次操作。

第二步，我们现在颜色和相应个数已经确定，只需要让位置对应，可以通过交换两个点来实现。交换两点的颜色且不改变路径上点的颜色，需要$2(n-1)$次操作，这一步最多一共需要$2(n-1)n$次操作。总的操作次数少于$20000$。

## B Doors

solved by sk, upsolved by none

---

sk's solution

记两个门分别为$AA'$，$BB'$，$C$为$(0,0)$，$D$为$(0,w)$，那么$ans=min(2 \times R$，$D$到$AA'$的最短距离，$B'$到$AA'$的最短距离，$A$到$BB'$的最短距离$)/2$，当$\beta > \pi/2$时，$ans$还要和$B'$到上边界的距离的一半取$min$。

## C Playing with Numbers

solved by quailty, upsolved by none

---

quailty's solution

先考虑求最小值，最大值同理，$gcd$次数为$0$时所有操作都是$lcm$，两维分别取$max$即可，次数$\geq 2$时可以先把两维最小的$gcd$一下，再和其他$lcm$起来之后的数$gcd$，相当于两维分别取$min$，次数为$1$时显然是最后一步取$gcd$，枚举和哪个数取$gcd$即可，维护前后缀最大值可以快速求出两维的值，取$log$比较大小。

## D Peak Tram

solved by quailty, upsolved by none

---

quailty's solution

对每个$p_i$，把$p_i-(k-1),\dots,p_i-1,p_i,p_i+1,\dots,p_i+(k-1)$抠出来，得到$O(n^2)$种高度，离散化之后$dp_{i,j,k}$表示已经考虑了前$i$栋楼当前能看到$j$栋并且看到的最后一栋高度是$k$，转移枚举下一栋楼看不看，如果不看那么要调整到高度$\leq k$，可以直接算，如果看那么要调整到高度$>k$，需要枚举这个高度，前缀$min$优化转移。

## E Peak Tower

upsolved by quailty

---

quailty's solution

当矩形的相交情况不发生变化时，面积并是单峰的，计算矩形对相交/相离的事件点、矩形和边界相交/相离的事件点，将时间轴划分为$O(n^2)$段，每一段内三分求解，如果$O(n^2)$计算矩形并，复杂度是$O(n^4\log{n})$。

## F Perfect k-ary Tree

upsolved by quailty

---

quailty's solution

满$k$叉树的树高只有$O(\log{n})$，考虑$dp_{u,i,j}$表示以$u$为根的子树中选出一个以$u$为根的深度为$i$的树使得根有$j$个儿子且每个儿子挂着一棵深度为$i-1$的满$k$叉树的方案数，转移枚举是否将以儿子为根的深度为$i-1$的满$k$叉树挂上来，然后再做一次换根$dp$来计算以每个点为根的不同深度的满$k$叉树的方案数，需要维护每个点往上挂一棵深度为$j$的满$k$叉树的方案数，为了能够在递归到儿子的时候快速计算，在第一次$dp$的时候还需要记录前缀和后缀$dp$数组。

## G Scaffolding

upsolved by quailty

---

quailty's solution

时光倒流，考虑把竹子拿下来的过程，$dp_{i,j}$表示把$[i,j]$区间内高度$\geq \min_{k=i}^{j}h_k$的竹子拿下来的最小趟数以及这一趟还能拿走多少竹子，转移合并两个区间，至多有一个区间要再拿走一个矩形区域的竹子。考虑一个从高到低扫描线的过程，可以发现需要考虑的$dp$状态只有$O(n)$，因为只存在$O(n)$个合并区间的事件，将这些事件按照高度递减排序，并查集维护即可。

## H Slim Cut

upsolved by quailty

---

quailty's solution

考虑枚举最大的割边，将原图分成若干个连通块，现在就是要将这些连通块划分到$S$或$T$使得$\min(|S|,|T|)$最大，看上去是个$01$背包。

现在考虑从大到小加边，如果合并了两个连通块$u$和$v$，相当于删去两个大小分别为$size_u$和$size_v$的物品，然后添加一个大小为$size_u+size_v$的物品，由于合并连通块的次数只有$O(n)$，添加和删除物品的事件数也是$O(n)$，对时间分治结合$bitset$优化$01$背包，复杂度$O(n^2\log{n}/w)$。

如果维护$f_i$表示选出的连通块大小之和恰好为$i$的方案数，根据$0$（生）$1$（成）背（函）包（数）的可逆性，可以通过$O(n)$次运算完成添加/删除一个物品，方案数对质数取模，复杂度$O(n^2)$。

## I Special Tour

upsolved by quailty

---

quailty's solution

不妨设$n \leq m$，然后分情况讨论：

对于$n=1$，当且仅当$m=5 \vee m \geq 10$有解，$m=5$直接构造，$m \geq 10$时在前后$5$个格子分别保留$2$个插头，中间可以通过步长为$2$的路径连接。

对于$n \geq 2$，$(n,m)=(2,2)$无解，$(n,m)=(2,3),(2,4),(3,3),(3,4),(4,4)$直接构造，当$m \geq 5$时，将$n \times m$展开成$1 \times (n \times m)$然后同$n=1$。

## J Taboo

solved by quailty, upsolved by none

---

quailty's solution

对所有串建一个$AC$自动机并补全转移图，现在就是求一条从根出发不经过任何非法状态的最长路，考虑从根出发$DFS$，如果遇到环就无穷了，否则就是$DAG$，$DFS$的时候顺便$dp$一下，输出字典序最小的方案只需要贪心沿着$dp$值最大的方向再走一遍。

## K Team Up

solved by sk, upsolved by none

---

sk's solution

先对职业建树，然后自底向上合并包含子树所有技能的队伍即可。

# Replay