# Info

Date: 2017.10.13 12:30-17:30

[Link](http://codeforces.com/gym/100851)

# Solutions

## A Adjustment Office

solved by sk, upsolved by none

---

sk's solution

记选了哪些行，哪些列，以及行与列选过的个数，还有和，计算的时候行与列的拆开算，减去之前选过的数就行了。

## B Binary vs Decimal

upsolved by quailty

---

quailty's solution

记$f(s,t)=\sum_{i=0}^{|s|-1} s_i t^i$，所求即为第$n$小的满足$f(s,10) \equiv f(s,2) \mod 2^{|s|}$且$s_{|s|-1}=1$的$f(s,10)$。

注意到对于任意$k>0$均有$10^{k-1} \equiv 2^{k-1} \mod 2^k$，如果$s$满足$f(s,10) \equiv f(s,2) \mod 2^{|s|}$，那么对于$s$的长为$|s|-1$的前缀$s'$，就有$f(s',10) \equiv f(s',2) \mod 2^{|s|}$，自然就有$f(s',10) \equiv f(s',2) \mod 2^{|s|-1}$，这是一个必要条件。

考虑从空串开始扩展，每次在末尾添加一个$0$或者$1$，根据必要条件，如果当前不满足$f(s,10) \equiv f(s,2) \mod 2^{|s|}$，再继续扩展也不会出解，可以进行剪枝，否则如果$s_{|s|-1}$那么把$f(s,10)$加进答案集合，长度上限卡到$161$即可搜出最小的$10000$个解，由于涉及大数，随手写个$Python$即可。

## C Cactus Jubilee

upsolved by quailty

---

quailty's solution

称一条边是“环边”，如果它在某个简单环上，否则称这条边是“树边”。以下分两种情况讨论：

如果删去树边，新加的边只需要连接两个连通块，方案数是两个连通块大小之积减一；

如果删去环边，其所在环上的所有环边都会变成树边，由于新加的边不能经过环边，考虑每个只由树边构成的连通块，记其大小为$k$，那么方案数是$\frac{k(k-1)}{2}-(k-1)$，需要对所有这样的连通块求和之后再减一。为了快速计算，需要先记录不删边的情况下所有这样的连通块的方案数之和，删除一条环边的时候，先减去环上每个点所在连通块的方案数，再加上这些连通块合并之后的方案数。可以发现对于同一个环，删去任意一条环边之后得到方案数是相同的，因此一个环只需要计算一次。

那么只需要求出每个子仙人掌的大小以及每个点所在的只由树边构成的连通块的大小，在仙人掌上大力$dp$即可，复杂度$O(n)$。

## D Distance on Triangulation

unsolved

## E Easy Problemset

solved by Jove, upsolved by none

---

Jove's solution

签到题，按照题意做一遍即可，注意数组开到合适大小，不要越界。

## F Froggy Ford

solved by sk, upsolved by none

---

sk's solution

先二分答案$mid$，所有距离小于等于$mid$的点连边，将左边界看成起点，右边界看成终点，从起点和终点分别$bfs$，如果起点和终点不连通，找一对距离不超过$2*mid$的且可以使起点终点连通的点，在两点中间放一个石子就可以使答案在$mid$内。注意起点和终点本身也要加入判断，只是点到直线的距离计算方式有所不同。

## G Generators

solved by sk, upsolved by none

---

sk's solution

每个生成器先生成出所有的数，一共$O(nc)$个，分别存进$vector$里然后排序，每个生成器贪心的取最大的数，加起来，如果和是$k$的倍数，那么考虑在某生成器里找个数替换最大值，使最后的和不是$k$的倍数且尽可能大，扫一遍即可，注意判断无解情况。

## H Hypercube

unsolved

## I Iceberg Orders

unsolved

## J Jump

solved by quailty, upsolved by none

---

quailty's solution

初始时什么信息也没有，只能考虑先随机生成$01$串，尝试得到一个和目标串有$n/2$个位置匹配的串，可以发现单次随机的成功率是$\binom{n/2}{n}/2^n$，即使是$n=1000$也有大约$1/40$，那么$480$次随不出来的概率大约是$1/e^{12}$，已经非常小了。

假设现在已经得到$n/2$，不妨先认为位置$1$是对的，枚举$i$将位置$1$和位置$i$同时取反之后查询，如果仍然得到$n/2$那么说明原来位置$i$是错的，否则是对的。根据这些信息可以修正这个串，但是如果位置$1$是错的，那么所有位置是错的，此时会得到$0$，再将整个串取反即可。

需要注意的是，如果某时刻不小心得到了$n$，就不能再继续查询了。

## K King's Inspection

upsolved by quailty

---

quailty's solution

将所有出度和入度均为$1$的点缩起来，得到一个点数不超过$40$边数不超过$60$的有向图，暴力枚举每个点的后继，枚举量是$\prod deg^+(v)$，然后判断沿着指定后继走是否能得到一个哈密顿回路。

如果缩点后的图中有$k$个点，那么有$\sum deg^+(v) \leq k+20$，简单放缩可以得到$\prod deg^+(v) \leq (\frac{\sum deg^+(v)}{k})^k < 2 \times 10^7$，这个放缩比较松，考虑到度数都是整数，上界可以进一步缩小，枚举量是完全可以承受的。

## L Landscape Improved

solved by quailty, upsolved by none

---

quailty's solution

显然只会堆出一个山峰，于是二分高度$m$，考察是否存在某个位置$k$往上一直堆能堆到高度$m$，那么左侧山脚会被满足$h_i-i \geq m-k$的最大$i$所在岩石堆挡住，右侧山脚会被满足$h_j+j \geq m+k$的最小$j$所在岩石堆挡住，用单调栈来回扫两次可以求出每个$k$对应的$i$和$j$（如果$i$或者$j$不存在就不能放），现在就是在$[i+1,j-1]$这些位置往上堆石头，需要堆$m^2-\frac{(m-k+i+1)(m-k+i)}{2}-\frac{(m+k-j+1)(m+k-j)}{2}-\sum_{t=i+1}^{j-1}h_t$这么多的石头，这个值不能超过$n$。

# Replay