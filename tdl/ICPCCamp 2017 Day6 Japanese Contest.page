E. Randomized Binary Search Tree
================================

一棵 $n$ 个节点的 Treap， key 和 aux 都是 $[0, 1]$
均匀分布的随机数（不相等），求树每个可能的高度（$0~N-1$）对应的概率。\
如果将节点按 key 值排成一序列，那么 Treap
对应了这个序列的一棵笛卡尔树。每个节点都有 $\frac{1}{n}$
的概率成为当前区间的根。\
设 $f_{i,j}$ 为 $j$ 个节点高度恰为 $i$ 的概率，$g_{i,j}$ 为 $j$
个节点高度不超过 $i$ 的概率。有转移方程：\
$f_{i,j} = \sum_k{\frac{1}{j} (f_{i,k} \cdot g_{i,j-1-k} + f_{i,j-1-k} \cdot g_{i-1,k})}$\
这是一个卷积式，可以用 FFT 做到 $O(n^2logn)$
的时间复杂度，并且式中的两次卷积相加可以合成一次卷积，但复杂度还是很大。\
根据常识， Treap 的高度不可能太高。实际上，高度达到 50 的 Treap
出现的概率已经小于 $10^{-5}$。\
所以只需计算高度小于 h 的答案，复杂度为 $O(hnlogn)$， 其中
$h = min(n, 50)$。\
注意使用 double 即可以通过，而使用 long double 则很可能超时。

G. Hash
=======

给一个字符串 Hash 函数和参数 a, b，构造 100 个长度不超过 50 且 Hash
值相同的小写字母字符串。

    h = 0
    for i = 0, ... |s| - 1
        h = (h * a + (s[i] - 'a' + 1)) % b

随机生成足够多的长度为 7 的字符串，直到出现两个 Hash
值相同的串。（这个概率其实比较大@\_@）\
用这两个字符串拼接 7 段构成长度为 49 的字符串，一共有 $2^7 = 128$ 种。
