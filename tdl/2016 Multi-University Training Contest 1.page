A. Abandoned country \[braveTester\] \[Constroy\] \[Skywalkert\]
================================================================

边权互不相同，最小生成树唯一，第二问只需要在生成树上bfs一下就好了。时间复杂度$O(m \log m)$。

B. Chess \[Skywalkert\] \[braveTester\]
=======================================

每行互不影响，一行最多$2^m$种状态，打表计算sg值即可。时间复杂度$O(20\cdot 2^{20} + n)$。

C. Game \[Skywalkert\]
======================

最短路条数等于无障碍点数的平方，问题是如何计算任意两点的最短路。

由于每行每列最多一个障碍，所以任意两点之间的最短路最多受到一个障碍的影响，也就是说最短路要么为曼哈顿距离，要么是这个距离加2。

曼哈顿距离可以随便容斥算一下，考虑每个点到哪些点的最短路会加2，枚举一个无障碍点`s`，设障碍点为`o`，受影响的点为`*`，不受影响的点为`.`，可以得到这么一个图：

<pre>
.o......
......o.
........
...s.o**
...o....
..o*....
..**o...
..***...
</pre>
对于s和s上方的点，都会有下方`*`影响，右方`*`的影响同理，于是只需要在两个方向上维护一下每个段的`s`对应影响的`*`个数即可，由于这样的段是$O(n)$个，所以计算影响时可以暴力$O(n)$算有多少个段受影响。总时间复杂度为$O(nm)$。

D. GCD \[Skywalkert\] \[Constroy\]
==================================

离线处理，升序枚举右端点$r$，对应的$\gcd(a_l, a_{l + 1}, \cdots, a_r)$只有$O(\log a_r)$种取值，每种取值对应连续的一段$l$，当$r$变为$(r + 1)$时，只需要暴力更新本质不同的$\gcd(a_l, a_{l + 1}, \cdots, a_r)$即可，这样枚举所有区间$\gcd$的复杂度是$O(n \log^2 \max{a_i})$，在枚举过程中可以算出每种$\gcd$有多少个以及询问的$\gcd$是多少。总时间复杂度为$O(n \log^2 \max{a_i} + q)$。

E. Necklace \[Constroy\] \[Skywalkert\] \[braveTester\]
=======================================================

状压dp，设$f(mask1, mask2, i, j)$表示一边点集为$mask1$，一边点集为$mask2$，最后一个枚举的数字是$i$，最后一个数字是不是坏掉了$(j = 0, 1)$的最小代价，初始状态强制拿第一个数，转移时只有$0 \leq |mask1|-|mask2| \leq 1$的状态有效，最后再枚举最后一个点与开头第一个数是否产生代价即可。时间复杂度$O(N^2 2^{N + 1})$。

F. PowMod \[Skywalkert\]
========================

分成两道题来看，给定$n, m$满足$|\mu(n)| = 1$求$\sum_{1 \leq i \leq m}{\varphi(i \cdot n)}\,mod\,(10^9+7)$，以及给定$k,p$求$k^{k^{k^{k^{\cdots^{k}}}}}\,mod\,p$。

第一问就是枚举$i$与$n$的$\gcd$，可以反演得到$\varphi(i \cdot n) = \sum_{d|(n, i)}\varphi(\frac{n}{d})\varphi(i)$，带回原式就是$S(n,m) = \sum_{i = 1}^{m}\sum_{d|(n, i)}\varphi(\frac{n}{d})\varphi(i) = \sum_{d|n}\varphi(\frac{n}{d})\sum_{i = 1}^{\lfloor \frac{m}{d} \rfloor} \varphi(d\cdot i) = \sum_{d|n}\varphi(\frac{n}{d})S(d,\lfloor \frac{m}{d} \rfloor)$，所以可以记忆化搜索来计算答案，在$n = 1$或$m \leq 1$时终止即可，由于$n$最多有8个不同的质因子，而第二维总可以表示成$\lfloor \frac{m}{x} \rfloor$，所以空间大小是$O(2^8 \sqrt{m})$的，时间复杂度最坏是$O(3^8 \sqrt{m})$的，由于第二维的约束，所以时间复杂度达不到这个上界。

第二问就是利用$a^x \equiv a^{{x\,mod\,\varphi(p)} + \varphi(p)}(mod\,p)$，将求解$k,p$的问题变为求解$k, \varphi(p)$的问题，当$p = 1$时问题的解恒为$0$，因此可以递归求解这个问题。当$p$为偶数时$\varphi(p) \leq \frac{p}{2}$，而当$p$为奇数时$\varphi(p)$必为偶数，因此求解的层数是$O(\log p)$的，每层只需要计算快速幂即可。这部分的时间复杂度为$O(\log^2 p)$。

G. Rigid Frameworks \[Skywalkert\]
==================================

一个平面不自交的图是刚体图，当且仅当每条边动的时候所有边都在动。

考虑增加一个对角线，会使得对角线所在行的纵边联动、所在列的横边联动，并且联动的边平行或垂直。

在同一行或同一列的对角线会互相影响，从而多列或多行联动。

一个增加了对角线之后变成刚体图的网格图，必然满足每一行每一列能通过对角线联动到任意行任意列。

把行与列看成是点，两种对角线看成是两种颜色的边，所求就是左边有$n$个点，右边有$m$个点，用两种颜色染色的连通二分图个数。

设$f(i, j)$表示这样的二分图个数，$g(i, j)$则表示可以不联通的这种染色二分图个数。

显然不联通的二分图可以表示成左边1号节点所在连通染色二分图和一个可以不联通的染色二分图，故有$g(i, j) = \sum_{x = 1}^{i} \sum_{y = 0}^{j} {f(x, y) \cdot g(i - x, j - y)}$，而$g(i, j) = 3^{i \cdot j}$，于是可以利用$g(i, j)$来暴力计算$f(i, j)$了。时间复杂度$O(n^2 m^2)$。

H. Shell Necklace \[Skywalkert\] \[Constroy\]
=============================================

所求即$\sum_{k} \sum_{x_1 + x_2 + \cdots + x_k = n} \prod_{i = 1}^{k} {a_{x_i}}$，设这个值为$f(n)$，则可以枚举$x_k$得到$f(n) = \sum_{1 \leq x_k \leq n}{f(n - x_k) \cdot a_{x_k}}$，其中$f(0) = 1$，所以有$f = f * A$，即$f = \frac{1}{1 - A}$，利用多项式求逆或者cdq分治即可计算$f$。时间复杂度分别为$O(n \log n)$和$O(n \log^2 n)$，由于使用的都是FFT，前者有较大常数问题。

I. Solid Dominoes Tilings \[Skywalkert\]
========================================

同本场G题的思考方式相同，枚举一个角的连通情况即可容斥，但本题在两个维度上存在联系，无法像G题一样直接分开做，所以可以$O(2^m)$容斥所有列的情况，对于一种列的情况$O(n^2)$计算满足该种情况的行合法方案数，时间复杂度$O(n^2 2^m)$，感觉也可以直接本地$O(2^{n + m})$打表。

J. Subway \[Skywalkert\] \[braveTester\]
========================================

**Skywalkert:**
两个同构的树拥有相同的质心（重心），找到质心所在的点（或边），枚举可能的匹配情况，将树变为有根树后Hash每棵子树即可判断是否同构，时间复杂度$O(n)$。

注意到Hash子树可能会出现不同构但Hash值相同的情况，可以将子树按照高度排序，相同高度的子树运用有序表进行Hash，有序表的排序类似于后缀排序（传说中的波兰表？），最终的Hash结果会是$[0, n)$之间的值，且与同构的子树构成双射。

**braveTester:** 看不懂唐老师后半段在说什么( ╯□╰ )...

考虑从叶子开始不断修剪树的过程，每次把叶子剪掉，然后又有一些节点变成了叶子，继续剪掉...这样天然将树分了层。对每一层，随机两个整数
$A$ 和 $B$，定义某一结点 $u$ 的 hash 值为
$$A[level(u)] \times (\Sigma_{son\ v}{hash[v]}) + B[level(u)]$$，其中孩子是在刚刚分层的基础上说的。为了防止溢出，我还随机了一个大质数取模。然后选层最深，hash
值最小的点做根，构造解的时候把对应节点的儿子按 hash
值分别排序，就能找到各自儿子的对应节点，剩下的事情递归即可。

K. tetrahedron \[braveTester\] \[Skywalkert\]
=============================================

**Skywalkert:**
公式题。四面体内接球的半径可以用体积除以表面积得到，而内心到四个顶点的距离与对应的表面积成一定比例，将四个顶点的比例加权即可得到内心。时间复杂度$O(1)$。

~~赛后选择了[抄公式](http://maths.ac-noumea.nc/polyhedr/stuff/tetra_sf_.htm)~~

**braveTester:**
内接球半径公式是二维内接圆半径的直接推广，感叹自己真是连个中学生都不如...求内接球球心的另一种方法是将四个面往对应顶点平移内接球半径，然后高斯消元求交点即可（想法来自唐老师）。
