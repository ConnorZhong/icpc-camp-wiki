F. Median on Binary Tree
========================

a-median 等价于把一个序列中最大的 a 个扔掉之后的中位数。假设 $x$ 可做为
a-median，那么就存在一棵包含 $x$ 的子树，使得
$|\{y|y>x\}| - |\{y|y<x\}| = a$。考虑 $x$ 所能达到的最大的
$a_{max}$，及其对应的子树 $T$。由于在树上包含一个点至多会使 $a$ 增加
$1$，因此 $[0, a_{max}]$ 中的所有 a-median 均可达到，所以只需要求出
$a_{max}$ 即可。

令 $f[x][u]$ 表示包含 $u$ 的树，且其所有点在以 $u$ 为根的子树中的
$\max\{|\{y|y>x\}| - |\{y|y<x\}|\}$。设 $u$ 是 $x$ 的祖先，则所有包含
$u$ 和 $x$ 的树且其所有点在以 $u$ 为根的子树中的
$\max\{|\{y|y>x\}| - |\{y|y<x\}|\} = f[x][u] - f[x][v] + \delta$。其中
$v$ 是 $u$ 到 $x$ 的路径上第一个非 $u$ 点，也就是 $u$ 的儿子。$\delta$
是包含 $v$ 到 $x$ 的路径且只由 $v$
的子树中的点所组成的树所能达到的最大贡献。

又注意到如果 $u$ 的子树不含 $x + 1$，那么
$f[x + 1][u] = f[x][u]$，又题目给出了一个完全二叉树，树深
$O(\log n)$，所以每次暴力更新，复杂度为 $O(n\log n)$。

对于更一般的树，需要树链剖分 + 线段树或者 LCT。

G. Card Shuffling
=================

手玩之后会发现 $(1, 2, 3,\dots,n,x)$ 在进行 $2^n$ 步后 $x$ 会向后走
$x - n$ 步。因此只要发现 $1$ 在开头，那么之后所有数减去
$1$，之后每步代价乘 $2$。现在考虑对于任意序列，最多多少步其中的 $1$
会走到开头。

设在任意序列中 $1$ 在第 $i$ 个位置挪到第一个位置所需要的步数有上界
$f(i)$，且前 $i$ 个位置没有 $0$。那么至多有 $i - 3$ 个数小于
$i - 1$，因此前 $i - 1$ 个位置至少有两个数大于等于 $i - 1$，所以前
$i - 2$ 个位置至少有一个数大于等于 $i - 1$。只要这数挪到第一，那么 $1$
会向前挪 $1$ 位。易得这个大于等于 $i - 1$ 的数同样适用 $f$
的估计，因此有 $f(i) \le f(i - 1) + f(i - 2) + 1$。

H. Independent Events
=====================

有 $n$ 个独立事件，每个事件发生的概率是 $p_i$，有两种操作，1 询问区间
$[l, r]$ 事件都不发生的概率，对结果取自然对数，2 将区间 $[l, r]$
事件的概率乘以 $k$。\
由于修改操作是对 $p_i$ 做的，而询问是对 $ln(1-p_i)$
求和，所以不能直接对一个区间的答案做维护。\
对 $ln(1-p_i)$ 在 $x = 0$ 处做泰勒展开得
$ln(1-x) = \sum_i{\frac{x^i}{i}}$。大约计算 10
项就能满足精度。现在可以分别维护 10 个序列 ${x^i}$
的和，修改操作就是乘以 $k ^ i$，求和就是对 10 个序列求和。\
时间复杂度 $O(m * D * logn)$，其中 D 是泰勒展开的项数。
