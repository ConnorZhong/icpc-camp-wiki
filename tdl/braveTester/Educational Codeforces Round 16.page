A. King Moves
=============

手速模拟题。

B. Optimal Point on a Line
==========================

中位数。

C. Magic Odd Square
===================

构造题。根据样例，发现只要中心十字上是奇数，剩下四个象限的一组 4
个对称点保持奇偶性一致即可。因此先用奇数填满中心十字，然后把剩下的数分奇偶放进两个队列，每次找到一个没填数的格子从有数的队列里取出四个填到对应的一组对称点中即可。

D. Two Arithmetic Progressions
==============================

E. Generate a String
====================

算是比较神奇的
DP。考虑两个翻倍之间的情况，显然要么没有，要么全是加，要么全是减。如果加/减操作超过两个，因为假设了是在两个翻倍之间，因此总可以把这个操作挪到翻倍前，从而减少代价（代价都是正的。）。因此加减操作至多只有
1。

从底下加一以及从下面翻倍很好处理，麻烦的是如何处理减一，因为这会破坏拓扑序。显然减一只会发生在翻倍之后，适用之前结论，由此得出减一的情况一定是先翻倍再减一，这个时候就保持了从小到大的拓扑序。

按照上述讨论直接 DP 即可，复杂度 $O(n)$。

F. String Set Queries
=====================

神奇的静态数据结构添个 $\log$ 变在线（据说是通用方法。）。

要求维护一个字符串集合，要求可以增添、删除字符串，其中增添的字符串保证之前从未增添过。另外需要处理查询操作，给定一个上下文，要求输出字符串集合中所有串在其中出现的次数和。强制在线。操作次数以及输入的所有字符串总长度均不超过
$3 \times 10^5$。

AC
自动机只能在给定所有模板串之后构造，通过在适当时机暴力重构可以得到一个优雅的做法。把字符串集合任意划分，保证最后划分的集合大小都是
2 的不同次幂（即把串个数 $S$ 二进制分解），对每个集合构造一个 AC
自动机。对于新加进来的一个串，$S$ 会变为 $S + 1$，将 $S$ 与 $S + 1$
所有不同的位代表的自动机销毁，将其中包含的串及新串放入 $S + 1$ 的最低位
$1$ 代表的自动机（正常建造即可。）。显而易见，每个串最多跨越 $O(\log)$
个自动机，所以最后复杂度会乘个 $O(\log)$，然后这题就做完了
(..•˘\_˘•..)。

**\[过后内心 OS\]** 交完看别人内存小的 1b 点开发现人家用了
set&lt;int&gt; + hash...（╯\#-皿-)╯\~\~╧═╧。（虽然 get
到了特别的使用技巧也算不虚此行了。）
