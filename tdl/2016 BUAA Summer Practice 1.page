A. 翻转游戏 \[Skywalkert\]
==========================

设$f(i,j)$表示$(i,j)$被翻的次数，则根据$f(i, j) \oplus f(i - 1, j) \oplus f(i, j - 1) \oplus f(i, j + 1) \oplus f(i + 1, j) \oplus a(i, j) = 0$可以发现，第一行之外的变量都可以表示成第一行$M$个变量的线性组合，现在有$(M + K)$个限制，即给出的$K$个格子和第$(N + 1)$行的每个格子都不能被翻，根据这些条件解方程即可，需要压位。时间复杂度$O((N+M+K)\frac{M^2}{64})$。

B. Three Palindromes \[Skywalkert\]
===================================

三段回文串必然是一段前缀、一段后缀、一段中间串，利用manacher预处理回文信息，枚举中间串的回文中心，需要检查一些对应的前缀与后缀是否能组成回文串，需要压位，支持位移和求最左1的操作。时间复杂度$O(\frac{|S|^2}{64})$。

C. Duff in the Army \[Constroy\] \[Skywalkert\]
===============================================

每个点只需要存前10小的信息，不难想到利用倍增预处理信息，求lca的同时得到答案。时间复杂度$O(m + 10(n+q) \log n)$。

D. Ruminations on Ruminants \[Skywalkert\]
==========================================

遇到过定点的圆就强行圆反演一下，一个三元组$(i,j,k)$是合法的，当且仅当原点到三条直线的垂足共线。

预处理每条直线的垂足，枚举$i$，极角排序其他点，从而统计$(j,k)$的数量。时间复杂度$O(n^2 \log n)$。

E. Binary Table \[Skywalkert\]
==============================

考虑枚举行翻转的状态$S$，对应列的状态将从$T$变为$S \oplus T$或是$U - (S \oplus T)$，设$popcount(x)$表示$x$的二进制1个数，产生的贡献将是$\min(popcount(S \oplus T), n - popcount(S \oplus T))$，即$f(S)=\sum_{i=1}^{m}{\min(popcount(S \oplus col_i), n - popcount(S \oplus col_i))}$。

设$g(T)=\sum_{i=1}^{m}{[col_i=T]}, h(S \oplus T) = \min(popcount(S \oplus T), n - popcount(S \oplus T)$，则有$f(S) = \sum{g(T)\cdot h(S \oplus T)}$，也即$f(S \oplus T)=\sum{g(T) \cdot h(S)}$，利用快速沃尔什变换（或者说是分治乘法）计算即可。时间复杂度$O(n 2^n)$。

F. Bears and Juice \[Skywalkert\]
=================================

~~装作~~只会暴力

考虑dp的过程，发现可以矩阵加速，然而全部用矩阵反而会变慢，设使用矩阵的步长为$T$，则复杂度为$O(p^3 + p^2 T + p^3 (\log T + \frac{q}{T}) + p q)$，故$T$取不小于$\sqrt{p q}$的正2次幂即可。时间复杂度$O(p^{2.5} q^{0.5} + p q)$。

G. Chain Reaction \[Skywalkert\]
================================

由于每个点只能向一个方向运动，所以目标状态是有限界的，二分答案，枚举每个点的方向，每个点最终的相对位置，可以得到正方形四条边的上下界，构造最小可行解检查即可。时间复杂度$O(4^4 \cdot 4! \log V)$。

H. D Game \[Skywalkert\]
========================

删的等差数列一定可以拆成许多长度为$2$或$3$的等差数列，这基于$2x + 3y$能表示$\leq (2 - 1) (3 - 1)$的所有正整数。

因此对每个区间求完成该区间删除操作时最多删多少个数即可。时间复杂度$O(N^3)$。

I. Zip-line \[Constroy\] \[Skywalkert\]
=======================================

计算包含某个数字的最长上升子序列长度，可以分别计算以其开头和结尾的最长上升子序列长度，每次计算就是维护一个单调栈，并在栈上进行二分。

考虑被更改的数字是不是存在于唯一的最长上升子序列中即可知道新数产生的最长上升子序列对答案的影响，因此也可知道答案的变化最多为1。时间复杂度$O((n+m)\log n)$。

J. Table Compression \[Constroy\] \[Skywalkert\]
================================================

先处理相等的关系，缩点后按照偏序关系建边，最后求一个拓扑序即可。时间复杂度$O(n m)$。

K. Looksery Party \[Constroy\] \[Skywalkert\]
=============================================

构造即可，每次选择一个可能对自己不利的点扩展，如果扩展到最后仍对自己不利，则必然不利。时间复杂度$O(n^2)$。

L. The Game of Parity \[Skywalkert\]
====================================

裸题，分类讨论谁走最后一步以及要怎么决策即可，分支较多。时间复杂度$O(n)$。
