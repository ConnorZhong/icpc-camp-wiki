[AGC002 D](http://agc002.contest.atcoder.jp/tasks/agc002_d)
===========================================================

题意：n点m边的有向无环图，q个询问x, y, z，从x 和y
同时出发一共探索z个点，使经过的最大号边的标号最小，输出这个标号。\
题解：比赛的时候想到的是对每个询问二分答案，但是又不能每次都做一遍并查集，所以就搞了一个带历史的并查集。没有路径压缩于是T了，加上按size合并才过。\
正解是对所有询问一起二分。维护每个询问的上下界。每次算出中间值，做并查集的时候更新边标号对应的询问的答案。显然总共二分O(log(m))次，每次O(q
+ n + m)。

[CF \#377(Div.2) F](http://codeforces.com/contest/732/problem/F)
================================================================

题意：给一个没有重边和自环的无向连通图，给它的边定向，使得后继（所有可达点）最少的点的后继最多。\
题解：先缩一个边双，边双内部都可以搞成SCC。然后边双之间构成了一棵树，定向之后肯定是一个DAG，DAG至少有一个终点。\
显然可以构造一个DAG使得树根为唯一终点，其它点后继都包含树根。于是贪心地选取最大的点双为树根即可。\
不是很会根据点双构造SCC，参照了找环的写法。dfs路径上的点标记为-1，dfs完成的点标记为+1，其余点标记为0。\
删除当前点 u 到父亲 f 的单向边。遇到标记+1的邻接 v，说明 v 已经是 u
后继， 删除 u 到 v 的单向边，使之能构成环。

[CCPC online J](http://acm.hdu.edu.cn/showproblem.php?pid=5841)
===============================================================

题意：给一棵带点权的有根树，每次询问在一棵子树中进行如下博弈的结果：Alice
先选一个点，Bob 在此局面下再选另一个点。Alice
要使两数的异或值最大，Bob要使其最小。\
题解：之前只会在 01
字典树中查询与给定值异或值最小。而字典树可以维护树中这个博弈的结果。每个节点可以维护这个节点以下的数位的博弈答案。\
一个节点的 size 小于 2，那么不能进行博弈，答案为 -1。\
Alice 在一个非叶子节点走左儿子，如果左儿子 size 为 1，那么 Bob
只能走右儿子，将左儿子的数拿到右边查询。否则，Bob
肯定也走左儿子，直接用左儿子的答案更新当前点。\
Alice 走右儿子的情况类似。每次更新的复杂度至多为两次次查询
$O(log(w))$。\
原树上一个节点的字典树是它的儿子的字典树的并，再加入自己。字典树与线段树一样，总的合并复杂度是
$O(nlogn)$。
