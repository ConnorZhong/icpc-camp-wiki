A. Lobby \[braveTester\]
========================

签到模拟题。没注意人一开始就多了的情况然后会输出负数...WA 了一发。

B. Cameras \[braveTester\]
==========================

签到模拟题。根据规则之间判断就好。

C. Robot
========

Skywalkert 说我们可以 bfs ！

braveTester 发现只需要搞出点双就可以做这道题了！

然后鸽置。

D. Laser Game
=============

E. Billboard \[Skywalkert\]
===========================

枚举列区间转化成一维问题，问题是选择一个最长的区间使得区间里忽略最大 $r$
个数后数字之和不超过 $s$。

用 two pointer 枚举区间，利用线段树维护区间里忽略最大 $r$
个数后数字之和即可卡时通过，时间复杂度 $O(n^2 m \log m)$。

F. Funfair \[Skywalkert\]
=========================

对于游戏 $G_i$，输入 $x$ 将得到输出
$(1 - L_i\%(1 - P_i\%)) x + P_i\%A_i$，形如 $k_i x + b_i$。

所以猜测存在最优顺序，考虑交换相邻两个游戏
$G_i, G_j$，发现不交换的条件是 $b_i (1 - k_j) \leq b_j (1 - k_i)$。

在最优顺序上 dp 即可，时间复杂度 $O(nm)$。

G. Beehive \[Skywalkert\]
=========================

给每个格子标一个坐标 $(x, y)$，表示从1号格子到这个格子要向左上方走 $x$
格，向右上方走 $y$ 格。

可以发现向左上方走 $k$ 格且向右上方走 $k$ 格等价于向上方走 $k$ 格。

根据标号规律预处理出每个格子的坐标。对于询问，得到坐标差之后，尽量用竖直方向的走法来代替斜方向的走法即可。

H. DNA Sequencing \[braveTester\]
=================================

用 Tire
来考虑问题，单词结点到根的每个结点都是可以通过擦除操作到达的，显然擦除后缀后
Tire 上到根路径长度大于等于 $M$ 的节点个数就是答案。

如果一个单词结点到根的路径上有两个结点可以选择，并且深的那个没选，那么把浅的换成深的答案不会变得更差。由此可以得到最优解的结构为从深度最深的结点开始枚举，能选就选。

这个类似 BFS 的思路也可以用 DFS 来实现，复杂度
$O(total\ length\ of\ input)$。

I. Cafebazaar \[Skywalkert\]
============================

首先扩充成完全二分图，对于图上没有的边，如果端点都不是必选的，那么边权为
0 ，否则边权为一个极小值。

注意为了使得两边的必选点都在匹配中，点集较小的那边要补充一些孤点来使得两边点集大小相等。

然后跑 KM 就好了，最大完美匹配的权值和为正表示有解。

J. Fence \[Skywalkert\]
=======================

答案是类似凸包的东西，跑出凸包之后确定每种边的使用情况即可。

Summary
=======

**Skywalkert:** 思考题目的效率还需要提高。有些编程上的小 bug
需要注意。好好补基础。

**braveTester:** 这场状态感觉还不错，上了 A、B、H 三道签到题（其中 A
因为没考虑全还 WA 了一发），嘴巴过了 C，瞎蒙过了
J。技能点差的还是很多啊...图论不会写，凸包不会快速的写，还是需要多多学习一个。
