A. Almost Bobo Number \[Skywalkert\]
====================================

容易知道最小的 Almost Bobo Number(简称 ABN) 为 $1010$。又设原串长度为
$d$，则长度为 $d - 1$ 的最大 ABN 为
$\underbrace{99\cdots9}_{d - 4}898$。

因此现在只需要考虑寻找长度为 $d$ 的 ABN。最大的 ABN
的形式一定是与给定的数 $N$ 具有最长的 LCP，所以考虑枚举 LCP
长度。设枚举的 LCP 长度是 $l$，得到的压缩串为 $\text{comp}(l)$，则必有
ABN 的第 $l + 1$ 位小于 $N_{l + 1}$。现在需要判定是否存在一个满足限制的
ABN。分两种情况讨论：

1.  ABN 的压缩形式为 $(\text{comp}(l)\cdot u)^2$。
2.  ABN 的压缩形式为 $(xu)^2$，其中
    $\text{comp}(l) = x \cdot u \cdot x$。

对于第一种情况，如果 $\text{comp}(l)$ 的首字母小于 $N_{l + 1}$，则
$N_{1\cdots l}\cdot \text{comp}(l) \cdot \underbrace{\text{comp}(l)_1\cdots\text{comp}(l)_1}_{\text{长度可为 0}}$
为一个可行解；如果 $\text{comp}(l)$ 末字母小于 $N_{l + 1}$，则
$N_{1\cdots l}\cdot \text{comp}(l) \cdot \underbrace{\text{comp}(l)_1\cdots\text{comp}(l)_1}_{\text{长度可为 0}}$
为一个可行解；另外还有一种通行的解是
$N_{1\cdots l}\cdot 0 \cdot \text{comp}(l) \cdot \underbrace{0\cdots 0}_{至少为 1}$。

对于第二种情况，则需要找到一个可能的 $u$。如果 ABN 的第 $l + 1$ 位是 $x$
的一部分，则有 $N_l < N_{l + 1}$，这样只需要找到长度最短的 $u$
即可；如果 ABN 的第 $l + 1$ 位是 $u$ 的一部分，则有
$u_1 < N_{l + 1}$，对于 $i < N_{l + 1}$ 只需要找到
$S_{\text{comp}(l)}(i) = \{u | u_1 = i\}$
集合中长度最短的即可，这个集合的长度最小值可以 DP 维护，转移 $O(10)$。

总体复杂度是 $O(10n)$。

上述过程的本质其实都枚举了 LCP
后的第一个位置，因此直接枚举可以把所有情况合成第二种情况的第二种子情况，复杂度还是
$O(10n)$。

------------------------------------------------------------------------

为了保证答案尽量大，答案串和原串的公共前缀应该是尽量长的，假设枚举了第一个答案串小于原串的位置（并且不是前导
0 ），如果这一部分的压缩串只有 1 个字符，那么至少还需要添加 3
个字符才能满足条件，否则一定可以写成 $S' = xyx$ 的形式，其中
$|xy| \geq 2$ ，因此只需要使得 $y$
尽量短即可确定是否存在解，如果能计算出一个串的 kmp
失配位置不超过一半长度的，就可以添加一个长度不超过 $S'$ 的 $y$
，这种情况一定比添加 $|S'| + 2$ 个字符的优。如果非要产生前导 0
才能找到解，那么已经可以构造出最短解了。

尝试动态维护 $next(i, c)$ 表示在当前串的位置 $i$ 之后加一个字符 $c$
后最近匹配位置（该位置不超过 $i$ ），需要支持 $O(|\sum|)$
为当前串末尾添加一个字符， $O(1)$
删除当前串末尾的字符，这其实是很简单的，顺带就可以维护 $i$
位置的最近失配位置和不超过一半的最近失配位置，这正是所需要的，注意这里的后者可以通过
$next$ 做到 $O(1)$ 计算，而不是 $O(|\sum|)$ 。

枚举答案串与原串第一个不同的位置 $i$ ，将原串位置 $i$
之前的字符对应的压缩串都添加到动态维护的串里，降序枚举第 $i$
个位置加的是什么字符 $c$ ，用 $next(j, c) (j < i)$
可以很快计算出不超过一半的最近失配位置，如果可以产生一个满足条件的串，则固定这一位的取值，之后也是类似的降序枚举每一位加什么字符即可，这样避免了最短解不等于最优解的讨论，复杂度
$O(|S| |\sum|)$ 。

B. Connected Spanning Subgraph \[braveTester\]
==============================================

参考 Day1 C. City United
做法，模型转化后等价于求将点黑白染色，再选一个边集 $E$
满足其中所连的两点要同色的方案数：

$$
\begin{align}
&\sum_{C, E}{[\forall \{u, v\} \in E, \text{color}(u) = \text{color}(v)]}\\
=&\sum_{C}\sum_{E}[\forall \{u, v\} \in E, \text{color}(u) = \text{color}(v)]\\
=&\sum_{C}2^{\sum_{e}{[\text{color}(u) = \text{color}(v)]}}\\
=&\sum_{\{C, \neg C\}}2\times 2^{\sum_{e}{[\text{color}(u) = \text{color}(v)]}}
\end{align}
$$

所以只要有同色边，那么对答案就不会有贡献。对于可以对点集染色使得没有同色边的图，即为二分图。又由题目保证联通，所以只要是个联通二分图，答案就为
$1$，否则为 $0$。

C. Power of Power Partition Function \[Skywalkert\]
===================================================

**生成函数**

令 $B_m(x) = \sum_{i = 0}^{\infty}{b_m(i)x^i}$，则容易由组合意义得到：

$$
\begin{align}
B(x) &= \prod_{i = 0}^{\infty}\sum_{j = 0}^{\infty}x^{jm^i}\\
&= \prod_{i = 0}^{\infty}\frac{1}{1 - x^{m^i}}。
\end{align}
$$

由题意定义 $C_m^k = C_m^{k - 1}B_m$ ，其中 $C_m^0 = B_m$。易得

$$
C_m^k(x) = (B(x))^k = \prod_{i = 0}^{\infty}{\frac{1}{(1 - x^{m^i})^k}}。
$$

题目中实际要求的是
$\left(C_m^k\times\frac{1}{1 - x}\right)[x^n]$。假设已知已经得到了
$P_m^t(x) = \prod_{i = 0}^{t}{\frac{1}{(1 - x^{m^i})^k}}$，考虑乘上下一个因子的系数：

$$
\begin{align}
\left(P_m^t(x)\frac{1}{1 - x^{m^i}}\right)[x^n] &= \sum_{n - jm^i \ge 0}P_m^t[x^{n - jm^i}]\\
&= \sum_{jm^i + r \le n}P_m^t[x^{jm^i + r}]\\
&= \sum_{(jm + q) m^{i - 1} + r' \le n}P_m^t[x^{(jm + q) m^{i - 1} + r'}]。
\end{align}
$$

其中 $r$ 为 $n$ 对 $m^i$ 的最小非负剩余，$r'$ 为 $r$ 对 $m^{i - 1}$
的最小非负剩余，$r = qm^{i - 1} + r'$。假设 $k = 1$，尝试手算前几项，有

$$
\begin{align}
P_m^1[x^n] &= 1\\
P_m^2[x^{jm + r}] &= j + 1\\
P_m^3[x^{jm^2 + r}] &= \sum_{k = 0}^{j}km + q + 1\\
&= m\frac{j(j + 1)}{2} + qj + j\\
&= \frac{m}{2}j^2 + (\frac{m}{2} + q + 1)j。
\end{align}
$$

由上述观察及数学归纳法可以证出，对于任意
$P_m^t[x^{jm^t + r}] \in \text{Poly}_{tk - 1}(j, q)$。假设已知
$P_m^{t - 1}[x^{jm^{t - 1} + r'}]$，通过 $tk$ 次多项式求值再 $O(tk)$
插值出多项式即可实现乘上一个因式的转移。易得涉及到的不同多项式只有
$O(k \log_m n)$ 个，度数为
$O(k \log_m n)$，插值一次多项式的复杂度是度数平方，因此总复杂度为
$O((k \log_m n)^3)$。

多项式插值细节：对于一个度数为 $m$ 的多项式 $F(x)$ ，有
$\displaystyle F(n) = \sum_{i = 0}^{m}{(-1)^{m - i} \binom{n - i - 1}{m - i} \binom{n}{i} F(i)} = \sum_{i = 0}^{m}{\frac{(-1)^{m - i}}{i! (m - i)!} F(i) \prod_{0 \leq j \leq m, j \neq i}{n - j}}$
，为了在 $O(m)$ 的时间内从 $F(i) (i = 0, 1, \cdots, m)$ 转化到 $F(n)$
，需要预处理阶乘逆元和 $n - j$ 的前缀积、后缀积 $(j = 0, 1, \cdots, m)$
。

------------------------------------------------------------------------

**Abel 变换**

同上，也需要进行生成函数层级的卷积换序，本质是将点积表示成差分的和分（选择合适的差分算子），得到易于计算的式子。

D. Line Counting \[Skywalkert\]
===============================

推导比出题人的麻烦许多，分斜率为 0 、斜率不存在、斜率为负、斜率小于 1
、斜率不小于 1 五种情况讨论，其中斜率为负、斜率小于 1 、斜率大于 1
的情况其实贡献了相似的系数，为了使得每条线不被枚举多次，每次枚举直线上的两个点，并使得不存在第三个点同时属于点阵和该直线还在第一个点之前，这样可以枚举出所有可能的方案，最终合并一些余项可以得到答案是
$\displaystyle 3 \sum_{i \geq 1} {\varphi(i) (\binom{n + 1 - i}{2} - \binom{n + 1 - 2i}{2})}$
。

为了计算上述令人头疼的式子，需要先证明一些内容：

$\displaystyle \sum_{d | n}{d^k \varphi(d) (\frac{n}{d})^k} = n^k \sum_{d | n}{\varphi(d)} = n^{k + 1}$

$\displaystyle F(n) = \sum_{d | n}{G(d) H(\frac{n}{d})} = \sum_{i j = n}{G(i) H(j)} \\ \Rightarrow \sum_{i = 1}^{n}{F(n)} = \sum_{i = 1}^{n}{\sum_{j k = i}{G(j) H(k)}} = \sum_{1 \leq j k \leq n}{G(j) H(k)} = \sum_{j = 1}^{n} {G(j) \sum_{k = 1}^{\left \lfloor \frac{n}{j} \right \rfloor}{H(k)}} \\ \Rightarrow \sum_{i = 1}^{n}{H(i)} = \sum_{i = 1}^{n}{F(n)} - \sum_{j = 2}^{n} {G(j) \sum_{k = 1}^{\left \lfloor \frac{n}{j} \right \rfloor}{H(k)}}$

所以做法是，将两个组合数分开计算（因为 $i$
取值范围不同），每个组合数再拆成关于 $i$ 的多项式，对于每个 $i$ 的幂次
$i^k$ 计算 $i^k \varphi(i)$ 的前缀和，令
$F(n) = n^{k + 1}, G(n) = n^k, H(n) = n^k \varphi(n)$ ，由于
$\left \lfloor \frac{n}{j} \right \rfloor$ 只有 $O(\sqrt{n})$
种取值，维护出所有可能的取值 $t$ ，尝试升序计算
$\sum_{i = 1}^{t} {H(i)}$ ，注意到 $F(n), G(n)$
的前缀和可以利用公式或拉格朗日插值 $O(k)$ 计算，所以整体的复杂度为
$O(k^2 n^{\frac{3}{4}})$ ，采用预处理的技巧可以做到
$O(k^2 n^{\frac{2}{3}})$ 。

E. Maximum Flow \[Constroy\]
============================

平面图最大流，可以转换成对偶图最短路，由于图的特殊性，打牌就能得到最短路。

F. Rectangles Inside Rectangle \[Constroy\]
===========================================

G. Cute Panda \[braveTester\]
=============================

H. Order-Preserving Partition \[Skywalkert\]
============================================

根据排列 $Q$ 的形式分几类情况讨论解决。

对于单调的排列，转换成 `1234` 的形式，统计有多少个位置 $i$ 满足
$p_1, p_2, \cdots, p_i$ 包含 $1$ 且在值域上只有一个区段，如果有 $k$
个这样的位置，则答案是 $\binom{k - 1}{3}$ 。

对于前两个元素之差为 2
的排列，最大值和最小值分别在中轴的两边，考虑计算出前缀、后缀满足排列中某两个位置的方案，然后枚举中轴即可统计答案。以
`31` 匹配前缀为例，用并查集维护 $p_1, p_2, \cdots, p_i$
在值域上每个区段，并在每个区段上记录元素在 $P$
中出现的最早、最晚位置，视为一个区间，如果恰好有两个区段，且区段对应的位置区间互不相交，且与
$P$ 从大小、位置关系上匹配，且包含 1 ，那么位置 $i$ 的右侧可以作为中轴。

剩下的情况中 1 和 4
至少有一个在排列的中间两个位置，不妨通过对称、取反的形式将排列化为
`XX12` 或 `XX14` 。

如果现在是 `XX14` 的形式，先预处理出 `4` 部分包含 $n$
且在值域上只有一个区段的可行左端点，并利用前缀最值相等的性质配合区段数量计算出
`XX` 部分能否以某个位置做右端点 ，然后枚举 `1` 对应的实际区段统计答案。

对于 `XX12` 的形式，则只需要预处理出 `XX` 部分的情况再枚举 `1`
即可统计。

为了时间复杂度 $O(n)$ 欲仙欲死，结果还是写了 $O(n \alpha(n))$ 。

I. Prime Tree \[Skywalkert\]
============================

假设已知一个因式树的大小 $d (d | n)$ ，则可以通过树 DP
将整棵树唯一划分成 $\frac{n}{d}$
个部分，每个部分的根节点将会是提取因式树后剩下的节点，因此它们必须在原树上是一个连通块，此外每棵树应该同构，利用这三条性质即可判定一个
$d$ 是否可行，并在可行时生成出提取方案。

对于判断树同构问题，我的选择是求出括号序列的 hash
值进行比较，每个节点的后继节点顺序也是由 hash
值决定的，此外进制选择成模数的原根时效果比较好。

J. Hamiltonian K-vertex Connected Graph \[Constroy\]
====================================================

构造一个 n 个点的 m
连通度哈密顿图。连通度是指使图不连通需要删除的最小点集的大小。\
首先要满足连通度 m， 只需要每个点的度数达到 k 即可（反证法可以证明）。\
把点排成一个环，$0~n-1$ 标号，对于每一个 $k < m$， 点 $i$ 向点
$(i + k) \mod n$ 连边。每次点度数会增加2，直到度数足够。\
如果 m 是奇数，最后一轮取 $k = \lfloor\frac{n}{2}\rfloor$，
只找出度数不够的点 $i$ 向点 $(i + k) \mod n$ 连边。\
当 $m > 1$ 时这个图含有哈密顿环 1, 2, ... n, 1，否则无解。
