A. Even Three is Odd
====================

标程做法
--------

令 $W[i][j][k]$ 表示已经确定了前 $i + j$ 个数，且满足
$a_{i + j} = \max\{a_{i}, a_{i + 1}, a_{i + 2}\}$ 以及
$\max\{a_k|k<i + j\} < a_{i + j}$
的所有方案集合。上面限制条件的直观意义是 $a_{i + j}$
为第一个出现的最大值。令 $$
f[i][j][k] = \sum_{\{a_n\}\in W[i][j][k]}{\left(\prod_{m = 1}^{i}{w(\max\{a_m, a_{m + 1}, a_{m + 2}\})}\right)}
$$ 现在考虑如何从 $f[i][j][k]$ 转移到
$f[i + 1][j'][k']$。稍加枚举一下会发现有 3
种情况，这三种情况以及其对应的 $i + 1$ 的 $j'$ 可能位置如下：

1.  $= k, [\le k], [\le k], [?]$
2.  $< k, [= k], \le k, [?]$
3.  $< k, < k, [= k], [?]$

对于后两种情况，如果 $a_{i + 3}$ 为最大值，则由状态定义必有
$k < k'$，$W[i][j][k]$ 会对 $f[i + 1][j' = 2][k']$ 贡献
$a = k^{0/1}w(k')f[i][j][k]$；如果 $a_{i + j}$ 仍然是最大值，则
$W[i][j][k]$ 会对 $f[i + 1][j' = j - 1][k' = k]$ 贡献
$b = w(k')f[i][j][k]$。

对于第一种情况，如果 $k' \le k$ 为最大值，则 $W[i][j][k]$ 会对
$f[i + 1][j'][k']$ 贡献 $c = (k' - 1)^{0/1/2}w(k')f[i][j][k]$。如果
$a_{i + 3} = k' > k$ 为最大值，则 $W[i][j][k]$ 会对
$f[i + 1][j' = 2][k']$ 贡献 $d = k^{2}w(k')f[i][j][k]$。

$w(k')$ 只要转移到 $k'$ 都有这一项，可以暂时不乘。在此基础上，$a$ 和 $d$
会对一段后缀 $k'$ 的 $f$ 做相同贡献；$b$ 会对一个单独的 $k'$
做贡献；一段后缀 $k$ 对某 $k'$ 的 $c$ 贡献都含有共同因子
$(k' - 1)^{0/1/2}$，剩下因子变为一段后缀和。

由上述观察得出一种易于实现的写法。用差分数组维护 $i$ 对 $i + 1$ 的 $a$
和 $d$ 贡献，$b$
贡献直接加到相应状态，当要算出某个状态的具体答案时，再得到前序可能状态的后缀和因子，继而算出前序状态对该状态的所有
$c$ 贡献。

由于对于 $a$，$c$，$d$ 贡献均是得到了所有信息后再询问，因此总体复杂度
$O(n^2)$。

CLJ 做法
--------

C. City United
==============

令 $S$ 为一个点集，$G(S)$ 为 $S$ 的诱导子图，$C(S)$ 为 $G(S)$
中联通块的个数，则 $$
\left(\sum_{S \subset \{1,\cdots,n\}}{2^{C(S) - 1}}\right) \mod{2}
$$ 即为答案。变换一下得到答案的 2 倍为 $$
\left(\sum_{S \subset \{1,\cdots,n\}}{2^{C(S)}}\right) \mod{4}。
$$ 该式的组合意义为对所有 $S$，求 $G(S)$
中的联通块黑白染色方案数之和。把不在 $S$
中的点染成灰色之后，可以得到该式的另一种计算方法，即对 $G$
中点染黑白灰三种颜色，且黑白点不能相邻。

按上述方法 DP，复杂度为 $O(3^{14}n)$。

从前往后递推根据是否为 0 剪枝可肉眼可见的提升速度。

E. Lowest Common Ancestor
=========================

树链剖分
--------

首先考虑链上做法。按标号从小到大插入点，当插入点 $x$ 时，满足
$\text{depth}(y) < \text{depth}(x)$ 的已插入点 $y$ 会对答案贡献
$w(y)$；满足 $\text{depth}(y) > \text{depth}(x)$ 的点 $y$ 会对答案贡献
$w(x)$。因此只需要分别维护已插入点数以及插入点的点权对下标的前缀和即可。

考虑树链剖分。重链上的点同链上做法相同。轻边连接的子树上的点对于当前访问的重链来说，对答案的贡献等同于其在重链上对应的点。

注意在不同重链上计算答案时不要重复考虑已经在之前重链上考虑过的点即可。

维护两个前缀和用树状数组的话复杂度为 $O(n \log^2 n)$。

CDQ 分治
--------

每次对区间 $[l, r]$ 二分成两部分 $L := [l, mid]$ 和
$R := [mid + 1, r]$。考虑 $L$ 对 $R$ 的 $f$ 函数贡献。

如果复杂度可以做到 $O(r - l)$，那么每层复杂度为 $O(n)$，总复杂度为
$O(n \log n)$。

在树上通过一遍 DFS 可以得到每个点的子树里 $L$ 中点的个数，再通过一遍 DFS
从上到下可以得到如果一个点是 $R$ 中的点，$L$ 对该点 $f$
函数的贡献。这个做法直接做是 $O(n)$ 的，不满足要求。

但是注意到，只有集合 $\text{lca}([l, r] \times [l, r])$ 的权 $w$ 才会对
$R$ 的 $f$ 函数产生贡献。因此可以建出一棵只由
$\text{lca}([l,r] \times [l,r])$ 构成的树，称为“虚树”，再来搞事。由
Tarjan 算法流程，可以得知这棵树的大小为 $O(r - l)$，满足要求。

具体怎么建虚树呢？按 DFS 序排序，模拟 Tarjan
的算法，用已经确定存在的虚点维护栈序列。如果当前处理的点 $x$ 与栈顶的
$\text{lca}$
不在栈序列中，说明是一个新的虚点，弹栈之后加入即可；否则直接弹栈再加入
$x$。

那么又如何快速找任意两点间的 $\text{lca}$ 呢？化为 RMQ 之后通过 ST
表可以做到 $O(n \log n)$ 预处理，$O(1)$ 查询。

G. Matrix Recurrence
====================

并查集
------

用带权并查集维护一个点 $i$ 到其父亲 $\text{fa}(i)$ 的矩阵乘积 $$
\prod_{j = i}^{\text{fa}(i) - 1}{M_j}。
$$ 复杂度 $O(\alpha(n) \times m^3)$。

特别技巧
--------

题目等于要求抽象一种只支持前端弹出后端插入的双端队列，同时支持计算整个队列的矩阵乘积。

用一个栈 $S$ 和一个辅助矩阵 $D$
来支持整个结构。设整个双端队列表示的矩阵乘积为 $$
\prod_{i = l}^{r} M_i，
$$ 同时有一个辅助值 $l \le mid \le r$，其中 $S$ 存储 $$
\text{Suff}(i) = \prod_{j = i}^{mid - 1} M_j，i \in [l, mid - 1)。
$$ $D$ 的定义为 $\prod_{i = mid}^{r}{M_i}$。

对于后端插入 $r + 1$，直接令 $D := D\times M_{r + 1}$。

对于前端弹出，有两种情况。

第一，$S$ 不空，则直接弹出即可。

第二，$S$ 为空，则清空整个队列，用线性时间重建 $S$，同时 $C := I$。

这样每个矩阵至多会在 $D$ 中被乘一次，在某次重建 $S$
时被乘一次。所以总体复杂度 $O(nm^3)$。
