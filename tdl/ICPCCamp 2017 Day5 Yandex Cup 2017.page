C. Circular Shift
=================

给一个字符串 s，子串 $t = t_{1}t_{2}...t_{m}$ 是一个 good string 当字串
$t' = t_{2}...t_{m}t_{1}$ 也是 s 的一个子串。统计 s 中 good string
的个数。\
优雅的做法是后缀自动机，用后缀数组也可以搞出来。\
对于每一个后缀 s\_i， 这个后缀作为子串 t' 枚举前面加上字母 x
后构成的新子串 t 的个数，首先当前子串 t' 的长度要超过 $s_i$ 与 $s_{i-1}$
的 lcp，以避免重复计数。 然后，要保证新的 t 确实是 s 的子串，把新的后缀
x|s\_i 在后缀数组里做二分查找，找到第一个大于等于它的后缀，然后算出去掉
x 后的 lcp，t 的长度不超过这个 lcp 长度加一。统计这个长度区间里 x
出现的次数就是 t' 的个数。 二分查找和 lcp 的方法有些 tricky，
详细参考代码。

D. Frogs
========

一排 n 个石子，每个石子上有一只青蛙，青蛙 $i$ 会跳到石子 $p_i$($p_i$
是一个排列，可能会有不动点)，现在已知相邻两个石子之间经过的青蛙数量，构造一种跳的方式。\
显然对于每个区间经过的青蛙数必然是偶数，即左右方向的各一半。那么可以左右各扫一遍确定两个方向跳的青蛙。\
遇到一个青蛙就加入队列，当需要填满某个区间时就让队列里的青蛙来跳，如果青蛙数太多，就让一个青蛙停在当前石子（如果空闲），其余的直接扔回原处不用，如果青蛙数不够，就无解。最后再检查一遍这样构造的解是否合法。

E. HDRF
=======

一棵带点权的有根树，点 $i$ 的权 $r_i$ 是以 $i$ 为根的子树的优先级 $v_i$
的最小值，重复一下操作：\
1. 从根开始\
2. 选择当前点权最小的直接儿子\
3. 到达这个儿子\
4. 如果当前点是叶子，记录并删除它，否则转到 2\
这显然是个递归的过程。用 DFS
序线段树维护每个子树的权值，每次递归进入权值最小的子孙搞，所有子孙搞完了就删除当前节点。
