A. Hacker Cups and Balls
========================

给一个 1\~n 的排列，m 个操作 (L, R)。 每次操作将区间 \[L, R\]
的数按升序或降序排列。求最后中间位置的数是几。\
只要求中间位置的数，可以二分这个数
k（排序只用到大小关系，与具体数值无关）。\
记小于等于 k 的数为 0, 大于 k 的数为 1。排序操作就是把一个区间里的 0 和
1 的个数求出来分别放到两个子区间里。\
这个操作可以用一棵支持区间求和、区间赋值的线段树实现。注意一个区间里可能没有
0 或者没有 1。\
最后中间位置是 0 或 1 就表明了当前 k 和答案之间的大小关系。

G. Dreamoon and NightMarket
===========================

给 n 个正整数， 一共有 $2^n - 1$ 种子集和（排除空集）。求第 m 小的子集和
$(1 \le m \le min(10^6, 2^n - 1))$ 。\
首先，可以证明答案集合的基数不超过 20。考虑一个大小为 21 的集合，它有
$2^{21} - 2$ 个子集比它的和更小，所以这个集合不可能成为答案。\
先将元素升序排序。对于基数为 k 的集合，先选取最小的 {0, 1, 2 .. k - 1}
位置上的数构成最小集合，加入堆中。\
按如下方法迭代枚举，生成后面的集合，并依次加入堆中。\
用三元组 (a, b, c) 表示选取了 0\~a, b, c
以及后面一些位置的数（不记录）。初始集合记为 (k - 1, Ø,
Ø)。每次生成两个后继集合：\
1. 将 b 位置向后移一位，但不能到 c 位置，得到 (a, b + 1, c)。\
2. 将 0\~a 的最后一个位置即 a 向后移动一位， 得到 (a - 1, a, b)。\
这样可以保证不重不漏地枚举全部 $2 ^ k - 1$ 个非空集合，证明略。\
不同大小的集合可以共用一个堆，第 m 次出堆的元素即是答案。
