A. 2016 \[Skywalkert\]
======================

不懂大家所谓的标准做法，介绍一个普适性的做法。

对于所有的正整数
$\displaystyle n = \sum_{1 \leq i \leq \omega(n)}{{p_{n, i}}^{e_{n, i}}}$
，根据无序可重集合 $S_n = \{ e_{n, i} | i = 1, 2, \cdots, \omega(n) \}$
作为标识将 $n$ 进行分类（划分等价类）。

注意到本题的限制是 $y < x$ 里允许至多一个 $\sigma(y) > \sigma(x)$
，最坏情况下需要找出最小的两个 $y_1, y_2$ 使得
$\sigma(y) = \sigma(y_1) = \sigma(y_2)$ ，从而能确定 $x$
的取值范围上界，而每一类 $S_n$ 对应的 $\sigma(n)$ 相等（注意不同 $S_n$
也可能对应同一 $\sigma(n)$ ），不妨考虑如何找出每个 $S_n$ 对应的最小 $n$
和次小 $n$ 。

这里先介绍一下最小和次小的求法，再讲解本题的做法，建议酌情调整阅读顺序。

由排序不等式（并观察 $\ln n$ 的表达式）可知，其中最小的 $n$ 一定满足
$e_{n, i} \geq e_{n, i + 1} (i = 1, 2, \cdots, \omega(n) - 1)$ 且
$p_{n, i}$ 是第 $i$ 小的质数
$i = 1, 2, \cdots, \omega(n))$。由于它满足的性质，我们可以顺序枚举最小的一些质数来构成这些
$n$ ，复杂度和等价类的数量有关，对于 $n \leq 10^{18}$ 的情况，不同的
$S_n$ 有 32749 种，很休闲的。

次小的 $n$ 有很多的求法，我的做法依旧是写成满足
$e_{n, i} \geq e_{n, i + 1} (i = 1, 2, \cdots, \omega(n) - 1)$
的形式，只是尝试交换一下 $p_{n, i}$ 的位置。方便起见，令
$p_{n, \omega(n) + 1}$ 为第 $\omega(n) + 1$ 小的质数，且
$e_{n, \omega(n) + 1} = 0$ 。可以发现和证明次大的 $n$
一定是交换了某两个相邻的质数，且他们的幂次数不相等，找出至多 $\omega(n)$
个可能的候选值，选一个最小的即可。

接下来考虑如何找到这些有趣的 $x$ ，将所有可能的 $S_n$ 按照 $\sigma(n)$
排序，按照由大到小的顺序依次确定每种 $\sigma(n)$ 对应的 $n$
最大可以是多少即可，具体来说，只需要统计出满足 $\sigma(n') > \sigma(n)$
的最小 $n'_1$ 和次小 ${n'}_2$ ，那么上界便是 ${n'}_2 - 1$ 。

得到每种 $\sigma(n)$ 对应的 $n$ 上界后，将对应的 $S_n$ 里所有的 $n$
生成出来即可，为了保证尽量有效地生成，这次是按照幂次数降序的顺序去枚举可能的质数。由于性质太强，所需的质数也没有很大，例如
$p \leq 100$ 就是可以用实验验证的。

然后就做完了。

~~题外话：拿这个出题应该不会被寄刀片吧。~~

B. Airports \[Skywalkert\]
==========================

坐标系旋转 45
度后可以将曼哈顿距离置换为切比雪夫距离，即距离是每一维坐标之差的最大值，注意这个性质在高维也是满足的。

对于固定的 $D$
，每个点可以连边的区域是一个矩形区域的补集，不难发现这个区域可以表示成两个竖直方向上的半平面与两个水平方向上的半平面的并集，而验证图连通的方法呼之欲出，利用并查集分别在两个维度上连边，最后检查每个点与某个定点是否连通即可，如果可以很休闲地连边，那么这个题可以二分
$D$ 验证来解决。

不妨考虑竖直方向的半平面情况，所有的点可以只考虑其横坐标。将所有点按横坐标排升序，找出横坐标最小的点，它能连到的点是一个后缀区间，同理横坐标最大的点能连到的点是一个前缀区间，而其他的点可以通过连到这两个点来和其他点连通，这不会使解变差，所以要连的边数量也是
$O(n)$ 的，问题解决。

C. Jump \[Skywalkert\]
======================

不妨考虑从 $s$ 到 $t$ 进行了 $k$ 次对称，依次使用的枢轴是
$a_{i_1}, a_{i_2}, \cdots, a_{i_k}$ ，则有
$t = 2 a_{i_1} - 2 a_{i_2} + \cdots + (-1)^{k - 1} 2 a_{i_k} + (-1)^k s$
。

枚举 $k$ 的奇偶性，问题转化为求
$\displaystyle v = 2 \sum_{1 \leq j \leq k}{(-1)^{j - 1} a_{i_j}}$
所需的最小 $k$ ，注意到这个东西实际上是可以 bfs 的，那么就做完了。

D. Merge \[Skywalkert\]
=======================

难点在于如何使转移不重复计数，观察到两个序列都是排列，所以每个数字只会出现恰好两次，重复的情况只和最后两个数字的关系有关。

定义 $f(i, j, k)$ 表示当前构成长度为 $i$ 的序列，最后一个数字是 $j$
，这个 $j$ 可能来自的原序列状态为 $k$ 有多少种可能，这里的 $k$ 是两个
bit 的数字，每个 bit 的 0/1 表示 $j$ 能否转移自对应的原序列。

尝试往已经构成的序列后面添加一个数字，根据 $i, k$ 和 $j$
在排列中的位置可以知道能添加的数字有哪些可能（至多 4
种），对于每种可能，重新计算它对应的 $k$ 即可，时间复杂度 $O(n^2)$ 。

E. Mirror Rice Cake \[Constroy\] \[Skywalkert\]
===============================================

最小的蛋糕肯定是要选的，这样就得到了一个贪心算法，用归纳法证明即可证明其正确性。

F. Number Cards \[Skywalkert\]
==============================

先对每种颜色的卡进行合并，记录每种颜色出现的位置区间，并排除不合法的情况与无穷解的情况。

不妨设有 $n$ 种颜色的卡，它们出现的位置区间按照升序排序后第 $i$
小的区间为 $[L_i, R_i] (i = 1, 2, \cdots, n)$ 。

对于固定的 $M$ ，实际上需要满足的是每个区间里除右端点外不存在 $M$
的倍数，且相邻两个区间之间（含靠前区间的右端点，不含靠后区间的左端点）存在
$M$ 的倍数，写成式子便是
$\left\lfloor\frac{L_i - 1}{M}\right\rfloor = \left\lfloor\frac{R_i - 1}{M}\right\rfloor (i = 1, 2, \cdots, n)$
和
$\left\lfloor\frac{R_i - 1}{M}\right\rfloor < \left\lfloor\frac{L_{i + 1} - 1}{M}\right\rfloor (i = 1, 2, \cdots, n - 1)$
。

对于任意的 $x = L_i - 1$ 或 $x = R_i - 1$
，$\left\lfloor\frac{x}{M}\right\rfloor$ 只有至多 $2 \sqrt{x}$
种，所以上述条件可能产生变化的位置有 $O(n \sqrt{x})$ 种，对于每一段
$O(n)$ 检查是否满足条件即可。

G. Paint \[Skywalkert\]
=======================

首先根据最终序列里黑色格子的段数划分情况，再枚举操作位置的相对顺序、相互之间是否连成一段，得到一系列可能的情况（好像不超过
75
种），每个情况知道每一段黑色格子数量的上下界，对于满足至少一个情况的序列，都要产生恰好
1
的贡献，这里我的做法是计算出至少满足某几种情况的序列有多少种，直接容斥得到答案。

注意满足多种情况的意思是对应的上下界区间都要取交集，能满足超过一种情况的局面是很少的，这里可以稍微调整一下写法，例如改成搜索。

遗留问题是已知黑色格子段数和每一段黑色格子数量的上下界，求对应的局面数量，不妨设有
$k$ 段黑色格子，则至多有 $k + 1$
段白色格子，设从左至右的每段颜色相同的格子数量是
$x_1, x_2, \cdots, x_{2k + 1}$ ，则对于整体有
$\displaystyle \sum_{1 \leq i \leq 2k + 1}{x_i} = n$
，对于黑色格子有上下界限制，对于白色格子有 $x_1, x_{2k + 1} \geq 0$ 和
$x_{2i + 1} \geq 1 (i = 2, 3, \cdots, k - 1)$ ，用 ${x'}_1 = x_1 + 1$ 和
${x'}_{2k + 1} = x_{2k + 1} + 1$
去替换原变量，并容斥黑色格子的取值情况，计算组合数即可。

于是容斥套容斥套组合数就做完了，很休闲的。

H. Random Walk \[Skywalkert\]
=============================

考虑容斥，问题是在每种可能的方案里统计每个格子被第一次走过的数量，这等于每一次走过的数量减去非第一次走过的数量。

考虑计算出从任意一个点走 $k$ 步，前 $k - 1$
步都没有经过起点（可以经过其他的点多次），第 $k$
步走回起点的方案数，对于每个含有这种走法的方案（前面和后面可以有任何的走法），这种走法第
$k$ 步的贡献是 0 ，需要被减去，而走到这个起点的贡献也可能是 0
，但那样会在其他情况里被减去，所以这里不考虑。

从任意一个点走 $k$ 步第一次回到起点的方案数也可以通过容斥求得，用任意走
$k$ 步回到起点的方案减去先用 $j (0 < j < k)$
步第一次回到起点，再任意走回起点的方案即可。

I. Robots \[Skywalkert\]
========================

考虑每个机器人会被哪个机器人触发，只需要在四个方向上找向它移动的最靠近它的机器人即可，将它们之间连一条有向边，计算直走有向边的最短路即可算出每个机器人被触发的时刻，即可算出一定时间后每个机器人的位置。

J. Ropes \[Skywalkert\]
=======================

考虑树的 prufer 序列，每个点有度数减一种可能出现在序列中，而序列的长度为
$n - 2$ ，只需计算组合数即可。

K. Stains \[Skywalkert\]
========================

取一点作为基点，最终的小正方形的两个相交（并且垂直、模长相等）的边界向量为基向量，则基点到所有点的向量可以被两个基向量的线性组合表示。

利用复平面加入旋转操作，通过单位复根 $w_4$
将两个基向量表示成一个复平面的向量与整系数复向量的乘积，在该平面上可以计算一些向量的最大公约向量，满足条件的基向量一定包含最大公约向量。

求出基向量之后，只需要计算基点到所有点的向量在两个基向量的线性组合中的系数，分别求出上下界，即可得到
$K$ 。

L. String Modification \[Awcrr\] \[Skywalkert\]
===============================================

考虑贪心匹配，如果遇到 $T$
串出现多余的字符，且字符与之前的字符相同，可以考虑 $S$
串中往前找到最近的不是当前字符的字符，如果存在这样的字符，那么可以在前面加一个所需的字符，从而继续匹配下去，于是贪心就可以了。

M. Team Competition \[Skywalkert\]
==================================

对于 $n$ 是奇数的情况，枚举环上所有可能的等腰三角形即可。

对于 $n$ 是偶数的情况，先构造出 $n - 1$
个点的方案，发现如果要将新点与原来 $n - 1$
个点之间的边的统计数量增加足够，只需要底边长度为 1 或 2
的即可，注意还需要为原来的 $n - 1$
个点补充一些统计数量，具体来说，将原来的等腰三角形中腰长不为 1
的再复制一遍即可，每条边的统计数量相对 $n$ 是奇数的情况多一倍。

Summary
=======

**Skywalkert:**
心血来潮所以重新做了一遍题目，发现很多题目在现在来看是很易产生思路的，这或许是数学题比较多的缘故，rng\_58
的这套题目可以帮助巩固数学基础。现场的细节已经记不太清了，但现在想想还是能记得，我当时的心态是对队友不利的，这很危险。现在我对自己的队内定位已经清楚，希望能带动大家的积极性，共同成长。
