A. Relic Discovery \[braveTester\]
==================================

签到题。输入的每行两个数相乘后再相加。

B. Pocket Cube \[braveTester\]
==============================

签到题。由于步数小于等于
1，因此只需要枚举每个面顺时针或者逆时针旋转即可。

C. Pocky \[Skywalkert\]
=======================

猜答案：$L \leq d$ 时答案为 $0$ ，否则答案为 $\ln(L) - \ln(d) + 1$ 。

------------------------------------------------------------------------

设 $f(L)$ 表示长度为 $L$ 时走到终态的期望步数，则 $L \leq d$ 时
$f(L) = 0$ ，否则
$f(L) = \int_{0 \leq x \leq L}{p_L(x) f(L - x) dx} + 1$ ，其中 $p_L(x)$
表示长度为 $L$ 时吃掉长度 $x$ 的概率，由于是均等分布，所以有
$L \cdot (f(L) - 1) = \int_{0 \leq x \leq L}{f(L - x) dx} = \int_{0 \leq x < L - d}{f(L - x) dx}$
。

关于 $L$ 求个导，有 $f(L) - 1 + L f'(L) = f(L)$ ，即
$f'(L) = \frac{1}{L}$ ，积分得 $f(L) = \ln(L) - \ln(d) + 1$ 。

D. Lucky Coins \[Skywalkert\]
=============================

第 $i$ 种硬币在第 $k$ 轮后剩下至少一枚硬币的概率是
$1 - (1 - p_i^k)^{c_i}$ 。

可以计算出每种硬币恰好在第 $k$ 轮结束的概率，从而计算出每种硬币在第 $k$
轮结束时获胜的概率。

由于 $0.4 \leq p_i \leq 0.6$ ，答案关于 $k$ 收敛很快， $k$
较大时迭代精度已经足够，所以枚举 100 轮左右即可得到较好的结果。

E. Fibonacci \[Skywalkert\]
===========================

定义 $L(p)$ 是对于任意非负整数 $x$ 满足 $f(x) \equiv f(x+L(p)) \pmod{p}$
的最小正整数，也就是 $f(x)$ 在模 $p$ 意义下的循环节。因为
$\det(\begin{bmatrix}0&1\\1&1\end{bmatrix})=1$ ，所以 $L(p)$ 始终存在。

基于以上定义对序列做如下观察：

-   计算 $x(1) \equiv f(x(0)) \pmod{p}$ 需要知道 $x(0) \bmod L(p)$ 。
-   计算 $x(2) \equiv f(x(1)) \pmod{p}$ 需要知道 $x(1) \bmod L(p)$
    ，从而需要知道 $x(0) \bmod L(L(p))$ 。
-   计算 $x(3) \equiv f(x(2)) \pmod{p}$ 需要知道 $x(2) \bmod L(p)$
    ，从而需要知道 $x(1) \bmod L(L(p)), x(0) \bmod L(L(L(p)))$ 。

所以计算 $x(n) \bmod p$ 需要知道 $x(0) \bmod L^n(p)$
，从而可以依次计算出 $x(i) \bmod L^{n-i}(p)$ ，这里定义 $L^0(p) = p$ 。

对于$L(m)$ 有以下结论：

-   若 $m$ 为合数，且 $m = \prod_{i} {p_i^{k_i}}$ ，则 $L(m)$ 是
    $L(p_i^{k_i})$ 的最小公倍数。
-   若 $m$ 为质数的高次幂，且 $m = p^k (k > 1)$ ，则 $L(m)$ 的循环节整除
    $p^{k - 1} L(p)$ 。（对已知的素数来说，整除可以改为等于）
-   若 $m = 2$ ，或 $m$ 为奇质数，且 5 不是模 $m$ 的二次剩余，则 $L(m)$
    整除 $2(m + 1)$ 。
-   若 $m$ 为奇质数，且 5 是模 $m$ 的非平凡二次剩余，则 $L(m)$ 整除
    $m - 1$ 。
-   若 $m$ 为奇质数，且 5 是 $m$ 的倍数，则 $L(m)$ 整除 $m^2 - m$ 。

为了简化计算，以上整除均视为等于，这样得到的 $L$ 是 $L(m)$
的倍数，可以代替其进行计算，记为 $L'(m)$。

基于以上结论对${L'}^n(p)$ 做如下观察：

-   ${L'}^n(1) = [1, 1, \cdots]$
-   ${L'}^n(2) = [2, 3, 8, 12, 24, 24 \cdots]$
-   ${L'}^n(3) = [3, 8, 12, 24, 24 \cdots]$
-   ${L'}^n(4) = [4, 6, 24, 24 \cdots]$
-   ${L'}^n(5) = [5, 20, 60, 120, 120 \cdots]$
-   ${L'}^n(6) = [6, 24, 24 \cdots]$
-   ${L'}^n(7) = [7, 16, 24, 24 \cdots]$

可以发现当 $n$ 充分大时 ${L'}^n(p) = {L'}^{n+1}(p)$ 。

设 $N$ 是满足 ${L'}^N(p) = {L'}^{N+1}(p)$ 的最小正整数，且
$M = {L'}^N(p)$ 。

经过打表发现，对于 $p \leq 200000$ ，这样的
$N \leq 15, {L'}^n(p) \leq 1800000$ 。

对 2, 3, 5 的幂次变化进行讨论即可发现和证明 $N = O(\log p), M = O(p)$ 。

因此做法很显然需要枚举 $n$ ，尝试计算 $x(n) \bmod p$ 进行检查。

当 $n \leq N$ 时，$O(n \log p)$ 迭代计算答案。

当 $n > N$ 时，有 $x((n-N)+1) \equiv f(x(n-N)) \pmod{M}$ ，因此只有
$O(M)$ 个 $n$ 需要计算，每个 $n$ 可以 $O(N \log p)$ 迭代计算答案。

所以整体的复杂度是 $O(NM \log p) = O(p \log^2 p)$ 。

F. Lambda Calculus \[Skywalkert\]
=================================

由于输入是合法的，因此可以改写文法，降低编程复杂度，例如
$\text{LcExp ::= Variable | lambda (Variable) | (LcExp LcExp)}$ 。

用栈维护带有属性(+/-)的集合，集合合并使用启发式合并即可。

G. Coding Contest \[Constroy\]
==============================

H. Pattern \[braveTester\]
==========================

给定一个 $N \times M$
的矩阵，以及某些点的四连度数，设在给定限制下补全全图后的度数矩阵有 $K$
种，共有 $P_i$ 种方式得到第 $i$ 种度数矩阵，求 $$
\left(\sum_{i = 1}^{K}{P_i}^2\right) \% 10007。
$$ 其中 $N \le 66，M \le 6$。

将原式变换一下： $$
\begin{align}
\sum_{i = 1}^{K} {P_i}^2 &= \sum_{i = 1}^{K} \left(\sum_G{[\text{$G$ is pattern $i$}]}\right)^2\\
&= \sum_{i = 1}^{K} \sum_G \sum_{G'} [\text{$G$ is pattern $i$}][\text{$G'$ is pattern $i$}]\\
&= \sum_G \sum_{G'} \sum_{i = 1}^{K} [\text{$G$ is pattern $i$}][\text{$G'$ is pattern $i$}]\\
&= \sum_G \sum_{G'} [\text{$G$ and $G'$ have same pattern}]。\\
\end{align}
$$ 最后的和式可以用双插头 DP 求出。插头状态表示为维护 6 条横线和 1
条竖线共 7 条界限上有没有插头伸出来。令 $f[i][j][S][S']$
为到两个插头状态分别为 $S$ 和 $S'$，且对应的两张图 $G$ 和 $G'$
的度数矩阵在 $(i, j)$ 之前（不含 $(i, j)$）保证相同时的方案数，则
$f[N][M][0][0]$ 即为答案。

复杂度 $O(NM2^{N+M + 2})$。

HDU 居然丧病的卡时...加个“正推时如果 f 为 0 就不做 16
的循环”优化才给过...

I. Travel Brochure \[Skywalkert\]
=================================

观察到
$(a_{j+1} - a_{j}) \frac{b_{j} b_{j+1}}{a_{j} a_{j+1}} = \frac{b_j}{a_j} b_{j + 1} - \frac{b_{j+1}}{a_{j+1}} b_j$
，将 $(\frac{b_j}{a_j}, b_j)$
视为二维平面上的点，所求最大值即凸包的面积。

J. Cliques \[Skywalkert\]
=========================

由于不存在重边，则任意三个点之间的边数必须为 $0, 1, 3$
才满足每个连通块是团，边数为 $2$ 则必须要修改其中一对点之间的连通关系。

预处理出任意三个点之间的边数，任意选一个边数为 $2$
的三元组，尝试三种可能的变化，搜索十步即可。

K. Finding Hotels \[Constroy\]
==============================

L. Tower Attack \[Skywalkert\]
==============================

套路题。考虑树上的任意一个点集 $S$，定义 $dim(S)$ 是任意一个满足
$u, v \in S$ 且 $dist(u, v)$ 最大的二元组 $(u, v)$ ，那么 $dim(S + T)$
一定是 $dim(S)$ 和 $dim(T)$ 这四个点中的两个，更一般化地也可得出
$u \in S, v \in T$ 的结论。

现在删去两条边，相当于将 dfs
序列划分成五个部分，由这五个点集合并得出实际的三个连通块的直径即可。

计算 $dist(u, v)$ 涉及到求 lca ，可以用 $O(n \log n)$ 先预处理出 lca
，之后 $O(1)$ 查询。

dfs 序列上的区间 $dim(S)$ 也可以 $O(n \log n)$ 预处理出来 $O(1)$
查询，用线段树查询会导致常数变大。

M. Generator and Monitor
========================

Summary
=======

**Constroy:** 这场出了许多状况，开始的时候我发现 E
像是唐题，交给唐之后感觉有些难度。然后发现 C
的样例很有名堂，就把我观察的规律告诉了唐，唐拿 Python 验证了一下就 Y
了。然后我开始想 D，发现很难，唐深陷于
E。这个过程中刘保持了输出，稳住了节奏。\
我把 D 交给状态不错的刘，自己去写
G。中途遇到了一些坑，包括费用是否取对数，比较是否加
eps，然而最致命的错误是我算费用的时候忘了乘流量！挂了之后赶紧换唐上去写
E，等了很久打印都没来（后来知道一台打印机坏了）。唐的 E 出错了，我的 G
又没法静态查错，当时有点恼火，一冲动就乱交了几发。还好唐把 E
改对了，我冷静下来，测了几组数据，发现了自己的错误。带着一吨的罚时终于通过了，这时打印却送了过来。\
时间不多了，唐码不停题搞出了 F，在刘的 Hack 之后顺利通过。还剩大概
50min，D 过的队伍很多，然而我们三个一筹莫展。我只好掏出板子写
K，最后一分钟写完交上去，就断电了。滚榜的时候发现 K 绿了，过 7 题排名第
6，有惊无险。不过下次可能就没这么幸运了。

**Skywalkert:** ~~开场一脸智障地找上 E
开始想，发现循环节和下标的循环节可能不同然后狗带。此时队长给我讲了下 C
，而且发现 $f(n^2) = 2 f(n) - 1$ 和 $f(ab) = f(a) + f(b) - 1$ ，抢来键盘
py 了一下找出公式干掉了。然后继续搞 E
，半个小时过后终于理清了循环节的循环节与循环节的关系，开始手玩循环节的表，发现很快就迭代到环了，而且环长几乎是
1 ，后来队长贡献出机子准备静态查 G ，我就开始 py
搞这个迭代，搞出来发现真的不大，然后就搞搞搞弄过去啦。打印机狗带了以及我乱搞太慢了，队长搞掉
G 已经是后期了 ，QAQ虚的不行，于是赶紧各种 STL 乱上把 F
搞掉了，和学弟瞪着 D 发呆到比赛结束。~~
感觉这场运气占了很大成分，想题的过程还是没走对路子，以及技能缺失过重
`>_<` ，需要补补课。

**braveTester:** 开场上来过了签到 A。然后一看 B
也是个签到，就是细节有些麻烦，但只要细心还是可以过的，于是把机子交给队友，下去想了想实现。在队友没题的空隙慢慢把
B 码了出来，1 A 很开心。然后就开始读题为队友传递题意。发现 F
也是个简单题，不过需要很细心。唐老师搞出 F 后 Hack 了一发然后 1 A
很开心。然后就是看着板刷的 D 一筹莫展。最可惜的大概算是 I
了。唐老师明明都看出了模型，可惜我题意传达不清，也没有仔细验过样例，不然一个凸包板应该就可以过了。概率和几何还是差的太多...没有系统的分析方法，见的世面也太少了，急需补充。
