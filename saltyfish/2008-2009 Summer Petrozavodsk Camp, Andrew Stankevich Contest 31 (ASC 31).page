A Casino \[zyh\]
================

dp\[i\]\[j\]表示玩i次之后在初始金钱为j的情况下的胜率，那么有$dp[i][j]=max_{k=1}^{m}(\frac{p[k]}{s}dp[i-1][j+w[k]]+\frac{s-p[k]}{s}dp[i-1][j-1])$，并且当j&gt;n时概率总为1，j&lt;=0时概率总为0，不断迭代，卡时~~，其实收敛挺快的迭代1000次就能过~~

B Chip Reconstruction \[hwq补\]
===============================

相当于有若干条长度为h的线段，线段端点位置可以根据a数组求出，然后贪心将每条线段放入能放且需求量最大的列中即可。**注意判断线段条数和需要量之和是否相等的情况**

C Convex Hull \[zyh补\]
=======================

自适应simpson积分

D Discussions \[zyh补\]
=======================

相当于给定一个z，求最小的n使得存在k满足$\binom{n}{k}=z$，由于$\binom{n}{k}=\binom{n}{n-k}$，不妨设$k\leq \lfloor \frac{n}{2} \rfloor$，那么当k比较大时，n的值不会太大，暴力枚举组合数，当k比较小时，暴力枚举k然后二分n来解方程，取阈值为100即可

E Yet Another Game with Words \[zyh补\]
=======================================

对所有子串hash，然后建立hash值到状态的映射，强行搜出胜败态，~~直接冲是会TLE的但是随便剪剪枝就能过，~~科学做法是用三元组(i,j,k)表示一个子串，对子串进行去重，然后建立三元组到状态的映射

F Merge \[ghc\]
===============

为了找出第k大的数，考虑枚举所有大小为k的集合，所有这样的集合中最大值的最小值即为所求，由于x\[\]和y\[\]有序，只需分别取出前若干个

G The Most Relevant Pattern \[hwq\]
===================================

对每个s串的后缀最小表示一下，hash后缀的所有前缀，相当于得到了所有s的子串的最小表示的hash值，计算相同的hash值个数并构造解

H Straight or Flush \[zyh补\]
=============================

对于第一问，dp\[i\]\[j\]\[k\]\[0/1\]表示考虑到第i种rank，已经选了j张牌，当前已经连续选了k种rank，是否已经存在Straight的方案数，对于第二问，dp\[i\]\[j\]\[0/1\]表示考虑到第i种suit，已经选了j张牌，是否已经存在Flush的方案数，Java大数

I No Term Repetition Exactly One Satisfiability \[hwq补\]
=========================================================

每个括号向汇点连，流量为1，每个变量新增正负两点，变量向这两个点连边，流量为1，每个正/负值向出现该值的括号连边，流量为1，源点向每个变量连边，流量为1。考虑正负值都出现的变量必须要流正负中的一边，源点连向此类点的费用为-1，表示强制先考虑这些点。最终汇点满流且费用为**-正负值都出现的变量数**则有解，根据网络构造即可

J Trading Game \[hwq补\]
========================

读入很恶心，把每个原料拆成三部分xyz，考虑1号玩家如果第i种原料多了，那么从源点向i的x部连边，否则从i的y部向汇点连边，对于其他人，如果第i种原料多了，此人向i的z部连边，表示这种原料可以py出去，否则从i的x部向此人连边，表示把原料py进来，对于每种原料i，从i的z部分别向x和y部连无穷边，表示继续py或盖房子，验证是否满流即可，输出方案直接dfs

K Parse Tree \[ghc补\]
======================

模拟，根据题意建出表达式树然后按照规则打印，建树考虑递归下降，每次找出作为根的运算符（优先级最低且不在任何一个括号内的）将表达式划分，递归处理，如果当前处理的这一段表达式两侧是匹配的括号，直接扔掉即可
