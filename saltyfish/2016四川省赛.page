A Nearest Neighbor Search \[ghc\]
=================================

求出区间$[x_1,x_2]$内的数与$x_0$差的绝对值的最小值，对$y$和$z$也求出对应的值，然后加起来即为所求

B Odd Discount \[zyh&ghc\]
==========================

记$cnt_i$表示$i$的二进制表示下$1$的个数，$b_i$表示第$i$种优惠的物品集合，$[x]$表示如果命题$x$为真那么$1$否则$0$，于是$$ans=\sum_{i=1}^{2^n-1}(\sum_{j=1}^{m}[cnt_{i\&b_j}\ mod \ 2=1]c_j)^2=\sum_{i=1}^{2^n-1}\sum_{j_1=1}^{m}\sum_{j_2=1}^{m}[cnt_{i\&b_{j_1}}\ mod \ 2=1][cnt_{i\&b_{j_2}}\ mod \ 2=1]c_{j_1}c_{j_2}=\sum_{j_1=1}^{m}\sum_{j_2=1}^{m}c_{j_1}c_{j_2}\sum_{i=1}^{2^n-1}[cnt_{i\&b_{j_1}}\ mod \ 2=1][cnt_{i\&b_{j_2}}\ mod \ 2=1]$$其中$$\sum_{i=1}^{2^n-1}[cnt_{i\&b_{j_1}}\ mod \ 2=1][cnt_{i\&b_{j_2}}\ mod \ 2=1]=(b_{j_1}=b_{j_2}\ ?\ 2^{n-1}\ :\ 2^{n-2})$$这是因为如果$b_{j_1}=b_{j_2}$那么实际上就是一个限制条件，集合外的任意取，集合内的留下一个其余任意取，否则并集外的任意取，交集内的任意取，恰好属于一个集合的各自留下一个其余任意取

C Eight Queens
==============

D Longest Common Subsequence \[zyh补\]
======================================

$dp[i][j]$表示$b[]$的前$i$段和$a[]$的前$j$个数的$LCS$，假设现在考虑到第$i$段，要用$dp[i-1][\cdot]$去更新$dp[i][\cdot]$，枚举$LCS$在第$i$段中的长度$k$，对于$dp[i][j]$，如果$a[p..j]$中能找到恰好$k$个$b[]$的第$i$段中的元素（这里每个元素只能被找一次），那么可以用$dp[i-1][p-1]+k$更新$dp[i][j]$，因为$dp[i-1][\cdot]$是不减的，显然$p$越大越好，从$1$到$n$枚举$j$，维护$a[p..j]$中每种数的个数以及在$b[]$的第$i$段中能找到的元素个数然后滑窗，复杂度是$O((n+l)m)$的

E Coins \[ghc\]
===============

首先讨论面值为1和2的硬币的有无，若两者都有，则能取到从1到a+2\*b+3\*c的所有面值；若有1没有2，需要考虑1的个数是否大于1，若大于1，则能取到从1到a+3\*c的所有面值，否则只能取到模3余1的面值（c+1种）和3的倍数（c种），共2\*c+1种；若1和2都没有，答案显然是c；若有2没有1，若没有3，答案就是b，否则情况比较复杂，这里将能取到的面值按模3的余数分开考虑：3的倍数有b/3\*2+c种，模3余1的，首先用两个2得到4（若没有两个2，这部分答案为0），然后用剩下的2和3构成3的倍数，于是这部分答案为(b-2)/3\*2+c，模3余2的，首先拿出一个2，然后用剩下的2和3构成3的倍数，这部分答案是(b-1)/3\*2+c，将三部分答案相加即可

F Floyd-Warshall \[hwq&ghc\]
============================

取出一棵生成树之后还有100条非树边，得到200个关键点，从每个关键点出发BFS出最短路，每次查询如果不过非树边那么就是树上最短路，否则枚举经过的非树边

G Road History \[zyh\]
======================

对于一个连通块，如果是二分图，贡献是两部分点数之积，否则贡献是点对个数

H Around the World \[zyh\]
==========================

给图定向，每条边有一半的方向是一样的，之后根据[BEST
theorem](https://en.wikipedia.org/wiki/BEST_theorem)计算定向后的图中欧拉回路的个数，注意对于同一个欧拉回路，第一步走的方向不同会得到不同的行走方案

I Longest Increasing Subsequence \[zyh&hwq\]
============================================

搜出n个数的大小关系，按照从小到大的顺序dp

J Matrix Transformation \[hwq\]
===============================

炫酷球形链表（双向循环十字链表）
