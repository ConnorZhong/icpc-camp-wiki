# A HHPaint [zyh&ghc]

先求出凸包，选凸包上一个点作为原点向凸包上其他点连边，凸包会被划分成若干个三角形，每个三角形内的点向原点连边，然后对这些点以及三角形除原点外的另外两个顶点求凸包，如果下一个点向右转，那么这个点与栈顶两个点做一个三角形，然后弹栈，直到下一个向左转

# B Square Root [hwq&zyh]

给原数乘上$10^{2k}$，用$x=(x+n/x)/2$（这里除法是下取整）迭代，再将结果除以$10^k$~~，Java大法好~~

# C Interesting Places [ghc补]

边双缩点后得到若干棵树，把所有树连成一棵树，要求所得树的叶子数尽可能少（这需要在连接两棵树时，优先通过叶子进行连接），然后对于这棵树，先求带权重心（叶子权为1其他为0），拆分出若干子树，每次从叶子最多的两棵子树中各选一个叶子连起来，如果最后剩下一个叶子则任连一个其他子树的叶子，这样保证连出的边总是覆盖一条经过重心的树上路径，最后所有树边都能被覆盖

# D Road to Home

# E Ant and apples [hwq&ghc&zyh]

need[i]表示走i这棵子树需要的能量，delta[i]表示走i这棵子树能量的变化量，考虑i的子树，按能量变化的正负分类，如果为正则优先考虑需要能量较小的走法，否则优先考虑需要能量加上变化量较大的

# F Square

[这里](https://async.icpc-camp.org/d/569-2016-2017-ct-s03e02-f-square)有讨论，还要研究一下为什么这么做是work的

# G Pair [hwq&zyh]

枚举k，然后枚举k的倍数，复杂度是O(nlogn)的

# H The Fence [hwq]

求一组(i,j)，满足对应位置为1且i-j+1为k的倍数，按mod k分类即可，注意k=1的情况

# I Painting the natural numbers [hwq&zyh&ghc]

构造，s[0]="0"，s[i]=s[i-1]+"ii0ii0ii0...ii0ii"+s[i-1]，中间一段的长度为len(s[i-1]+1)，这样len(s[i])=3len(s[i-1])+1，于是len(s[9])>25000。正确性考虑归纳证明，显然s[0]符合条件，对于s[i]，因为0所在位置(1-based)满足mod 3=1，两个0位置相加不可能还是0的位置，对于左边，根据归纳假设知满足条件，对于中间，两个i位置相加至少是2len(s[i-1])+2，大于最后一个i的位置，对于右边，显然任意两个位置相加均大于串长，对于左边和右边相同的数，只可能是左边+右边=右边，右边的位置同时减去2len(s[i-1])+1之后得到左边+左边=左边，这是不可能的

# J Selection [hwq&ghc]

求出奇数的个数$x=\lceil \frac{n}{2} \rceil$和偶数的个数$y=\lfloor \frac{n}{2} \rfloor$，答案即为$\binom{x}{2}\binom{y}{1}+\binom{y}{3}$

# K Parquet [hwq&zyh]

若n>1且m>1且n*m被6整除则可行，证明是容易的

# L Closing the Loop [hwq&ghc]

显然红蓝要取数量相等多个，按长度从大到小取尽可能多就好了