# A 2016 [zyh补]

枚举两边mod 2016的值，计算贡献

# B 有向无环图 [zyh补]

dp[u]表示从u出发能到达的所有v的count[v]*b[v]之和，那么u的一个后继v对dp[u]有dp[v]+b[v]的贡献，按照反向拓扑序dp

# C Three Capitals [zyh补]

给图定向，需要枚举某两个点之间的边定为某个方向的个数，进而求得任意两点之间每种方向的边的个数，之后根据[BEST theorem](https://en.wikipedia.org/wiki/BEST_theorem)计算定向后的图中欧拉回路的个数，注意对于同一个欧拉回路，第一步走的方向不同会得到不同的行走方案

不依赖于BEST theorem也能解决此题，待补

# D Toll [zyh补]

~~注意到从1到n的任意一条路径长度都形如ct+d，考虑对每个c(显然不大于1000n)求出最小的d，那么答案即为这些直线的min在[0,T]上的积分，实际上是很多梯形或者三角形的面积之和。~~直接自适应simpson积分，求f(t)相当于把t带进去跑最短路

# E 最长上升子序列 [zyh补]

记loc[i]表示i的出现位置，未出现标为-1，首先考虑n，

1.若n不在位置n

1)若n也不在位置n-1，那么删去n之后一定是1,2,3,...,n-1，找出满足loc[i]=i的最大i以及满足loc[j]=j+1的最小j，那么对[1,i]内的每个k均有loc[k]=k或-1，对[j,n]内的每个k均有loc[k]=k+1或-1，并且n可能的位置在[i+1,min(n-2,j)]内，只需判断值位于[i+1,min(n-2,j))内的数是否都是未确定的

2)若n在位置n-1，那么前n-1项构成一个递增序列，相当于找一个数扔到位置n，如果p[n]已确定，判断[1,p[n]-1]内的所有k是否均有loc[k]=k或-1，判断[p[n]+1,n]内的所有k是否均有loc[k]=k-1或-1，如果p[n]未确定，找出满足loc[i]=i的最大i以及满足loc[j]=j-1的最小j，那么对[1,i]内的每个k均有loc[k]=k或-1，对[j,n]内的每个k均有loc[k]=k-1或-1，并且可能被扔到右边的数的值在[i+1,min(n-1,j-1)]内，只需判断值位于这个区间内的数是否都是未确定的

2.若n在位置n，删去n之后得到规模为n-1的相同问题

# F 地铁 [zyh补]

对每个换乘站拆点，每个点分属于一条线路，站与站之间根据线路连边，对于换乘站拆出来的点，把这些点根据所属线路编号从小往大连边，然后跑多源多汇最短路

# G Parenthesis [zyh补]

记'('为1，')'为-1，做一个前缀和，只有把位于左边的'('与位于右边的')'交换才可能导致不合法，此时区间[min(a,b),max(a,b))内所有数都-2，如果最小值<2那么不合法

# H Reverse [zyh补]

分两部分计算贡献，一部分是每个位置不在操作区间内时的贡献，只需计算有多少个区间不影响当前位置，另一部分是每个位置在操作区间内的贡献，对于位置i，考虑计算把i换到[i+1,n-i]这个区间内的贡献，对于区间内每个位置，都有恰好i种操作能把i换到这个位置，同时会把这个位置上的数换到位置i，对于位置n-i+1类似分析，然后补上i仍在i、n-i+1仍在n-i+1、i和n-i+1互换这三种情况的贡献

# I Tree Intersection [zyh补]

相当于对每条边求两侧都有的颜色数，启发式合并求出每个子树中每种颜色的个数，那么对于当前点往上延伸的这条边的答案就是当前子树中存在并且未满的颜色种类数

# J 三角形和矩形 [zyh补]

先用两个矩形求交，再沿着三角形对角线切开

# K 盖房子 [zyh补]

利用单调栈维护正交凸包，求出以每个格子为左上、左下、右上、右下角的矩形个数

枚举一个格子作为右下角，在右下角的L型区域内枚举一个格子作为左上角，方案数相乘加进答案，类似枚举右上角和左下角

![](/human2016_K.png)

在这个过程中每一对不相交矩形似乎会被计算两次，但是实际上有重复计算的部分

![](/hunan2016_K2.png)

对于这种情况，枚举一个格子作为右上角，在对角区域内枚举一个格子作为左下角，类似枚举右下角和左上角

减掉这种情况之后每一对不相交矩形恰好被计算两次