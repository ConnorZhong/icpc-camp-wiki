A.Monotonic Matrix \[wjy\]
==========================

B.Symmetric Matrix \[wjy\]
==========================

C.Fluorescent 2 \[补:wjy\]
==========================

将立方的括号打开，转化为$\sum{xi*xj*xk}$。可证只与对应矩阵的秩有关。从头扫一遍，对(i,j)按消元结果分组，就可以计算(i,j,k)按秩分组的各个结果。

D.Two Graphs \[wjy\]
====================

暴力枚举各种匹配，进行检验即可。

E.Removal \[zlc\]
=================

我的 $dp$ 方程比较恶心，$dp[i][j][k]$ 表示
$第 i 个位置，前面有 j 个，最后数字为 k 的方案数$

观察到重复计算的之和 $最后删除的一段含有最后一个字符$ 有关，所以直接
$dp$ 去掉，复杂度是 $O(n*m*m*k)$，可以差分去掉一个 $m$

F.Sum of Maximum \[zlc\]
========================

$sort$ 一遍然后算出公式有个 $\sum{x^k}$
，这个式子不好求。。用伯努利数可以
$O(n^2)$，拉格朗日插值可以$O(n^2logn)$

G.Steiner Tree \[补:zlc\]
=========================

看着 $tls$
的[题解](https://www.nowcoder.com/discuss/87241?type=101&order=0&pos=16&page=1)补掉了，主要思路是按照普通斯坦纳树的方法，分成两部分来做，第一部分子集卷积，第二部分
$dijkstra$
同时记录路径条数（这里长度都是1，所以也可以按长度基数排序）即可

H.Longest Path \[补:wjy,zlc\]
=============================

wjy：分为向上与向下的。向下的O(n)dfs一下即可。对于向上的涉及到在某个结点的不同子节点合并。dp方程为斜率优化的形式。正向反向处理一遍即可。

zlc：区别：我斜率优化那里用的是 $set$，要慢一点常数

I.Substring \[补:wjy,zlc\]
==========================

枚举同构后求不同的子串个数。其中只有只含一种字符的只被计算3次，其余的均被计算6次，将差的补上后除6即为所求。求不同的子串个数使用广义后缀自动机即可。

J.Different Integers \[wjy\]
============================

将整个序列复制一份就转化为了求解区间多少种不同的整数个数。可以$n^{3/2}$莫队，也可以离线树状数组
$nlogn$，或主席树在线 $nlogn$

Summary
=======

zlc：全靠嘉翼 $carry$ ，我这场做一道挂一道
