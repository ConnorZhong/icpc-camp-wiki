A.
==

B.
==

C.
==

D.
==

E.
==

F.
==

如果字符串A的子串B在A中出现了至少三次并且B既是A的前缀也是A的后缀，那么就称B是A的特殊子串。

给定字符串S，求S的所有前缀的最长特殊子串的长度和。|S|&lt;=5\*10\^5

考虑KMP算法的next数组，next\[i\]表示S(1,i)的最长的既是前缀又是后缀的子串的长度。

如果存在 j &lt; i, next\[j\] &gt;=
next\[i\]，那么我们可以在S(1,i)中找出一个长度为next\[i\]的"特殊子串"。

更一般地，如果存在 j &lt; i，next\[j\] &gt;=
p，S(1,i)长度为p的前缀同时也是后缀，那么我们可以在S(1,i)中找出一个长度为p的"特殊子串"。

``` {.cpp}
int p = next[i];        
while(p && !find(p)) p = next[p];
```

其中find函数查询是否存在 j &lt; i, next\[j\] &gt;= p

这样我们就能找到最大的满足条件的p。

现在我们证明，调用find函数的次数是O(n)的。

while循环结束后，对于每个遍历过的p，都存在next\[i\]&gt;=p

所以**对于每个p，find函数返回false最多一次**

一旦find函数返回true,循环结束，所以find函数最多被调用2n次。
